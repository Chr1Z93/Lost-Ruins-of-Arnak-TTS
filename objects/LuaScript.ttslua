---@diagnostic disable: param-type-mismatch, assign-type-mismatch
-- originally scripted by jkk - https://steamcommunity.com/id/creamymello/myworkshopfiles/
-- updated by Chr1Z and covertskippy55 for the missing expedition

testVars = {
  defineSeated = true,
  seatedPlayers = { 'Blue', 'Green', 'Yellow', 'Red' }
}

playerVars = {
  Red = {
    allZoneGuid = 'b32bc6',
    playAreaZoneGuid = '472eb8',
    refZoneGuid = '545a04',
    deckZoneGuids = {
      base = 'fb8591',
      leader = '474558',
      mystic = '06e359',
      journo_Mech = 'f203ae'
    },
    mysticRitualPosition = { -66.15, 1.6, 20.72 },
    researchTokens = {
      magnifying = '3ac5a9',
      notebook = 'a70c8f'
    },
    pawns = { 'b2d015', '47658b', 'bfb9eb' },
    pawnPositions = {
      { -24.91, 2.30, 24.03 },
      { -28.33, 2.30, 24.41 },
      { -26.38, 2.30, 25.02 } },
    tentGuid = '2cbeb3',
    tentZoneGuid = 'cc542a',
    trashGuid = 'b0f01b',
    resourceBags = {
      t = '7cf312',
      a = 'b5027a',
      j = '2e0235',
      c = 'ea5777',
      s = 'e10365'
    },
    resourceBagZones = {
      t = 'e757ed',
      a = 'd0f92a',
      j = 'b56916',
      c = 'cbf8fd',
      s = '0a749b'
    },
    suitcaseResourceBagZones = {
      t = '223031',
      s = '4b2360'
    },
    suitcasePosition = { -26.50, 1.53, 8.80 },
    falconPositions = { { -44.93, 1.63, 17.46 }, { -42.37, 1.63, 16.26 }, { -39.69, 1.63, 16.98 }, { -38.49, 1.63, 19.27 }, { -38.26, 1.63, 21.99 } },
    archivePositions = { { -67, 1.50, 20.30 }, { -67, 1.50, 13.10 }, { -67, 1.50, 5.90 } },
    foodPositions = { { -38.18, 1.63, 22.27 }, { -38.18, 1.63, 19 }, { -38.18, 1.63, 15.75 } },
    articlePosition = { -24, 1.57, 16.80 },
    goldenTeethPosition = { -24, 1.57, 16.80 },
    refPositions = { { -53, 1.48, 28.5 }, { -47, 1.48, 28.5 } },
    firstPlayerPosition = { -26.60, 1.53, 28.75 }
  },
  Blue = {
    allZoneGuid = 'd9da53',
    playAreaZoneGuid = '67c9fd',
    refZoneGuid = '9ba49e',
    assistantZoneGuid = 'ca1026',
    deckZoneGuids = {
      base = '251ebb',
      leader = 'c59a9b',
      mystic = 'a3aaf8',
      ritual = '339af9',
      journo_Mech = 'c59a9b'
    },
    mysticRitualPosition = { 35.85, 1.60, 20.72 },
    researchTokens = {
      magnifying = '1a305e',
      notebook = '96a124'
    },
    pawns = { 'c8a97b', 'ddd08f', '822412' },
    pawnPositions = { { 28.29, 2.30, 24.02 }, { 24.87, 2.30, 24.41 }, { 26.82, 2.30, 25.02 } },
    tentGuid = '46fb5e',
    tentZoneGuid = '2b78f5',
    trashGuid = 'c1c247',
    resourceBags = {
      t = 'd40949',
      a = '20ff93',
      j = '70714a',
      c = 'bcf902',
      s = '65efcd'
    },
    resourceBagZones = {
      t = 'c197da',
      a = '2e1fe3',
      j = '8e0e22',
      c = '12d02d',
      s = '5c8abb'
    },
    suitcaseResourceBagZones = {
      t = 'f923b7',
      s = '7c33b6'
    },
    suitcasePosition = { 26.60, 1.53, 8.80 },
    falconPositions = { { 48.21, 1.63, 17.42 }, { 50.81, 1.63, 16.26 }, { 53.48, 1.63, 17.01 }, { 54.66, 1.63, 19.34 }, { 54.86, 1.63, 22.07 } },
    archivePositions = { { 67, 1.50, 20.30 }, { 67, 1.50, 13.10 }, { 67, 1.50, 5.90 } },
    foodPositions = { { 54.99, 1.63, 22.30 }, { 54.99, 1.63, 19.03 }, { 54.99, 1.63, 15.78 } },
    articlePosition = { 29.20, 1.57, 16.80 },
    goldenTeethPosition = { 29.20, 1.57, 16.80 },
    refPositions = { { 53, 1.48, 28.5 }, { 47, 1.48, 28.5 } },
    firstPlayerPosition = { 26.60, 1.53, 28.75 }
  },
  Green = {
    allZoneGuid = '05b782',
    playAreaZoneGuid = 'df8647',
    refZoneGuid = '25eec1',
    assistantZoneGuid = '1d601a',
    deckZoneGuids = {
      base = '033194',
      leader = '56a26a',
      mystic = '1947cf',
      ritual = '603a7b',
      journo_Mech = '56a26a'
    },
    mysticRitualPosition = { 35.85, 1.60, -20.28 },
    researchTokens = {
      magnifying = '975b98',
      notebook = '6cf350'
    },
    pawns = { '609cfd', 'ddc20b', 'b4abfd' },
    pawnPositions = { { 28.29, 2.30, -16.98 }, { 24.87, 2.30, -16.59 }, { 26.82, 2.30, -15.98 } },
    tentGuid = '5a9adf',
    tentZoneGuid = '5717d6',
    trashGuid = '9c24a7',
    resourceBags = {
      t = '9bf040',
      a = '64418c',
      j = 'da3f08',
      c = '590b1a',
      s = '8b0cb8'
    },
    resourceBagZones = {
      t = 'f4d753',
      a = '067ec4',
      j = '37db2d',
      c = '4eab66',
      s = 'b8b628'
    },
    suitcaseResourceBagZones = {
      t = '4d7b3f',
      s = '9e8531'
    },
    suitcasePosition = { 26.60, 1.53, -32.20 },
    falconPositions = { { 48.21, 1.63, -23.58 }, { 50.81, 1.63, -24.74 }, { 53.48, 1.63, -23.99 }, { 54.66, 1.63, -21.66 }, { 54.86, 1.63, -18.93 } },
    archivePositions = { { 67, 1.50, -20.70 }, { 67, 1.50, -27.90 }, { 67, 1.50, -35.10 } },
    foodPositions = { { 54.99, 1.63, -18.70 }, { 54.99, 1.63, -21.97 }, { 54.99, 1.63, -25.22 } },
    articlePosition = { 29.20, 1.57, -24.20 },
    goldenTeethPosition = { 29.20, 1.57, -24.20 },
    refPositions = { { 53, 1.48, -12.5 }, { 47, 1.48, -12.5 } },
    firstPlayerPosition = { 26.60, 1.53, -12.25 }
  },
  Yellow = {
    allZoneGuid = '19cc4f',
    playAreaZoneGuid = '7a5b2c',
    refZoneGuid = '332924',
    deckZoneGuids = {
      base = 'ec6a31',
      leader = 'a0aebd',
      mystic = 'eae7fa',
      journo_Mech = '30eb87',
    },
    mysticRitualPosition = { -66.15, 1.59, -20.28 },
    researchTokens = {
      magnifying = 'ca9cc3',
      notebook = '5db4d4'
    },
    pawns = { 'e94bc0', 'dabf30', 'b5f37c' },
    pawnPositions = { { -24.91, 2.30, -16.98 }, { -28.33, 2.30, -16.59 }, { -26.38, 2.30, -15.98 } },
    tentGuid = '1da514',
    tentZoneGuid = 'b6e97f',
    trashGuid = '66b07c',
    resourceBags = {
      t = 'cf6aea',
      a = 'd28bcd',
      j = '355261',
      c = '57c250',
      s = 'f20389'
    },
    resourceBagZones = {
      t = '9b072b',
      a = 'dba428',
      j = 'f72570',
      c = '71fc56',
      s = 'f0ec52'
    },
    suitcaseResourceBagZones = {
      t = '3c308e',
      s = '75c07f'
    },
    suitcasePosition = { -26.60, 1.53, -32.20 },
    falconPositions = { { -44.93, 1.63, -23.54 }, { -42.37, 1.63, -24.73 }, { -39.69, 1.63, -24.02 }, { -38.49, 1.63, -21.73 }, { -38.26, 1.63, -19.01 } },
    archivePositions = { { -67, 1.50, -20.70 }, { -67, 1.50, -27.90 }, { -67, 1.50, -35.10 } },
    foodPositions = { { -38.18, 1.63, -18.73 }, { -38.18, 1.63, -22 }, { -38.18, 1.63, -25.25 } },
    articlePosition = { -24, 1.57, -24.20 },
    goldenTeethPosition = { -24, 1.57, -24.20 },
    refPositions = { { -53, 1.48, -12.5 }, { -47, 1.48, -12.5 } },
    firstPlayerPosition = { -26.60, 1.53, -12.25 }
  }
}

-- data for idols slots: points and local position
idolSlotData = {
   -- captain
  {
    { points = 1, localPos = Vector(-0.149, 0, -0.672)},
    { points = 2, localPos = Vector(-0.549, 0, -0.672)},
    { points = 3, localPos = Vector(-1.025, 0, -0.672)},
    { points = 4, localPos = Vector(-1.427, 0, -0.672)}
  },
  -- falconer
  {
    { points = 1, localPos = Vector(-0.149, 0, -0.672)},
    { points = 2, localPos = Vector(-0.549, 0, -0.672)},
    { points = 3, localPos = Vector(-1.025, 0, -0.672)},
    { points = 4, localPos = Vector(-1.427, 0, -0.672)}
  },
  -- baroness
  {
    { points = 1, localPos = Vector(-0.149, 0, -0.672)},
    { points = 2, localPos = Vector(-0.549, 0, -0.672)},
    { points = 3, localPos = Vector(-1.025, 0, -0.672)},
    { points = 4, localPos = Vector(-1.427, 0, -0.672)}
  },
  -- professor
  {
    { points = 1, localPos = Vector(-0.149, 0, -0.672)},
    { points = 2, localPos = Vector(-0.549, 0, -0.672)},
    { points = 3, localPos = Vector(-1.025, 0, -0.672)},
    { points = 4, localPos = Vector(-1.427, 0, -0.672)}
  },
  -- explorer
  {
    { points = 1, localPos = Vector(-0.149, 0, -0.672)},
    { points = 2, localPos = Vector(-0.549, 0, -0.672)},
    { points = 3, localPos = Vector(-1.025, 0, -0.672)},
    { points = 4, localPos = Vector(-1.427, 0, -0.672)}
  },
  -- mystic
  {
    { points = 1, localPos = Vector(-0.120, 0, -0.663)},
    { points = 2, localPos = Vector(-0.514, 0, -0.663)},
    { points = 2, localPos = Vector(-0.992, 0, -0.663)},
    { points = 3, localPos = Vector(-1.396, 0, -0.663)},
    { points = 4, localPos = Vector(-1.798, 0, -0.663)}
  },
  -- journalist
  {
    { points = 2, localPos = Vector(1.644, 0, -0.674)},
    { points = 3, localPos = Vector(1.225, 0, -0.674)},
    { points = 4, localPos = Vector(0.800, 0, -0.674)},
    { points = 0, localPos = Vector(-3.485, 0, -0.254)},
    { points = 0, localPos = Vector(-3.494, 0, 0.249)}
  },
  -- mechanic
  {
    { points = 1, localPos = Vector(1.621, 0, -0.677)},
    { points = 2, localPos = Vector(1.231, 0, -0.677)},
    { points = 3, localPos = Vector(0.770, 0, -0.677)},
    { points = 4, localPos = Vector(0.378, 0, -0.677)}
  },
  -- base game board
  {
    { points = 1, localPos = Vector(-1.330, 0, -0.634)},
    { points = 2, localPos = Vector(-1.714, 0, -0.634)},
    { points = 3, localPos = Vector(-2.097, 0, -0.634)},
    { points = 4, localPos = Vector(-2.478, 0, -0.634)}
  }
}
seatedPlayerColors = {}
startPlayerIndex = 0
hexColors = {
  White = '[ffffff]',
  Brown = '[713b17]',
  Red = '[da1a18]',
  Orange = '[f4641d]',
  Yellow = '[e7e52c]',
  Green = '[31b32b]',
  Teal = '[21b19b]',
  Blue = '[1e87ff]',
  Purple = '[a020f0]',
  Pink = '[f570ce]',
  Black = '[404040]',
  Grey = '[808080]'
}

starterDeck = {
  Yellow = { "0001", "0002", "0003", "0004" },
  Green = { "0005", "0006", "0007", "0008" },
  Blue = { "0009", "0010", "0011", "0012" },
  Red = { "0013", "0014", "0015", "0016" },
  Falconer = { "1001", "1002", "1003", "1004" },
  Explorer = { "1005", "1006", "1007", "1008" },
  Professor = { "1009", "1010", "1011", "1012" },
  Mystic = { "1013", "1014", "1015", "1016" },
  Baroness = { "1017", "1018", "1019", "1020" },
  Captain = { "1021", "1022", "1023", "1024" },
  Mechanic = { "2001", "2002", "2003", "2004" },
  Journalist = { "2005", "2006", "2007", "2008" }
}
options = {
  solo = false,
  objectives = 3,
  playerBoards = {},
  board = 1,
  researchTrack = 1,
  staff = 1,
  leaders = 'random',
  campaign = false,
  expansions = {
    expeditionLeaders = true,
    missingExpedition = true,
    promos = true
  }
}
bags = {
  resources = {
    t = '831df9',
    a = '84369b',
    j = 'e283e9',
    c = '1ee5ea',
    s = 'c85087'
  },
  fear = '69002b',
  blocking = '8c3f25',
  researchBonus = 'e90e2a',
  leaderRef = '0a5188',
  miscTokens = '47fde4',
  replaced = 'bb923d',
  solo = 'cabb5b',
  soloTempleTiles = 'c13fff',
  campaignItems = '5c483d'
}
deckZones = {
  artifacts = 'c19201',
  items = 'cd21a5',
  fear = '1fcdb3',
  sites1 = '702902',
  sites2 = 'e0c338',
  guardians = 'b51480',
  bonus1 = "bonus1",
  bonus2 = "bonus2",
  bonus3 = "bonus3",
  bonus4 = "bonus4",
  bonus5 = "bonus5"
}
assistantDeckGuid = '538a5c'
idolDeckGuid = 'ab4a80'

expansionDecks = {
  expeditionLeaders = {
    assistants = 'cf87b7',
    idols = '9988c4',
    sites1 = '37a6dd',
    sites2 = '486402',
    guardians = 'b876d5'

  },
  missingExpedition = {
    assistants = 'b640aa',
    idols = '2e956e',
    sites1 = '408800',
    sites2 = '10d945',
    guardians = '6fbe77'
  }
}

playerDecks = {
  base = {
    Red = 'cbf743',
    Blue = 'aaed1a',
    Green = '47fe07',
    Yellow = '34c052'
  },
  leaders = { '1e21bd', '99385f', 'd0d33f', 'a42e51', '64471d', '2c1dc4', '5c5fc9', '302d5d' }
}
tokens = {
  falcon = '9ef0a8',
  suitcase = 'f78694',
  food = { '4c7454', '7ae3bf', 'a4129d' },
  firstPlayer = 'b1383c',
  journalistArticles = 'a40186',
  journalistNewspapers = 'd73b83',
  MechanicWheel = 'd3657d',
  MechanicMonkey = '168247',
  MechanicGoldTokens = '428f5c',
  MechanicGoldTokenAttacher = '3cc576'
}
cards = {
  baroness = '49e35e'
}
suitcaseResourceBags = {
  t = 'da4493',
  s = '4ecc7c'
}
falconRotations = { { 0, 225, 0 }, { 0, 190, 0 }, { 0, 148, 0 }, { 0, 115, 0 }, { 0, 90, 0 } }
assistantPositions = { { 9.15, 1.63, -30.73 }, { 13.83, 1.63, -30.73 }, { 18.52, 1.63, -30.73 } }
assistantZones = { 'a432ac', 'a44647', '3ffbd7' }

cardRowZoneGuids = { '8ae6f2', '6103ae', 'cea4b5', '99cfc2', '8a1a02', 'dbf266' }
staffPositions = { { -14.61, 1.63, 20.23 }, { -7.37, 1.63, 20.23 }, { -0.03, 1.63, 20.23 }, { 7.23, 1.63, 20.23 }, { 14.51, 1.63, 20.23 } }
exileZoneGuids = {
  artifacts = '19f28c',
  items = 'ec5c7a',
  other = 'bcb533'
}
siteLevels = {
  {
    { guid = '102294', pawnSpaces = { 'd8ae82' } },
    { guid = '836103', pawnSpaces = { '7b9a3a' } },
    { guid = '73d0db', pawnSpaces = { '6dfe86' } },
    { guid = 'a3b7a0', pawnSpaces = { 'c77d64' } }
  },
  {
    { guid = '5dce42', pawnSpaces = { '6ec07b' } },
    { guid = '8a7e4e', pawnSpaces = { 'f40303' } },
    { guid = 'ceb501', pawnSpaces = { '2bc798' } },
    { guid = '91a1f7', pawnSpaces = { '68bc73' } }
  },
  {
    { guid = 'f399b2', pawnSpaces = { '716a13' } },
    { guid = '588793', pawnSpaces = { '39f1c2' } },
    { guid = 'fa45f2', pawnSpaces = { '3c7380' } },
    { guid = '874212', pawnSpaces = { '0c50cf' } }
  },
  {
    { guid = 'e57811', pawnSpaces = { 'df2d4f', '45ab8f' } },
    { guid = '05cffe', pawnSpaces = { '74b16f', '9cf53d' } },
    { guid = '2af21b', pawnSpaces = { '264538', '023ed4' } },
    { guid = '92dc47', pawnSpaces = { '5c1009', '79c8e7' } },
    { guid = '0322bb', pawnSpaces = { '87786d', '35c82d' } }
  }
}

templeTileZoneGuids = { 'fc3aea', '6b0f38', 'aa7dfd', 'e573c3', 'bb0b10', '599983' }
templeSpaceZoneGuids = { '9c9b90', 'efc726', '024b25', '13d709' }
researchZoneGuid = '5de995'
researchTracks = {
  {
    bonusPositions = {
      { { 9.08, 1.68, -18.72 },  { 13.77, 1.68, -18.73 }, { 9.11, 1.68, -9.83 }, { 13.22, 1.68, -9.84 }, { 17.23, 1.68, -9.84 }, { 9.34, 1.68, -1.65 }, { 14.05, 1.68, -1.65 } },
      { { 9.29, 1.68, 2.43 },    { 16.64, 1.68, 2.43 } },
      { { 13.01, 1.68, -14.25 }, { 11.45, 1.68, -5.71 } },
      { { 19.63, 1.68, 6.15 } }
    },
    rows = {
      {
        z = 3.87,
        bonusPos = { 19.63, 1.78, 6.15 }
      },
      {
        z = 0.95,
        magnifying = 16,
        notebook = 10,
        paths = { { pos = { 9.29, 1.78, 2.43 }, forward = { 1 }, bonus = true }, { pos = { 16.64, 1.78, 2.43 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -3.16,
        magnifying = 12,
        notebook = 8,
        paths = { { pos = { 9.34, 1.78, -1.65 }, forward = { 1 }, bonus = true }, { pos = { 14.05, 1.78, -1.65 }, forward = { 1, 2 }, bonus = true } }
      },
      {
        z = -7.36,
        magnifying = 9,
        notebook = 6,
        paths = { { pos = { 11.45, 1.78, -5.71 }, forward = { 1, 2 }, bonus = true } }
      },
      {
        z = -11.44,
        magnifying = 6,
        notebook = 4,
        assistant = true,
        paths = { { pos = { 9.11, 1.78, -9.83 }, forward = { 1 }, bonus = true }, { pos = { 13.22, 1.78, -9.84 }, forward = { 1 }, bonus = true }, { pos = { 17.23, 1.78, -9.84 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -15.93,
        magnifying = 4,
        notebook = 2,
        assistant = true,
        paths = { { pos = { 13.01, 1.78, -14.25 }, forward = { 1, 2, 3 }, bonus = true } }
      },
      {
        z = -20.50,
        magnifying = 2,
        notebook = 1,
        assistant = true,
        paths = { { pos = { 9.08, 1.78, -18.72 }, forward = { 1 }, bonus = true }, { pos = { 13.77, 1.78, -18.73 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -24.93,
        magnifying = 1,
        notebook = 0,
        assistant = true,
        paths = { { pos = { 9.31, 1.73, -23.28 }, forward = { 1, 2 } }, { pos = { 17.53, 1.73, -23.28 }, forward = { 2 } } }
      }
    },
    templePoints = { 23, 21, 20, 19 }
  },
  {
    bonusPositions = {
      { { 9.05, 1.68, -19.26 },  { 16.90, 1.68, -19.26 }, { 9.06, 1.68, -15.03 }, { 16.91, 1.68, -15.03 }, { 9.06, 1.68, -1.92 }, { 15.33, 1.68, -1.92 }, { 9.07, 1.68, 2.38 }, { 16.90, 1.68, 2.38 } },
      { { 13.16, 1.68, -19.26 }, { 13.08, 1.68, 2.38 } },
      { { 9.07, 1.68, -6.02 },   { 16.93, 1.68, -6.02 } },
      { { 19.66, 1.68, 6.15 } }
    },
    rows = {
      {
        z = 4.20,
        bonusPos = { 19.66, 1.78, 6.15 }
      },
      {
        z = 0.66,
        magnifying = 15,
        notebook = 15,
        paths = { { forward = { 1 }, bonusPos = { { 9.07, 1.78, 2.38 }, { 13.08, 1.78, 2.38 }, { 16.90, 1.78, 2.38 } } } }
      },
      {
        z = -3.47,
        magnifying = 10,
        notebook = 12,
        paths = { { pos = { 9.06, 1.78, -1.92 }, forward = { 1 }, bonus = true }, { pos = { 15.33, 1.78, -1.92 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -7.51,
        magnifying = 5,
        notebook = 8,
        assistant = true,
        paths = { { pos = { 9.07, 1.78, -6.02 }, forward = { 1, 2 }, bonus = true }, { pos = { 16.93, 1.78, -6.02 }, forward = { 2 }, bonus = true } }
      },
      {
        z = -12.46,
        magnifying = 4,
        notebook = 5,
        assistant = true,
        paths = { { pos = { 17.37, 1.73, -10.84 }, forward = { 1, 2 } } }
      },
      {
        z = -16.61,
        magnifying = 3,
        notebook = 4,
        assistant = true,
        paths = { { pos = { 9.06, 1.78, -15.03 }, forward = { 1 }, bonus = true }, { pos = { 16.91, 1.78, -15.03 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -20.93,
        magnifying = 2,
        notebook = 3,
        paths = { { pos = { 9.05, 1.78, -19.26 }, forward = { 1 }, bonus = true }, { pos = { 13.16, 1.78, -19.26 }, forward = { 1, 2 }, bonus = true }, { pos = { 16.90, 1.78, -19.26 }, forward = { 2 }, bonus = true } }
      },
      {
        z = -25.04,
        magnifying = 1,
        notebook = 0,
        assistant = true,
        paths = { { pos = { 8.69, 1.73, -23.36 }, forward = { 1, 2 } }, { pos = { 14.50, 1.73, -23.23 }, forward = { 2, 3 } } }
      }
    },
    templePoints = { 23, 21, 20, 19 },
    assistantPos = { 12.86, 1.72, -10.47 },
    assistantZone = '7f2184',
  },
  {
    bonusPositions = {
      {}, {}, {},
      { { 13.50, 1.68, -16.70 }, { 12.80, 1.68, -3.99 }, { 19.73, 1.68, 6.06 } }
    },
    rows = {
      {
        z = 4.20,
        bonusPos = { 19.73, 1.78, 6.06 }
      },
      {
        z = 1.48,
        magnifying = 15,
        notebook = 16,
        paths = { { pos = { 9.42, 1.73, 3 }, forward = { 1 } }, { pos = { 15.75, 1.73, 3 }, forward = { 1 } } }
      },
      {
        z = -1.89,
        magnifying = 9,
        notebook = 9,
        assistant = true,
        paths = { { pos = { 8.53, 1.73, -0.47 }, forward = { 1 } }, { pos = { 13.74, 1.73, -0.47 }, forward = { 1, 2 } } }
      },
      {
        z = -5.4,
        magnifying = 8,
        notebook = 7,
        paths = { { pos = { 12.79, 1.78, -3.99 }, forward = { 1, 2 }, bonus = true } }
      },
      {
        z = -9.87,
        magnifying = 5,
        notebook = 4,
        paths = { { pos = { 16.51, 1.73, -7.80 }, forward = { 1 } } }
      },
      {
        z = -14.5,
        magnifying = 5,
        notebook = 2,
        assistant = true,
        paths = { { pos = { 16.44, 1.73, -12.55 }, forward = { 1 } } }
      },
      {
        z = -18.14,
        magnifying = 4,
        notebook = 1,
        paths = { { pos = { 13.50, 1.78, -16.70 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -21.8,
        magnifying = 3,
        notebook = 0,
        assistant = true,
        paths = { { pos = { 8.23, 1.73, -20.30 }, forward = { 1 } }, { pos = { 13.20, 1.73, -20.30 }, forward = { 1 } }, { pos = { 16.68, 1.73, -20.30 }, forward = { 1 } } }
      },
      {
        z = -24.98,
        magnifying = 1,
        notebook = 0,
        assistant = true,
        paths = { { pos = { 8.48, 1.73, -23.76 }, forward = { 1 } }, { pos = { 11.74, 1.73, -23.80 }, forward = { 1, 2 } }, { pos = { 15.24, 1.73, -23.76 }, forward = { 2, 3 } } }
      }
    },
    templePoints = { 23, 21, 20, 19 },
    artifactPos = { 10.36, 1.69, -10.37 }
  },
  -- Lizard Temple
  {
    bonusPositions = {
      { { 9.15, 1.68, -19.77 }, { 16.97, 1.68, -19.80 }, { 9.15, 1.68, -16.18 }, { 16.94, 1.68, -16.20 }, { 9.37, 1.68, -9.19 }, { 11.89, 1.68, -4.60 }, { 14.44, 1.68, -4.61 }, { 11.37, 1.68, 2.57 }, { 15.01, 1.68, 2.56 } },
      { { 9.33, 1.68, -4.60 },  { 9.02, 1.68, 2.57 } },
      { { 16.98, 1.68, -4.61 }, { 17.35, 1.68, 2.56 } },
      { { 19.84, 1.68, 6.11 } }
    },
    rows = {
      {
        z = 4.20,
        bonusPos = { 19.84, 1.78, 6.11 }
      },
      {
        z = 1.12,
        magnifying = 20,
        notebook = 13,
        paths = { { forward = { 1 }, bonusPos = { { 9.02, 1.78, 2.57 }, { 11.37, 1.78, 2.57 }, { 15.01, 1.78, 2.56 }, { 17.35, 1.78, 2.56 } } } }
      },
      {
        z = -2.13,
        magnifying = 12,
        notebook = 10,
        paths = { { pos = { 8.75, 1.73, -0.96 }, forward = { 1 } }, { pos = { 15.73, 1.73, -0.96 }, forward = { 1 } } }
      },
      {
        z = -6.21,
        magnifying = 8,
        notebook = 7,
        assistant = true,
        paths = { { forward = { 1, 2 }, bonusPos = { { 9.33, 1.78, -4.60 }, { 11.89, 1.78, -4.60 }, { 14.44, 1.78, -4.61 }, { 17, 1.78, -4.61 } } } }
      },
      {
        z = -13.94,
        magnifying = 4,
        notebook = 3,
        assistant = true,
        paths = { { pos = { 9.37, 1.78, -9.19 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -17.54,
        magnifying = 3,
        notebook = 3,
        paths = { { pos = { 9.15, 1.78, -16.18 }, forward = { 1 }, bonus = true }, { pos = { 13.19, 1.73, -16.18 }, forward = { 1 } }, { pos = { 16.93, 1.78, -16.18 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -21.18,
        magnifying = 2,
        notebook = 1,
        assistant = true,
        paths = { { pos = { 9.15, 1.78, -19.77 }, forward = { 1, 2 }, bonus = true }, { pos = { 16.97, 1.78, -19.80 }, forward = { 2, 3 }, bonus = true } }
      },
      {
        z = -24.96,
        magnifying = 1,
        notebook = 0,
        assistant = true,
        paths = { { pos = { 7.97, 1.73, -23.29 }, forward = { 1 } }, { pos = { 11.94, 1.73, -23.29 }, forward = { 1, 2 } }, { pos = { 16.19, 1.73, -23.29 }, forward = { 2 } } }
      }
    },
    templePoints = { 28, 26, 25, 24 },
    guardianPos = { 14.90, 1.69, -10.51 },
    guardianZone = '7f2184',
    idolPositions = { { 18.54, 1.72, -0.97 } }
  },
  -- Tree Temple
  {
    bonusPositions = {
      -- always place these
      { { 10.66, 1.78, 2.70 }, { 16.82, 1.78, 2.70 },  { 11.91, 1.78, -9.80 }, { 14.39, 1.78, -9.77 }, { 9.42, 1.78, -19.80 }, { 16.82, 1.78, -19.80 } },
      -- only place these for 3+ player
      { { 9.40, 1.78, -9.80 }, { 12.18, 1.78, -19.80 } },
      -- only place these for 4+ players
      { { 16.97, 1.78, -9.80 } },
      -- place one tile per player
      { { 19.75, 1.78, 5.90 } }
    },
    -- z-position in the following table is for research token detection (scoring)
    -- magnifying / notebook indicates the points for reaching that row
    -- assistant indicates whether the rival will remove an assistant
    rows = {
      {
        z = 4.4,
        bonusPos = { 19.75, 1.73, 5.90 }
      },
      {
        z = 0.65,
        magnifying = 19,
        notebook = 13,
        paths = { { pos = { 10.66, 1.73, 2.70 }, forward = { 1 }, bonus = true }, { pos = { 16.82, 1.73, 2.70 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -3.1,
        magnifying = 15,
        notebook = 10,
        assistant = true,
        paths = { { pos = { 10.37, 1.73, -1.44 }, forward = { 1, 2 } }, { pos = { 16.80, 1.73, -1.42 }, forward = { 1, 2 } } }
      },
      {
        z = -7.7,
        magnifying = 12,
        notebook = 6,
        paths = { { pos = { 8.92, 1.73, -5.16 }, forward = { 1, 2 }, bonus = true }, { pos = { 11.42, 1.73, -5.05 }, forward = { 1, 2 }, bonus = true }, { pos = { 14.79, 1.73, -4.94 }, forward = { 1, 2 }, bonus = true }, { pos = { 17.45, 1.73, -5.16 }, forward = { 1, 2 }, bonus = true } }
      },
      {
        z = -11.6,
        magnifying = 9,
        notebook = 5,
        assistant = true,
        paths = { { pos = { 11.91, 1.73, -9.80 }, forward = { 1, 2, 3, 4 }, bonus = true }, { pos = { 14.39, 1.73, -9.77 }, forward = { 1, 2, 3, 4 }, bonus = true } }
      },
      {
        z = -17.9,
        magnifying = 6,
        notebook = 3,
        paths = { { pos = { 9.79, 1.73, -13.91 }, forward = { 1, 2 }, bonus = true }, { pos = { 11.88, 1.73, -14.68 }, forward = { 1, 2 }, bonus = true }, { pos = { 14.37, 1.73, -14.64 }, forward = { 1, 2 }, bonus = true }, { pos = { 16.78, 1.73, -13.96 }, forward = { 1, 2 }, bonus = true } }
      },
      {
        z = -21.4,
        magnifying = 3,
        notebook = 1,
        assistant = true,
        paths = { { pos = { 9.42, 1.73, -19.80 }, forward = { 1, 2, 3, 4 }, bonus = true }, { pos = { 16.82, 1.73, -19.80 }, forward = { 1, 2, 3, 4 }, bonus = true } }
      },
      {
        z = -26,
        magnifying = 1,
        notebook = 0,
        assistant = true,
        paths = { { pos = { 9.22, 1.73, -23.25 }, forward = { 1 } }, { pos = { 15.69, 1.73, -23.44 }, forward = { 1, 2 } } }
      }
    },
    templePoints = { 27, 25, 24, 23 },
    idolPositions = { { 19.86, 1.69, -15.77 }, { 19.89, 1.69, -6.18 } }
  },
  -- Waterfall Temple
  {
    bonusPositions = {
      -- always place these
      { { 11.38, 1.78, 2.44 },  { 16.67, 1.78, 2.43 },  { 11.85, 1.78, -4.45 }, { 14.20, 1.78, -4.47 }, { 12.03, 1.78, -16.93 }, { 14.33, 1.68, -16.98 } },
      -- only place these for 3+ player
      { { 9.60, 1.78, -4.47 },  { 9.75, 1.78, -16.95 } },
      -- only place these for 4+ players
      { { 16.45, 1.78, -4.47 }, { 16.55, 1.78, -16.95 } },
      -- place one tile per player
      { { 19.66, 1.78, 5.58 } }
    },
    -- z-position in the following table is for research token detection (scoring)
    -- magnifying / notebook indicates the points for reaching that row
    -- assistant indicates whether the rival will remove an assistant
    rows = {
      {
        z = 4.1,
        bonusPos = { 19.66, 1.78, 5.58 }
      },
      {
        z = 1.1,
        magnifying = 13,
        notebook = 18
      },
      {
        z = -2.25,
        magnifying = 10,
        notebook = 14,
        assistant = true,
        paths = { { pos = { 11.38, 1.68, 2.44 }, forward = { 1 } }, { pos = { 16.67, 1.68, 2.43 }, forward = { 1 } } }
      },
      {
        z = -6.3,
        magnifying = 8,
        notebook = 11,
        paths = { { pos = { 13.73, 1.73, -0.55 }, forward = { 1, 2 }, bonus = true } }

      },
      {
        z = -10.6,
        magnifying = 5,
        notebook = 9,
        paths = { { pos = { 9.60, 1.68, -4.47 }, forward = { 1 } } }
      },
      {
        z = -14.8,
        magnifying = 5,
        notebook = 7,
        assistant = true,
        paths = { { pos = { 10.34, 1.81, -10.75 }, forward = { 1 } } }
      },
      {
        z = -18.6,
        magnifying = 3,
        notebook = 5,
        assistant = true,
        paths = { { pos = { 9.75, 1.68, -16.95 }, forward = { 1 }, bonus = true } }
      },
      {
        z = -22.1,
        magnifying = 3,
        notebook = 3,
        paths = { { pos = { 12.73, 1.73, -20.41 }, forward = { 1 } } }
      },
      {
        z = -25.3,
        magnifying = 1,
        notebook = 0,
        assistant = true,
        paths = { { pos = { 9.23, 1.73, -23.53 }, forward = { 1 } }, { pos = { 14.75, 1.73, -23.63 }, forward = { 1, 2 } } }
      }
    },
    templePoints = { 20, 18, 17, 16 },
    site1pos = { 10.34, 1.69, -10.75 },
    waterfallPositions = { { { 11.21, 1.69, -2.19 }, { 14.93, 1.69, -2.26 } }, { { 11.04, 1.69, -18.88 }, { 14.81, 1.69, -18.88 } } }
  }
}

solo = {
  rules = '29196c',
  board = 'a30382',
  boardPosition = { -43.26, 1.53, 18.96 },
  objectives = 'd8547e',
  objectivePosition = { -51, 1.53, -0.80 },
  zones = { deck = '7196a9', discard = '0ecbe9', idol = { c = '184e31', p = 'de4ec0', s = '7fa25b', fa = '6892c0', ftt = '1caf8d', g = '6892c0', d = '53c99c', t = '500131', r = 'af87d7', e = '69ed89', u = 'fdf87e', dupe = '91df7a' }, delete = '0a61ed', objectivesDeck = '250afb', objectives = { 'd18d8f', 'c9584b', '36d489', '08da31' } },
  pawns = { '47658b', 'bfb9eb', 'b2d015', 'fb9f5d', '9f84c9', 'e5b510' },
  pawnPositions = { { -28.50, 2.20, 20 }, { -26.50, 2.20, 20 }, { -24.50, 2.20, 20 }, { -28.50, 2.20, 18 }, { -26.50, 2.20, 18 }, { -24.50, 2.20, 18 } },
  actionDecks = { arch = 'f682fb', other = '52b0e5' },
  actionCards = {
    artifact = { '35cf03', '8643d5', '6862ec' },
    item = { '0b253e', 'ff70b0', '344897' },
    site = { '3e3e03', '0fe862', '79c5eb' },
    guardian = { 'ee3c46', '4a8a22', '5e9528' },
    research = { 'd5cc24', 'ea0b21', 'f06250' }
  },
  actionCardTypes = { 'artifact', 'item', 'site', 'guardian', 'research' },
  deckPositions = { { -52.57, 1.65, 17.70 }, { -48.58, 1.60, 17.70 } },
  setupPositions = { { -52.57, 1.53, 42.48 }, { -48.58, 1.53, 42.48 } },
  acquiredStuffPositions = {
    idolA = { -34.85, 1.50, 10.15 },
    researchBonus = { -32.16, 2.28, 10.15 },
    templeTile = { { -45.60, 1.93, 11 }, { -42, 1.93, 11 }, { -38.40, 1.93, 11 }, { -45.60, 1.93, 9.30 }, { -42, 1.93, 9.30 }, { -38.40, 1.93, 9.30 } },
    templeTileSilver = { -49.90, 1.93, 10.15 },
    templeTileGold = { -54.10, 1.93, 10.15 },
    guardian = { -42.25, 2.1, 17.71 },
    buy = { -35.12, 2.1, 18.95 },
    assistant = { -26.50, 2, 10.15 }
  }
}
soloStatus = {
  firstTurn = true,
  fulfilledObjectives = {},
  pawnsOut = 0,
  magnifying = { row = 0, path = 0 },
  notebook = { row = 0, path = 0 }
}

tableY = 1.50
tileY = 1.60
pawnY = 2.30
faceup = { 0, 180, 0 }
facedown = { 0, 180, 180 }
buttonLabels = {
  ready1 = 'Calculate Scores',
  ready2 = 'Recalculate Scores',
  confirm = hexColors.Green .. 'Confirm[-]',
  busy = hexColors.Red .. 'Scoring[-]'
}
buttonLabelsRival = { ready = 'Rival Turn', busy = hexColors.Red .. 'Busy[-]' }

round = 0
doneLoading = false
setupInProgress = false
movingRow = false
discovering = false
turn = nil -- tts bug: the player turn is not set correctly when loading/rewinding

function onSave()
  return JSON.encode({
    seatedPlayerColors = seatedPlayerColors,
    startPlayerIndex = startPlayerIndex,
    options = options,
    round = round,
    siteLevels = siteLevels,
    soloStatus = soloStatus,
    turn = turn
  })
end

function onLoad(saveState)
  local loadedData = JSON.decode(saveState)
  if loadedData ~= nil and loadedData.seatedPlayerColors ~= nil then
    seatedPlayerColors = loadedData.seatedPlayerColors
    startPlayerIndex = loadedData.startPlayerIndex
    options = loadedData.options
    round = loadedData.round
    siteLevels = loadedData.siteLevels
    soloStatus = loadedData.soloStatus
    turn = loadedData.turn
  end

  if round == 0 then
    menuOptions()
  elseif round > 0 then
    drawLines()
    setupButtons()
    for _, object in ipairs(getObjects()) do
      addExileMenu(object)
      addGetRewardsMenu(object)
      addReturnMenu(object)
      addTrashMenu(object)
    end
    addAssistantCycleMenu()
  end
  if turn ~= nil and Turns.enable and Turns.turn_color ~= turn then Turns.turn_color = turn end
  math.randomseed(os.time())
  Wait.time(function() doneLoading = true end, 0.5)
end

---------------------- START MENU UI

function uiOff()
  UI.setAttribute('optionsMenuTop', 'active', 'false')
  UI.setAttribute('optionsMenuLeft', 'active', 'false')
  UI.setAttribute('optionsMenuRight', 'active', 'false')
  UI.setAttribute('optionsMenuButtons', 'active', 'false')
  UI.setAttribute('continueMenu', 'active', 'false')
  UI.setAttribute('continueMenuButtons', 'active', 'false')
  UI.setAttribute('soloMenu', 'active', 'false')
end

function menuClose()
  uiOff()
  round = -1
end

function menuOptions()
  uiOff()
  UI.setAttribute('optionsMenuTop', 'active', 'true')
  UI.setAttribute('optionsMenuLeft', 'active', 'true')
  UI.setAttribute('optionsMenuRight', 'active', 'true')
  UI.setAttribute('optionsMenuButtons', 'active', 'true')
end

function uiToggle(_, value, id)
  UI.setAttribute(id, 'isOn', value)
end

function uiSlider(_, value, id)
  UI.setAttribute(id, 'value', value)
  Wait.time(function()
    if id == 'objectiveSlider' then
      local objectives = UI.getAttribute('objectiveSlider', 'value')
      UI.setValue('objectiveText', 'Objectives: ' .. objectives)
    else
      local red = UI.getAttribute('redSlider', 'value')
      local purple = UI.getAttribute('purpleSlider', 'value')
      UI.setValue('redText', 'Red Actions: ' .. red)
      UI.setValue('purpleText', 'Purple Actions: ' .. purple)
      local difficulty = 'N/A'
      if red + purple <= 5 then difficulty = red + 2 * purple end
      UI.setValue('rivalDifficulty', 'Difficulty: ' .. difficulty)
    end
  end, 0.01)
end

function checkToggle(id, var)
  local value = false
  if UI.getAttribute(id, 'isOn') == 'True' then value = true end
  if var ~= nil then var[id] = value end
  return value
end

---------------------- SETUP

function setupGame()
  setupInProgress = true
  AllCardsBag = getObjectFromGUID("4bfea4")
  fearDeckZone = getObjectFromGUID(deckZones.fear)
  decks = {}
  boards = {}
  if options.campaign == true then
    detectSeatedPlayers()
    wait(0.1)
    if #seatedPlayerColors > 3 then
      broadcastToAll("Campaign mode cannot be played with more than 2 players, please reload the mod and try again.")
      return 1
    end
    setupArtifactsItemsFear()
    wait(0.1)
    setupPlayerAreas()
    wait(0.1)
    waitForBoardLoading()
    wait(0.1)
    setupStartingResources()
    wait(0.1)
    setupCampaignMisc()
  else
    getOptionsFromUI()
    wait(0.1)
    detectSeatedPlayers()
    wait(0.1)
    optionOverride()
    wait(0.1)
    setupDecks()
    wait(0.1)
    setupBoard()
    wait(0.1)
    setupMoonstaff()
    wait(0.1)
    setupArtifactsItemsFear()
    wait(0.1)
    setupResearchTrack()
    wait(0.1)
    setupPlayerAreas()
    wait(0.1)
    waitForBoardLoading()
    wait(0.1)
    setupStartingResources()
    wait(0.1)
    setupMiscThings()
  end
  return 1 -- TTS throws an error if a coroutine doesn't return 1
end

function checkDoneSpawning()
  for _, board in pairs(boards) do
    if board.spawning or board.loading_custom then return false end
  end
  return true
end

function getOptionsFromUI()
  local expansions = { 'expeditionLeaders', 'missingExpedition', 'promos' }
  for _, expansion in ipairs(expansions) do
    checkToggle(expansion, options.expansions)
  end

  if checkToggle('leaders1') then
    options.leaders = 'random'
  elseif checkToggle('leaders2') then
    options.leaders = 'choose'
  end

  if checkToggle('board1') then
    options.board = 1
  elseif checkToggle('board2') then
    options.board = 2
  elseif checkToggle('board3') then
    options.board = math.random(1, 2)
  end

  if checkToggle('research1') then
    options.researchTrack = 1
  elseif checkToggle('research2') then
    options.researchTrack = 2
  elseif checkToggle('research3') then
    options.researchTrack = 3
  elseif checkToggle('research4') then
    options.researchTrack = 4
  elseif checkToggle('research5') then
    options.researchTrack = 5
  elseif checkToggle('research6') then
    options.researchTrack = 6
  elseif checkToggle('research7') then
    options.researchTrack = math.random(1, 6)
  end

  if checkToggle('staff1') then
    options.staff = 1
  elseif checkToggle('staff2') then
    options.staff = 2
  end
end

function optionOverride()
  if options.researchTrack == 4 and options.expansions.expeditionLeaders == false and options.expansions.missingExpedition == false then
    broadcastToAll('The Lizard Temple has been selected. Expedition Leaders expansion will be used.')
    options.expansions.expeditionLeaders = true
  end

  if options.expansions.missingExpedition == true and options.expansions.expeditionLeaders == false and #seatedPlayers > 2 then
    broadcastToAll('Not enough real leaders available, enabling Expedition Leaders.')
    options.expansions.expeditionLeaders = true
  end
end

function detectSeatedPlayers()
  local allColors = { 'Red', 'Blue', 'Green', 'Yellow' }
  seatedPlayerColors = {}
  local absentColors = {}

  seatedPlayers = getSeatedPlayers()
  if testVars.defineSeated then
    seatedPlayers = testVars.seatedPlayers
  end

  options.playerBoards = {}
  local leaders = { false, false, false, false, false, false, false, false }
  for _, color in ipairs(allColors) do
    local seated = false
    for _, seatedPlayerColor in ipairs(seatedPlayers) do
      if seatedPlayerColor == color then
        seated = true
        table.insert(seatedPlayerColors, color)
        local playerBoard = getPlayerBoard(color)
        local stateId = playerBoard.getStateId()
        options.playerBoards[color] = stateId
        if stateId ~= 9 then
          if not leaders[stateId] then
            leaders[stateId] = true
          else
            broadcastToAll('Duplicate expedition leaders were chosen.')
            return
          end
        end
      end
    end
    if not seated then table.insert(absentColors, color) end
  end

  if #seatedPlayerColors == 0 then
    broadcastToAll('All players must select colors before setup.')
    return
  elseif #seatedPlayerColors == 1 or options.campaign == true then
    for _, seatedPlayer in ipairs(seatedPlayerColors) do
      if seatedPlayer == 'Red' then
        broadcastToAll('Rival plays as red. Choose a different color.')
        return
      end
    end
    options.solo = true
    table.insert(seatedPlayerColors, 'Red')
    table.remove(absentColors, 1)
  end

  -- delete not seated
  for _, playerColor in ipairs(absentColors) do
    local vars = playerVars[playerColor]
    for _, object in ipairs(getObjectFromGUID(vars.allZoneGuid).getObjects()) do
      object.destruct()
    end
    for _, guid in pairs(vars.researchTokens) do
      local token = getObjectFromGUID(guid)
      if token ~= nil then token.destruct() end
    end
  end
end

function setupBoard()
  -- Check the current board and if its not what was chosen via options, change it
  for _, object in ipairs(fearDeckZone.getObjects()) do
    if object.getName() == 'Board' then
      if object.getStateId() ~= options.board then object.setState(options.board) end
      break
    end
  end

  -- distribute idols to the tier 1 and tier 2 sites. Tier 2 sites get 2 (one face up one face down)
  for i = 1, 3 do
    for _, siteZone in ipairs(siteLevels[i]) do
      local pos = getObjectFromGUID(siteZone.guid).getPosition()
      if i == 1 then
        decks.idols.takeObject({ position = pos + Vector(-0.97, 0, 0), rotation = faceup, smooth = true })
        decks.idols.takeObject({ position = pos + Vector(0.97, 0, 0), rotation = facedown, smooth = true })
      else
        decks.idols.takeObject({ position = pos, rotation = faceup, smooth = true })
      end
    end
  end
end

function setupMoonstaff()
  -- Check the moon staff and if its not what was chosen via options, change it
  local staff = getStaff()
  if staff and staff.getStateId() ~= options.staff then
    staff.setState(options.staff)
  end
end

function setupResearchTrack()
  -- Check the research board and if its not what was chosen via options, change it
  for _, object in ipairs(getObjectFromGUID(researchTracks[4].guardianZone).getObjects()) do
    if object.getName() == 'Research Track' then
      if object.getStateId() ~= options.researchTrack then
        boards.researchBoard = object.setState(options.researchTrack)
      end
      break
    end
  end

  -- place bonusses
  local bag = getObjectFromGUID(bags.researchBonus)
  bag.shuffle()

  local trackInfo = researchTracks[options.researchTrack]
  for i, list in ipairs(trackInfo.bonusPositions) do
    if i == 4 then
      for _, pos in ipairs(list) do
        for j = 1, #seatedPlayerColors do
          bag.takeObject({ position = Vector(pos) + Vector(0, j * 0.1, 0), rotation = facedown, smooth = true })
        end
      end
    elseif i == 1 or #seatedPlayerColors > i then
      for _, pos in ipairs(list) do
        bag.takeObject({ position = pos, rotation = faceup, smooth = true })
      end
    end
  end

  -- maybe place assistants equal to the number of players
  if trackInfo.assistantPos then
    local newDecks = decks.assistants.cut(#seatedPlayerColors)
    wait(0.01)
    decks.assistants = newDecks[1]
    newDecks[2].setRotationSmooth({ 0, 90, 0 }, false, true)
    newDecks[2].setPositionSmooth(trackInfo.assistantPos, false, true)
  end

  -- maybe get a random artifact with 3 cost (for Monkey Temple)
  if trackInfo.artifactPos then
    for _, cardData in ipairs(decks.artifacts.getData().ContainedObjects) do
      local md = JSON.decode(cardData.GMNotes) or {}
      if md.cost == 3 then
        local card = decks.artifacts.takeObject({
          guid = cardData.GUID,
          position = trackInfo.artifactPos,
          rotation = faceup
        })
        card.lock()
        break
      end
    end
  end

  -- maybe get a random guardian
  if trackInfo.guardianPos then
    decks.guardians.takeObject({ position = trackInfo.guardianPos, rotation = facedown, smooth = true })
  end

  -- maybe place a site 1 location per player
  if trackInfo.site1pos then
    local newDecks = decks.sites1.cut(#seatedPlayerColors)
    wait(0.01)
    decks.sites1 = newDecks[1]
    newDecks[2].setRotationSmooth(facedown, false, true)
    newDecks[2].setPositionSmooth(trackInfo.site1pos, false, true)
  end

  -- maybe place idols equal to the number of players
  if trackInfo.idolPositions then
    for _, idolPos in ipairs(trackInfo.idolPositions) do
      for i = 1, #seatedPlayerColors do
        decks.idols.takeObject({ position = idolPos, rotation = facedown, smooth = true })
      end
    end
  end

  -- won't need idols after this
  decks.idols.destruct()

  -- maybe place waterfall tiles
  if trackInfo.waterfallPositions then
    local tokenBag = getObjectFromGUID(bags.miscTokens)
    for _, posList in ipairs(trackInfo.waterfallPositions) do
      for _, objData in ipairs(tokenBag.getData().ContainedObjects) do
        if objData.Nickname == "Waterfall" then
          tokenBag.takeObject({ guid = objData.GUID, position = posList[math.random(#posList)] })
          break
        end
      end
    end
  end
end

function setupArtifactsItemsFear()
  -- get positions from zones
  local deckPos = {
    Artifact = getObjectFromGUID(deckZones.artifacts).getPosition(),
    Item = getObjectFromGUID(deckZones.items).getPosition(),
    Fear = getObjectFromGUID(deckZones.fear).getPosition()
  }

  for _, cardType in ipairs({ "Artifact", "Item" }) do
    local cardList = {}
    -- always add base game cards
    local result = AllCardsBag.call("getCardsByExpansionAndType", { expansion = "Base Game", type = cardType })
    addCardsToList(cardList, result)

    -- maybe add cards from "Expedition Leaders"
    if options.expansions.expeditionLeaders then
      result = AllCardsBag.call("getCardsByExpansionAndType", { expansion = "Expedition Leaders", type = cardType })
      addCardsToList(cardList, result)
    end

    -- maybe add cards from "Missing Expedition"
    if options.expansions.missingExpedition then
      result = AllCardsBag.call("getCardsByExpansionAndType", { expansion = "Missing Expedition", type = cardType })
      addCardsToList(cardList, result)
    end

    -- maybe add cards from "Promo 1"
    if options.expansions.promos then
      result = AllCardsBag.call("getCardsByExpansionAndType", { expansion = "Promo 1", type = cardType })
      addCardsToList(cardList, result)
    end

    local deck = AllCardsBag.call("spawnCardList", {
      cardList = cardList,
      position = deckPos[cardType],
      rotation = facedown
    })
    deck.setName(cardType .. " Deck")
    deck.shuffle()

    -- add deck to global index
    if cardType == "Artifact" then
      decks.artifacts = deck
    elseif cardType == "Item" then
      decks.items = deck
    end
    wait(1)
  end

  -- generate fear deck
  local cardList = {}
  for i = 1, (19 - #seatedPlayers * 2) do
    table.insert(cardList, "0000")
  end
  local deck = AllCardsBag.call("spawnCardList", {
    cardList = cardList,
    position = deckPos["Fear"],
    rotation = faceup
  })
  deck.setName("Fear Deck")
  decks.fear = deck
end

function addCardsToList(list, cards)
  for _, v in ipairs(cards) do
    table.insert(list, v)
  end
end

function setupPlayerAreas()
  -- determine available states
  local availableLeaders = {}

  -- first 6 states come from the first expansion
  if options.expansions.expeditionLeaders then
    for i = 1, 6 do
      table.insert(availableLeaders, i)
    end
  end

  -- next two states come from the second expansion
  if options.expansions.missingExpedition then
    for i = 7, 8 do
      table.insert(availableLeaders, i)
    end
  end

  -- track manual leader selection
  if options.leaders == 'choose' then
    for _, playerColor in ipairs(seatedPlayerColors) do
      local stateId = getPlayerBoard(playerColor).getStateId()
      if stateId ~= 9 then
        -- remove leader from pool
        for i, id in ipairs(availableLeaders) do
          if id == stateId then
            table.remove(availableLeaders, i)
            break
          end
        end
      end
    end
  end

  for _, playerColor in ipairs(seatedPlayerColors) do
    if options.solo and playerColor == 'Red' then
      -- Setup the solo player board
      local soloBag = getObjectFromGUID(bags.solo)
      for _, object in ipairs(getObjectFromGUID(playerVars[playerColor].allZoneGuid).getObjects()) do
        if object.getName() ~= 'Red Archaeologist' then object.destruct() end
      end
      getPlayerBoard(playerColor).destruct()
      soloBag.takeObject({
        guid = solo.board,
        position = solo.boardPosition,
        rotation = faceup,
        callback_function = function(x)
          x.setLock(true)
        end
      })
    else
      -- If not the solo player board
      local playerBoard = getPlayerBoard(playerColor)
      if playerBoard == nil then
        broadcastToAll('Cannot find ' .. playerColor .. "'s player board. Please reload the mod.")
        return 1
      end

      -- if random leader selection is enabled OR they choose to randomize during leader picking
      if options.leaders == 'random' or (options.leaders == 'choose' and playerBoard.getStateId() == 9) then
        local leaderId = 9
        if #availableLeaders ~= 0 then
          local rand = math.random(1, #availableLeaders)
          leaderId = availableLeaders[rand]

          -- remove leader from pool
          for i, id in ipairs(availableLeaders) do
            if id == leaderId then
              table.remove(availableLeaders, i)
              break
            end
          end
        end

        options.playerBoards[playerColor] = leaderId
        if playerBoard.getStateId() ~= leaderId then playerBoard.setState(leaderId) end
      else
        options.playerBoards[playerColor] = playerBoard.getStateId()
      end
    end
  end

  -- TODO: remove expansion player aids?
end

function waitForBoardLoading()
  for _, object in ipairs(fearDeckZone.getObjects()) do
    if object.getName() == 'Board' then
      boards.board = object
      break
    end
  end

  for _, playerColor in ipairs(seatedPlayerColors) do
    boards[playerColor] = getPlayerBoard(playerColor)
  end

  repeat coroutine.yield(0) until checkDoneSpawning()
  for _, board in pairs(boards) do
    board.lock()
    if options.campaign == false then
      board.interactable = false
    end
  end
  drawLines()
end

function setupDecks()
  -- combine/delete expansion decks
  for _, object in ipairs(fearDeckZone.getObjects()) do
    if object.type == 'Deck' then
      decks.fear = object
      object.unlock()
      break
    end
  end

  -- Go through the expansion dictionary which holds multiple dictionaries containing the guids for various expansion decks/items
  for expansion, subTable in pairs(expansionDecks) do
    for option, guid in pairs(subTable) do
      local expansionDeck = getObjectFromGUID(guid)
      local deck = nil
      if option == 'idols' then
        deck = getObjectFromGUID(idolDeckGuid)
      elseif option == 'assistants' then
        deck = getObjectFromGUID(assistantDeckGuid)
      else
        for _, object in ipairs(getObjectFromGUID(deckZones[option]).getObjects()) do
          if object.type == 'Deck' then
            deck = object
            break
          end
        end
      end

      if deck == nil then
        broadcastToAll('Cannot find ' .. option .. ' deck. Please reload the mod.')
        return 1
      elseif expansionDeck == nil then
        broadcastToAll('Cannot find ' .. option .. ' expansion deck. Please reload the mod.')
        return 1
      end
      deck.unlock()
      decks[option] = deck

      -- If this expansion is checked, we add the content from it to the respective deck (idols, guardians, artifacts, items, assistants, sites)
      if options.expansions[expansion] then
        deck.putObject(expansionDeck)
      else
        expansionDeck.destruct()
      end
    end
  end

  -- shuffle decks
  for _, deck in pairs(decks) do
    if deck ~= nil then
      deck.shuffle()
    end
  end
end

function setupMiscThings()
  -- remove or shuffle bonus encounter cards
  for i = 1, 5 do
    local zone = getObjectFromGUID(deckZones["bonus" .. i])
    for _, obj in ipairs(zone.getObjects()) do
      if obj.type == "Deck" then
        if options.expansions.missingExpedition then
          obj.shuffle()
        else
          obj.destruct()
        end
      end
      break
    end
  end

  -- remove temple tiles
  for _, guid in ipairs(templeTileZoneGuids) do
    local count = 0
    for _, object in ipairs(getObjectFromGUID(guid).getObjects()) do -- zones have tag 'temple'
      count = count + 1
      if count > #seatedPlayerColors then
        object.destruct()
      else
        object.unlock()
      end
    end
  end

  -- distribute blocking
  bag = getObjectFromGUID(bags.blocking)
  if #seatedPlayerColors == 2 then
    for _, siteInfo in ipairs(siteLevels[4]) do
      siteInfo.blocked = true
      local toPos = getObjectFromGUID(siteInfo.pawnSpaces[2]).getPosition()
      local block = bag.takeObject({
        position = Vector(toPos[1], 1.63, toPos[3]),
        rotation = faceup
      })
      block.lock()
    end
  elseif #seatedPlayerColors == 3 then
    local selection = { 1, 2, 3, 4, 5 }
    for i = 1, 3 do
      local randomIndex = math.random(1, #selection)
      local siteInfo = siteLevels[4][selection[randomIndex]]
      siteInfo.blocked = true
      local toPos = getObjectFromGUID(siteInfo.pawnSpaces[2]).getPosition()
      local block = bag.takeObject({
        position = Vector(toPos[1], 1.63, toPos[3]),
        rotation = faceup
      })
      block.lock()
      if i < 3 then
        table.remove(selection, randomIndex)
      end
    end
  end

  -- place assistants
  local totalAssistantCount = 12
  if options.expansions.expeditionLeaders then
    totalAssistantCount = totalAssistantCount + 3
  end

  if options.expansions.missingExpedition then
    totalAssistantCount = totalAssistantCount + 4
  end

  -- snake temple has one assistant per player in a special spot
  if options.researchTrack == 2 then
    totalAssistantCount = totalAssistantCount - #seatedPlayers
  end

  -- divide by number of stacks (3) and round down
  local stackCount = math.floor(totalAssistantCount / 3 + 0.5)
  local newDecks = decks.assistants.cut(stackCount)
  wait(0.01)
  newDecks[2].setRotationSmooth(faceup, false, true)
  newDecks[2].setPositionSmooth(assistantPositions[1], false, true)

  local moreNewDecks = newDecks[1].cut(stackCount)
  wait(0.01)
  moreNewDecks[2].setRotationSmooth(faceup, false, true)
  moreNewDecks[2].setPositionSmooth(assistantPositions[2], false, true)
  moreNewDecks[1].setRotationSmooth(faceup, false, true)
  moreNewDecks[1].setPositionSmooth(assistantPositions[3], false, true)

  -- fill market
  wait(0.4)
  round = 1
  refillRowCoroutine()
  wait(0.2)
  setupButtons()
  wait(0.2)

  -- delete bags
  for _, object in ipairs(getObjectFromGUID(solo.zones.delete).getObjects()) do
    if not (options.solo and (object.getName() == 'Solo Components' or object.getName() == 'Solo Temple Tiles')) then
      object.destruct()
    end
  end
  getObjectFromGUID(bags.campaignItems).destruct()
  addAssistantCycleMenu()

  -- start player
  local firstPlayerColor = 'Red'
  if not (options.solo and #seatedPlayerColors == 2) then
    startPlayerIndex = math.random(1, #seatedPlayerColors)
    firstPlayerColor = seatedPlayerColors[startPlayerIndex]
  end

  local firstPlayerMarker = getObjectFromGUID(tokens.firstPlayer)
  if firstPlayerMarker ~= nil then
    firstPlayerMarker.lock()
    firstPlayerMarker.setRotation(faceup)
    firstPlayerMarker.setPositionSmooth(playerVars[firstPlayerColor].firstPlayerPosition, false, false)
  end

  if options.solo then
    UI.setAttribute('soloMenu', 'active', 'true')
  else
    for _, playerColor in ipairs(seatedPlayerColors) do
      if options.playerBoards[playerColor] == 3 then
        decks[playerColor].takeObject({ guid = cards.baroness }).deal(1, playerColor)
        decks[playerColor].deal(4, playerColor)
      else
        decks[playerColor].deal(5, playerColor)
      end
      if options.playerBoards[playerColor] == 6 then decks.fear.deal(1, playerColor) end
      getObjectFromGUID(playerVars[playerColor].tentGuid).unlock()
    end
    broadcastToAll('Starting Round 1')
    Turns.turn_color = firstPlayerColor
    Turns.enable = true
    setupInProgress = false
  end
end

--Create buttons that are used for both standard play and campaign play
function setupButtonsMisc()
  -- take fear button
  local buttonZone = getObjectFromGUID(deckZones.fear)
  params = {
    function_owner = self,
    label = 'Take',
    click_function = 'takeFearButton',
    position = { 0, 0, -2.9 },
    width = 800,
    height = 380,
    font_size = 200
  }
  buttonZone.createButton(params)

  -- take resources buttons
  params.label = 'Take'
  params.scale = { 2 / 1.5, 2, 2 / 1.5 }
  params.position = { 0, 0, 1.8 }
  for resource, guid in pairs(bags.resources) do
    params.click_function = 'takeResource' .. resource
    getObjectFromGUID(guid).createButton(params)

    _G['takeResource' .. resource] = function(obj, clickColor, alt)
      if not doneLoading or not isSeated(clickColor) then return end
      takeResourceButton(resource, clickColor)
    end
  end

  -- player resource bag counters creation
  params = {
    function_owner = self,
    position = { 0, 0, 1.9 },
    width = 700,
    height = 700,
    font_size = 400
  }
  for _, playerColor in ipairs(seatedPlayerColors) do
    if not (options.solo and playerColor == 'Red') then
      local vars = playerVars[playerColor]
      for resource, guid in pairs(vars.resourceBagZones) do
        local bag = getObjectFromGUID(vars.resourceBags[resource])
        params.label = tostring(bag.getQuantity())
        params.click_function = 'clickResourceBag' .. resource .. playerColor
        getObjectFromGUID(guid).createButton(params)

        _G['clickResourceBag' .. resource .. playerColor] = function(obj, clickColor, alt)
          if not doneLoading or clickColor ~= playerColor then return end
          if alt then
            if bag.getQuantity() > 0 then getObjectFromGUID(vars.trashGuid).putObject(bag.takeObject()) end
          else
            takeResourceButton(resource, clickColor)
          end
        end
      end
      if options.playerBoards[playerColor] == 4 then
        for resource, guid in pairs(suitcaseResourceBags) do
          local bag = getObjectFromGUID(guid)
          if bag ~= nil then
            params.label = tostring(bag.getQuantity())
            params.click_function = 'clickResourceBag' .. resource .. 'Suitcase'
            getObjectFromGUID(vars.suitcaseResourceBagZones[resource]).createButton(params)

            _G['clickResourceBag' .. resource .. 'Suitcase'] = function(obj, clickColor, alt)
              if not doneLoading or clickColor ~= playerColor then return end
              if alt then
                if bag.getQuantity() > 0 then getObjectFromGUID(vars.trashGuid).putObject(bag.takeObject()) end
              else
                takeResourceButton(resource, clickColor, true)
              end
            end
          end
        end
      end
    end
  end
end

--This function will do a variety of things to setup the campaign including moving campiagn related objects to the table, determining first player, etc
function setupCampaignMisc()
  local campaignBag = getObjectFromGUID(bags.campaignItems)

  -- shuffle bonus encounter cards and reposition them to make space for the chapter 6 deck
  for i = 1, 5 do
    local zone = getObjectFromGUID(deckZones["bonus" .. i])
    for _, obj in ipairs(zone.getObjects()) do
      if obj.type == "Deck" then
        obj.setPosition(obj.getPosition() + Vector(-4.0, 0, 0))
        obj.shuffle()
      end
    end
  end

  setupButtonsMisc()

  -- place the chapter 6 encounter deck on the board
  campaignBag.takeObject({
    position = { 18.5, 1.54, 47.00 },
    guid     = '0ac1dc',
    smooth   = false,
    rotation = { 0.00, 180.00, 180.00 }
  })

  -- place the campaign book at the edge of the table
  campaignBag.takeObject({
    position          = { -27.86, 1.50, 50.34 },
    callback_function = function(x)
      x.setLock(true)
      x.setPositionSmooth({ 36.00, 6.80, 55.00 })
      x.setRotationSmooth({ 60.00, 180.00, 0.00 })
    end,
    smooth            = true,
    guid              = '0cf9c7',
  })

  -- place the campaign tracker at the edge of the table
  campaignBag.takeObject({
    position          = { -27.86, 1.50, 50.34 },
    callback_function = function(x)
      x.setLock(true)
      x.setPositionSmooth({ 45.00, 6.80, 55.00 })
      x.setRotationSmooth({ 60.00, 180.00, 0.00 })
    end,
    smooth            = true,
    guid              = 'c64617',
  })

  -- place the overview cards in two rows below the campaign book
  local overViewGuids = { '7e55f6', '2f7531', '248eeb', 'f1bd54', '78cbcd', '74971a' }
  local startLoc = { 33.0, 1.55, 47.0 }
  local newLoc = {}
  for i, g in ipairs(overViewGuids) do
    if i <= 3 then
      newLoc = { startLoc[1] + (8 * (i - 1)), startLoc[2], startLoc[3] }
    else
      newLoc = { startLoc[1] + (8 * (i - 4)), startLoc[2], 40 }
    end
    campaignBag.takeObject({
      position = newLoc,
      rotation = { 0.00, 180.00, 180.00 },
      smooth   = false,
      guid     = g,
    })
  end

  -- If two players are playing place the pidgeon tokens on the board
  if #seatedPlayerColors == 3 then
    campaignBag.takeObject({
      position = { -15.00, 1.51, 36.50 },
      smooth   = true,
      rotation = { 0.00, 180.00, 180.00 },
      guid     = '20c269',
    })
  end

  -- Iterate through the expansion decks and grab the decks containing the expansion content (idols, assistants, guardians, sties)
  -- Grab the decks of the base game belonging to each of those types, then add the expansion decks to the base decks
  local baseDeck = nil
  local expDeck = nil
  for key, value in pairs(expansionDecks) do    -- Outer table containing the list of expansions
    for deckType, guidString in pairs(value) do -- Inner table containing the deck types and guids per expansion from outer table
      -- Delete the missing expedition site decks as they cannot be used in the campaign
      if key == 'missingExpedition' and (deckType == 'sites1' or deckType == 'sites2') then
        getObjectFromGUID(guidString).destruct()
        -- for idols and assistants, the base deck guids are defined as global variables and not as deck zones
      elseif deckType == 'idols' then
        baseDeck = getObjectFromGUID(idolDeckGuid)
        expDeck = getObjectFromGUID(guidString)
        baseDeck.putObject(expDeck)
      elseif deckType == 'assistants' then
        baseDeck = getObjectFromGUID(assistantDeckGuid)
        expDeck = getObjectFromGUID(guidString)
        baseDeck.putObject(expDeck)
      else
        -- for the other deck types, their guids are not stored but instead we have to use their deck zones to grab the deck guid
        for _, object in ipairs(getObjectFromGUID(deckZones[deckType]).getObjects()) do
          if object.type == 'Deck' then
            baseDeck = object
            break
          end
        end
        expDeck = getObjectFromGUID(guidString)
        baseDeck.putObject(expDeck) -- put expansion deck into base deck of the same type
      end
    end
  end

  -- Determine a first player thats not the red bot
  repeat
    startPlayerIndex = math.random(1, #seatedPlayerColors)
    firstPlayerColor = seatedPlayerColors[startPlayerIndex]
  until firstPlayerColor ~= 'Red'

  for _, playerColor in ipairs(seatedPlayerColors) do
    if playerColor ~= 'Red' then
      if options.playerBoards[playerColor] == 3 then
        decks[playerColor].takeObject({ guid = cards.baroness }).deal(1, playerColor)
        decks[playerColor].deal(4, playerColor)
      else
        decks[playerColor].deal(5, playerColor)
      end
      if options.playerBoards[playerColor] == 6 then decks.fear.deal(1, playerColor) end
    end
  end

  local soloBag = getObjectFromGUID(bags.solo)
  -- Place the bot player base action deck
  soloBag.takeObject({
    position = { -59.79, 1.50, -0.04 },
    rotation = { 0.00, 180.00, 0.00 },
    smooth   = true,
    guid     = solo.actionDecks[1],
  })

  -- Place the bot player advanced (green,red,purple) action deck
  soloBag.takeObject({
    position          = { -55.79, 1.50, -0.04 },
    rotation          = { 0.00, 180.00, 0.00 },
    smooth            = true,
    guid              = solo.actionDecks[2],
    callback_function = function(x)
      -- Iterate through the advanced deck and seperate out the different colors to be their own decks
      for _, card in ipairs(x.getObjects()) do
        if card.gm_notes == 'red' then
          x.takeObject({
            position = { -51.79, 1.50, -0.04 },
            smooth   = true,
            guid     = card.guid
          })
        elseif card.gm_notes == 'purple' then
          x.takeObject({
            position = { -47.79, 1.50, -0.04 },
            smooth   = true,
            guid     = card.guid
          })
        end
      end
    end
  })

  -- Set turn to randomized player and begin game!
  broadcastToAll('Campaign Starts!')
  Turns.turn_color = firstPlayerColor
  Turns.enable = true
  setupInProgress = false
  round = 1
end

function setupStartingResources()
  -- distribute starting player decks and tokens
  local tokenBag = getObjectFromGUID(bags.miscTokens)
  local refBag = getObjectFromGUID(bags.leaderRef)
  local references = {}
  for _, playerColor in ipairs(seatedPlayerColors) do
    if options.solo and playerColor == 'Red' then -- if playing solo and this is the red player, setup the pawns
      for i, guid in ipairs(solo.pawns) do
        if i < 4 then
          local pawn = getObjectFromGUID(guid) -- setup the red pawns already on the board as part of startup board state
          if pawn ~= nil then
            pawn.setRotationSmooth(faceup, false, true)
            pawn.setPositionSmooth(solo.pawnPositions[i], false, true)
          end
        else -- take the rest of red pawns from the solo bag and set them up
          local soloBag = getObjectFromGUID(bags.solo)
          soloBag.takeObject({ guid = guid, position = solo.pawnPositions[i], rotation = faceup })
        end
      end
    else
      local playerBoardState = options.playerBoards[playerColor]
      local vars = playerVars[playerColor]

      if playerBoardState ~= 1 then
        local pawn = getObjectFromGUID(vars.pawns[3])
        if pawn ~= nil then pawn.destruct() end
      end

      -- collect data for deck spawning
      local cardList
      local deckPos = getObjectFromGUID(getDeckZoneGuid(playerColor)).getPosition()
      local boardLocation = getPlayerBoard(playerColor).getPosition()

      -- The mechanic and journalist need a small adjustment to their deck placement location if blue or green player
      if (playerBoardState == 7 or playerBoardState == 8) and (playerColor == "Green" or playerColor == "Blue") then
        deckPos = deckPos - Vector(0.08, 0, 0)
      end

      if playerBoardState == 9 then
        -- if the player board is the base board, grab the player deck for the board color
        cardList = starterDeck[playerColor]
      else
        local refIndex = playerBoardState * 2 - 2
        for i = 1, 2 do
          local ref = refBag.takeObject({ position = vars.refPositions[i], rotation = faceup, smooth = false })
          wait(0.01)
          table.insert(references, { obj = ref, state = refIndex + i })
        end

        if playerBoardState == 1 then     -- Setup for the captain
          cardList = starterDeck["Captain"]
        elseif playerBoardState == 2 then -- Setup for the falcon
          cardList = starterDeck["Falconer"]
          tokenBag.takeObject({
            guid = tokens.falcon,
            position = vars.falconPositions[2],
            rotation = falconRotations[2]
          })
        elseif playerBoardState == 3 then -- Setup for the baroness
          cardList = starterDeck["Baroness"]
        elseif playerBoardState == 4 then -- Setup for the professor
          cardList = starterDeck["Professor"]
          local profStuff = {}
          local suitcase = tokenBag.takeObject({
            guid = tokens.suitcase,
            position = vars.suitcasePosition,
            rotation = faceup
          })
          table.insert(profStuff, suitcase)
          for resource, guid in pairs(suitcaseResourceBags) do -- Place and setup the professor's Bag
            local toPos = getObjectFromGUID(vars.suitcaseResourceBagZones[resource]).getPosition()
            local resourceBag = tokenBag.takeObject({
              guid = guid,
              position = { toPos[1], 1.63, toPos[3] },
              rotation = faceup
            })
            table.insert(profStuff, resourceBag)
          end
          wait(0.3)
          for _, obj in ipairs(profStuff) do
            obj.setDescription(playerColor)
            obj.lock()
          end

          -- add cards to archive
          local archive = {}
          for i = 1, 3 do
            local card = drawCard(deckZones.artifacts)
            card.use_hands = false
            card.setRotationSmooth(faceup, false, true)
            card.setPositionSmooth(playerVars[playerColor].archivePositions[i], false, true)
            table.insert(archive, card)
          end
          wait(0.4)
          for _, card in ipairs(archive) do
            card.use_hands = true
          end
        elseif playerBoardState == 5 then -- Setup for the explorer
          cardList = starterDeck["Explorer"]
          local pawn = getObjectFromGUID(vars.pawns[2])
          if pawn ~= nil then pawn.destruct() end
          for i, guid in ipairs(tokens.food) do
            local pos = vars.foodPositions[i]
            if i == 3 then
              pos = { 4.89, 1.53, 40 }
            end
            tokenBag.takeObject({ guid = guid, position = pos, rotation = faceup, smooth = true })
          end
        elseif playerBoardState == 6 then -- Setup for the mystic
          cardList = starterDeck["Mystic"]
        elseif playerBoardState == 7 then -- Setup for the journalist
          cardList = starterDeck["Journalist"]
          -- Grab the newspaper token deck, shuffle, then place two newspapers into their location relative to the player board
          tokenBag.takeObject({
            guid              = tokens.journalistNewspapers,
            position          = Vector(-55.98, 1.55, 53.02),
            smooth            = true,
            callback_function = function(x)
              x.shuffle()
              x.takeObject({
                position          = boardLocation + Vector(8.82, 0.06, -0.58),
                smooth            = true,
                callback_function = function(y) y.setLock(true) end
              })
              x.takeObject({
                position          = boardLocation + Vector(14.74, 0.06, -0.59),
                smooth            = true,
                callback_function = function(y) y.setLock(true) end
              })
              x.destruct()
            end
          })
          -- As journalist place article tokens on to the player board for "featured articles". 3 or more players sets only two articles and 2 or less set all 3 articles.
          local articlePosition = vars.articlePosition
          tokenBag.takeObject({
            guid              = tokens.journalistArticles,
            position          = articlePosition,
            smooth            = true,
            callback_function = function(x)
              local boardArticleLocations = {
                Vector(8.87, 0.06, 4.54),
                Vector(11.76, 0.06, 4.54),
                Vector(14.61, 0.06, 4.54)
              }
              local count = 2
              if #seatedPlayers <= 2 then count = 3 end
              for i = 1, count do
                x.takeObject({ position = boardLocation + boardArticleLocations[i] })
              end
              -- Use the pre-defined pawn placement location array and place the remaining article tokens to the left of them
              for i = 1, 3 do
                for _, siteData in ipairs(siteLevels[i]) do
                  local pos = getObjectFromGUID(siteData.pawnSpaces[1]).getPosition()
                  x.takeObject({ position = pos + Vector(-2.25, 0, -0.08) })
                end
              end
            end
          })
        elseif playerBoardState == 8 then -- Setup for the mechanic
          cardList = starterDeck["Mechanic"]
          local goldenTeethPosition = vars.goldenTeethPosition
          tokenBag.takeObject({
            position          = goldenTeethPosition,
            smooth            = true,
            guid              = tokens.MechanicGoldTokens,
            rotation          = facedown,
            callback_function = function(x)
              -- Here we take the golden teeth deck and shuffle it, split it into 4 stacks of two each and move 3 of those 4 stacks to above the player board
              x.shuffle()
              local offsets = nil
              if playerColor == "Blue" or playerColor == "Green" then
                offsets = {
                  Vector(13.5, 0.2, 7.2),
                  Vector(16.25, 0.2, 7.2),
                  Vector(19, 0.2, 7.2)
                }
              elseif playerColor == "Red" or playerColor == "Yellow" then
                offsets = {
                  Vector(-13.5, 0.2, 7.2),
                  Vector(-16.25, 0.2, 7.2),
                  Vector(-19, 0.2, 7.2)
                }
              end

              for _, offset in ipairs(offsets) do
                for i = 1, 2 do
                  x.takeObject({ position = boardLocation + offset, smooth = true })
                end
              end
            end
          })
          -- Place the mechanic monkey assistant
          local monkeyPosOffsets = { Vector(-15.3, 0.02, 11.35), Vector(-14.12, 0, -6.74) }
          if playerColor == "Green" or playerColor == "Blue" then
            monkeyPosOffsets = { Vector(15.3, 0.02, 11.35), Vector(14.12, 0, -6.74) }
          end

          tokenBag.takeObject({
            position = boardLocation + monkeyPosOffsets[1],
            smooth   = true,
            guid     = tokens.MechanicMonkey
          })
          tokenBag.takeObject({
            position          = boardLocation + monkeyPosOffsets[2],
            rotation          = { 0, 0, 0 },
            smooth            = true,
            guid              = tokens.MechanicGoldTokenAttacher,
            callback_function = function(x) x.setLock(true) end
          })

          -- Place the spinning wheel for mechanic and lock it in place
          tokenBag.takeObject({
            position          = boardLocation + Vector(13.88, 0.05, -0.09),
            rotation          = { 0, 316.32, 0 },
            smooth            = true,
            guid              = tokens.MechanicWheel,
            callback_function = function(x) x.setLock(true) end
          })
        end

        -- add two fear cards to the deck
        table.insert(cardList, "0000")
        table.insert(cardList, "0000")

        -- spawn the deck
        decks[playerColor] = AllCardsBag.call("spawnCardList", {
          cardList = cardList,
          rotation = facedown,
          position = deckPos
        })
      end
    end
  end

  wait(0.4)

  for _, ref in ipairs(references) do
    if ref.state ~= 1 then ref.obj.setState(ref.state) end
  end

  wait(0.4)

  for _, playerColor in ipairs(seatedPlayerColors) do
    if not (options.solo and playerColor == 'Red') then
      for _, object in ipairs(getObjectFromGUID(playerVars[playerColor].refZoneGuid).getObjects()) do
        if object.type == 'Tile' then object.lock() end
      end
    end
  end

  wait(0.5)

  -- shuffle decks
  for _, deck in pairs(decks) do
    if deck ~= nil then
      deck.shuffle()
    end
  end

  -- starting resources
  if options.solo and (options.campaign == false or options.campaign == nil) and #seatedPlayerColors == 2 then
    takeResourceButton('c', seatedPlayerColors[1])
    takeResourceButton('s', seatedPlayerColors[1])
  else
    local passedFirstPlayer = false
    local turnOrder = 0
    local resourcesPerTurnOrder = { { c = 2, s = 0 }, { c = 1, s = 1 }, { c = 2, s = 1 }, { c = 1, s = 2 } }
    for i = 1, 2 do
      for _, playerColor in ipairs(seatedPlayerColors) do
        if playerColor == firstPlayerColor then
          if passedFirstPlayer then break end
          passedFirstPlayer = true
        end
        if passedFirstPlayer then
          turnOrder = turnOrder + 1
          for resource, count in pairs(resourcesPerTurnOrder[turnOrder]) do
            for i = 1, count do
              takeResourceButton(resource, playerColor)
              wait(0.1)
            end
          end
        end
      end
    end
  end
end

function menuStart(_, value, _)
  uiOff()
  local menuChoice = tonumber(value)
  if menuChoice == 1 then
    -- If the player chose campaign set a variety of options then show the manual leader choosing UI
    options.campaign = true
    options.leaders = 'choose'
    options.solo = true
    options.expansions.expeditionLeaders = true
    options.expansions.missingExpedition = true
    UI.setAttribute('continueMenu', 'active', 'true')
    UI.setAttribute('continueMenuButtons', 'active', 'true')
  elseif menuChoice == 2 and checkToggle('leaders2') then
    -- Only show the manual choice menu if player chose that during setup options
    UI.setAttribute('continueMenu', 'active', 'true')
    UI.setAttribute('continueMenuButtons', 'active', 'true')
  else
    startLuaCoroutine(Global, "setupGame")
  end
end

function menuStartSolo()
  local red = tonumber(UI.getAttribute('redSlider', 'value'))
  local purple = tonumber(UI.getAttribute('purpleSlider', 'value'))
  local actionCounts = { 5 - red - purple, red, purple }
  if red + purple > 5 then
    broadcastToAll('Cannot use more than five red and purple action cards combined.')
    return
  end
  options.objectives = tonumber(UI.getAttribute('objectiveSlider', 'value'))
  uiOff()

  function menuStartSoloCoroutine()
    local bag = getObjectFromGUID(bags.solo)
    if options.objectives > 0 then
      bag.takeObject({
        guid = solo.objectives,
        position = solo.objectivePosition,
        rotation = facedown
      })
    end
    local index = 0
    for _, guid in pairs(solo.actionDecks) do
      index = index + 1
      bag.takeObject({ guid = guid, position = solo.setupPositions[index], rotation = facedown })
    end
    wait(0.4)

    local actionDeck = getObjectFromGUID(solo.actionDecks.arch)
    local otherActionCards = getObjectFromGUID(solo.actionDecks.other)
    for i = 3, 1, -1 do
      if actionCounts[i] > 0 then
        for j = 1, actionCounts[i] do
          local rand = math.random(1, #solo.actionCardTypes)
          local actionType = solo.actionCardTypes[rand]
          actionDeck.putObject(otherActionCards.takeObject({ guid = solo.actionCards[actionType][i] }))
          table.remove(solo.actionCardTypes, rand)
        end
      end
    end
    wait(1.4)
    actionDeck.setRotationSmooth(facedown, false, true)
    actionDeck.setPositionSmooth(solo.deckPositions[1], false, true)
    wait(0.5)

    actionDeck.shuffle()
    if options.objectives > 0 then getObjectFromGUID(solo.objectives).shuffle() end
    for _, object in ipairs(getObjectFromGUID(solo.zones.delete).getObjects()) do
      if not (options.objectives > 0 and object.getName() == 'Solo Temple Tiles') then object.destruct() end
    end
    for _, playerColor in ipairs(seatedPlayerColors) do
      if playerColor ~= 'Red' then
        for _, object in ipairs(getObjectFromGUID(getDeckZoneGuid(playerColor)).getObjects()) do
          if object.type == 'Deck' then
            object.shuffle()
            break
          end
        end
      end
    end
    wait(0.5)

    for _, playerColor in ipairs(seatedPlayerColors) do
      if playerColor ~= 'Red' then
        local deck = nil
        for _, object in ipairs(getObjectFromGUID(getDeckZoneGuid(playerColor)).getObjects()) do
          if object.type == 'Deck' then
            deck = object
            break
          end
        end
        if options.playerBoards[playerColor] == 3 then
          deck.takeObject({ guid = cards.baroness }).deal(1, playerColor)
          deck.deal(4, playerColor)
        else
          deck.deal(5, playerColor)
        end
        if options.playerBoards[playerColor] == 6 then drawCard(deckZones.fear).deal(1, playerColor) end
        getObjectFromGUID(playerVars[playerColor].tentGuid).unlock()
      end
    end
    broadcastToAll('Starting Round 1')
    setupInProgress = false
    if options.solo and #seatedPlayerColors == 2 then rivalTurnCoroutine() end
    return 1
  end

  startLuaCoroutine(Global, 'menuStartSoloCoroutine')
end

function drawLines()
  local vectorLines = {}
  for _, playerColor in ipairs(seatedPlayerColors) do
    local zone = getObjectFromGUID(playerVars[playerColor].playAreaZoneGuid)
    local pos = zone.getPosition()
    local scale = zone.getScale()
    local vectorLine = { points = {}, color = playerColor, thickness = 0.2, rotation = { 0, 0, 0 } }
    table.insert(vectorLine.points, { pos.x - scale.x / 2, 1.5, pos.z + scale.z / 2 })
    table.insert(vectorLine.points, { pos.x + scale.x / 2, 1.5, pos.z + scale.z / 2 })
    table.insert(vectorLine.points, { pos.x + scale.x / 2, 1.5, pos.z - scale.z / 2 })
    table.insert(vectorLine.points, { pos.x - scale.x / 2, 1.5, pos.z - scale.z / 2 })
    table.insert(vectorLine.points, { pos.x - scale.x / 2, 1.5, pos.z + scale.z / 2 })
    table.insert(vectorLines, vectorLine)
  end
  Global.setVectorLines(vectorLines)
end

---------------------- BUTTONS
--Create buttons primarily used for standard play
function setupButtons()
  local params = {
    function_owner = self,
    label = 'Setup Round ' .. round + 1,
    click_function = 'nextRoundButton',
    position = { 8.23, 0, -3 },
    width = 2400,
    height = 500,
    font_size = 250
  }
  if round == 5 then
    params.label = 'Calculate Scores'
    params.click_function = 'calculateScoresButton'
  end
  local buttonZone = getObjectFromGUID(deckZones.fear)
  buttonZone.createButton(params)

  setupButtonsMisc()

  -- buy card row
  params = {
    function_owner = self,
    label = 'Buy',
    click_function = 'takeFearButton',
    position = { 0, 0, -2.4 },
    width = 800,
    height = 380,
    font_size = 200
  }


  for i, guid in ipairs(cardRowZoneGuids) do
    params.click_function = 'buy' .. i
    getObjectFromGUID(guid).createButton(params)

    _G['buy' .. i] = function(obj, clickColor, alt)
      if not doneLoading or setupInProgress or movingRow or not isSeated(clickColor) then return end
      buyButton(obj, clickColor, alt)
    end
  end

  -- place pawns
  params = {
    function_owner = self,
    label = '+',
    width = 600,
    height = 600,
    font_size = 500
  }
  for i, level in ipairs(siteLevels) do
    for j, siteInfo in ipairs(level) do
      for k, guid in ipairs(siteInfo.pawnSpaces) do
        if k < 2 or not siteInfo.blocked then
          if i == 4 then
            params.position = { 0, 0, 1.4 }
          else
            params.position = { 1.6, 0, 0 }
          end
          params.click_function = 'placePawn' .. i .. j .. k
          getObjectFromGUID(guid).createButton(params)

          _G['placePawn' .. i .. j .. k] = function(obj, clickColor, alt)
            if discovering or not doneLoading or setupInProgress or not isSeated(clickColor) then return end
            placePawn(clickColor, obj, siteInfo, i, alt)
          end
        end
      end
    end
  end

  -- discover sites button creation
  params = {
    function_owner = self,
    width = 1200,
    height = 280,
    font_size = 150
  }
  for i = 1, 3 do
    for _, siteInfo in ipairs(siteLevels[i]) do
      if not siteInfo.discovered then
        params.label = '+Site & Guardian'
        params.click_function = 'discoverSG' .. siteInfo.guid
        params.position = { 0, 0, -1.5 }
        getObjectFromGUID(siteInfo.guid).createButton(params)

        params.label = '+Site Only'
        params.click_function = 'discoverS' .. siteInfo.guid
        params.position = { 0, 0, -0.9 }
        getObjectFromGUID(siteInfo.guid).createButton(params)

        _G['discoverSG' .. siteInfo.guid] = function(obj, clickColor, alt)
          if discovering or not doneLoading or setupInProgress or not isSeated(clickColor) and clickColor ~= 'Black' then return end
          discoverButton(obj, clickColor)
        end

        _G['discoverS' .. siteInfo.guid] = function(obj, clickColor, alt)
          if discovering or not doneLoading or setupInProgress or not isSeated(clickColor) and clickColor ~= 'Black' then return end
          discoverButton(obj, clickColor, true)
        end
      end
    end
  end

  if options.solo then setupButtonRivalTurn() end
end

function takeResourceButton(resource, clickColor, alt)
  local fromBag = getObjectFromGUID(bags.resources[resource])
  if alt then
    local toBag = getObjectFromGUID(suitcaseResourceBags[resource])
    toBag.putObject(fromBag.takeObject())
  else
    local toBag = getObjectFromGUID(playerVars[clickColor].resourceBags[resource])
    toBag.putObject(fromBag.takeObject())
  end
end

function takeFearButton(zone, clickColor)
  if not doneLoading or not isSeated(clickColor) then return end
  local card = drawCard(zone)
  if card == nil then card = getObjectFromGUID(bags.fear).takeObject() end
  local toPos = getObjectFromGUID(playerVars[clickColor].playAreaZoneGuid).getPosition()
  local xOffset = 16.5
  if clickColor == 'Red' or clickColor == 'Yellow' then xOffset = 0 - xOffset end
  card.setPositionSmooth({ toPos[1] + xOffset, tableY + 0.5, toPos[3] }, false, true)
end

-- helper function to get the metadata for a card
function getMetaData(card)
  if card.type ~= "Card" then return {} end

  local md = JSON.decode(card.getGMNotes()) or {}
  if md.type == "Item" then
    md.resource = "coin"
  elseif md.type == "Artifact" then
    md.resource = "compass"
  end
  return md
end

function buyButton(zone, clickColor, alt)
  function buyButtonCoroutine()
    movingRow = true
    local card = drawCard(zone)
    local vars = playerVars[clickColor]
    if card ~= nil then
      local md = getMetaData(card)
      if alt then
        local bag
        if md.resource == "compass" then
          bag = getObjectFromGUID(vars.resourceBags.s)
        elseif md.resource == "coin" then
          bag = getObjectFromGUID(vars.resourceBags.c)
        end

        if bag.getQuantity() >= md.cost then
          broadcastToAll(getPlayerName(clickColor) .. ' spends ' .. md.cost .. ' ' ..
            md.resource .. ' tokens to buy a card.')
          for i = 1, md.cost do
            if bag.getQuantity() > 0 then
              getObjectFromGUID(vars.trashGuid).putObject(bag.takeObject())
              wait(0.16)
            end
          end
          wait(0.5)
        else
          broadcastToColor('You do not have enough ' .. md.resource .. ' tokens to buy this card.', clickColor)
          movingRow = false
          return 1
        end
      end

      if md.type == "Artifact" then
        local toPos = getObjectFromGUID(vars.playAreaZoneGuid).getPosition()

        local xOffset = 11.5
        if clickColor == 'Red' or clickColor == 'Yellow' then
          xOffset = 0 - xOffset
        end
        card.setPositionSmooth({ toPos[1] + xOffset, tableY + 0.5, toPos[3] }, false, true)

        local suffix = ' compass).'
        if md.cost > 1 then suffix = ' compasses).' end
        broadcastToAll(getPlayerName(clickColor) .. ' bought ' .. card.getName() .. ' (' .. md.cost .. suffix)
      else
        local deckZone = getObjectFromGUID(getDeckZoneGuid(clickColor))
        local toPos = deckZone.getPosition()
        local deck = nil
        for _, object in ipairs(deckZone.getObjects()) do
          if object.type == 'Deck' then
            deck = object
            break
          elseif object.type == 'Card' then
            object.setPositionSmooth({ toPos[1], tileY + 0.5, toPos[3] }, false, true)
            break
          end
        end
        if deck == nil then
          card.setRotationSmooth(facedown, false, true)
          card.setPositionSmooth({ toPos[1], tileY, toPos[3] }, false, true)
        else
          deck.putObject(card)
        end
        local suffix = ' coin).'
        if md.cost > 1 then suffix = ' coins).' end
        broadcastToAll(getPlayerName(clickColor) .. ' bought ' .. card.getName() .. ' (' .. md.cost .. suffix)
      end
    end
    wait(0.4)
    refillRowCoroutine()
    return 1
  end

  startLuaCoroutine(Global, 'buyButtonCoroutine')
end

function refillRowCoroutine()
  -- get cards/decks in the row
  local artifacts = {}
  local items = {}
  for i, guid in ipairs(cardRowZoneGuids) do
    for _, object in ipairs(getObjectFromGUID(guid).getObjects()) do
      if object.type == 'Card' or object.type == 'Deck' then
        if i <= round then
          table.insert(artifacts, object)
        else
          table.insert(items, object)
        end
        cardExists = true
        break
      end
    end
  end

  if #artifacts < round or #items < 6 - round then
    -- shift
    if #artifacts > 0 and #artifacts < round then
      for i = 1, #artifacts do
        local toPos = getObjectFromGUID(cardRowZoneGuids[round - i + 1]).getPosition()
        artifacts[#artifacts - i + 1].setPositionSmooth({ toPos[1], tileY, toPos[3] }, false, true)
      end
    end
    if #items > 0 and #items < 6 - round then
      for i = 1, #items do
        local toPos = getObjectFromGUID(cardRowZoneGuids[round + i]).getPosition()
        items[i].setPositionSmooth({ toPos[1], tileY, toPos[3] }, false, true)
      end
    end
    if #artifacts > 0 and #artifacts < round or #items > 0 and #items < 6 - round then wait(0.26) end

    -- refill
    if #artifacts < round then
      for i = 1, round - #artifacts do
        local toPos = getObjectFromGUID(cardRowZoneGuids[i]).getPosition()
        local card = drawCard(deckZones.artifacts, faceup, { toPos[1], tileY, toPos[3] })
        if card == nil then break end
        wait(0.16)
      end
    end
    if #items < 6 - round then
      for i = round + #items + 1, 6 do
        local toPos = getObjectFromGUID(cardRowZoneGuids[i]).getPosition()
        local card = drawCard(deckZones.items, faceup, { toPos[1], tileY, toPos[3] })
        if card == nil then break end
        wait(0.16)
      end
    end
    wait(0.2)
  end
  movingRow = false
  return 1
end

function placePawn(playerColor, zone, siteInfo, level, alt)
  -- check occupied
  for _, obj in ipairs(zone.getObjects()) do
    if obj.hasTag('pawn') then
      broadcastToColor('This space is occupied.', playerColor)
      return
    end
  end

  -- look for a free pawn
  local vars = playerVars[playerColor]
  local pawn = nil
  if options.playerBoards[playerColor] == 5 then
    pawn = getObjectFromGUID(vars.pawns[1])
    if pawn == nil then
      broadcastToColor('Your archaeologist was not found.', playerColor)
      return
    end
  else
    for _, obj in ipairs(getObjectFromGUID(vars.tentZoneGuid).getObjects()) do
      if obj.hasTag('pawn') and obj.getDescription() == playerColor then
        pawn = obj
        break
      end
    end
    if pawn == nil then
      broadcastToColor('No archaeologists found near your tent space.', playerColor)
      return
    end
  end

  -- check for idol/site
  local idolFaceup = nil
  local idolFacedown = nil
  local site = nil
  for _, obj in ipairs(getObjectFromGUID(siteInfo.guid).getObjects()) do
    if obj.hasTag('idol') then
      if obj.type == 'Deck' or obj.is_face_down and idolFacedown ~= nil or not obj.is_face_down and idolFaceup ~= nil then
        local faceMsg = 'face-up'
        if obj.is_face_down then faceMsg = 'face-down' end
        broadcastToAll('More than one ' .. faceMsg .. ' idol found at this location.')
        return
      end
      if obj.is_face_down then
        idolFacedown = obj
      else
        idolFaceup = obj
      end
    elseif obj.hasTag('site1') or obj.hasTag('site2') then
      if obj.type == 'Deck' or site ~= nil then
        broadcastToAll('More than one site card found at this location.')
        return
      end
      site = obj
    end
  end
  if (idolFaceup ~= nil or idolFacedown ~= nil) and site ~= nil then
    broadcastToAll('Idol and site card both found at this location.')
    return
  end

  function placePawnCoroutine()
    discovering = true
    if level < 4 and alt and (idolFaceup ~= nil or idolFacedown ~= nil) then
      local compassCost = 3
      if level == 1 then compassCost = 6 end
      local bag = getObjectFromGUID(vars.resourceBags.s)
      if bag.getQuantity() >= compassCost then
        broadcastToAll(getPlayerName(playerColor) .. ' spends ' .. compassCost .. ' compasses to discover a site.')
        for i = 1, compassCost do
          if bag.getQuantity() > 0 then
            getObjectFromGUID(vars.trashGuid).putObject(bag.takeObject())
            wait(0.16)
          end
        end
        wait(0.5)
      else
        broadcastToColor('You do not have enough compass tokens to discover this site.', playerColor)
        discovering = false
        return 1
      end
    end
    local toPos = zone.getPosition()
    pawn.setRotationSmooth(faceup, false, true)
    pawn.setPositionSmooth({ toPos[1], pawnY, toPos[3] }, false, false)
    wait(0.6)
    if idolFaceup ~= nil or idolFacedown ~= nil then
      local idolPosition3 = getGlobalPosForIdolSlot(playerColor, 3) - Vector(0, 0, 3)
      local idolPosition4 = getGlobalPosForIdolSlot(playerColor, 4) - Vector(0, 0, 3)
      local toPosFaceup = idolPosition3:setAt("y", tileY + 0.3)
      local toPosFacedown = idolPosition4:setAt("y", tileY + 0.3)

      if idolFaceup ~= nil then
        local delivered = deliverRewards(playerColor, idolFaceup)
        wait(0.5)
        if delivered then
          idolFaceup.setRotation(facedown)
          idolFaceup.setPositionSmooth(toPosFacedown, false, false)
        else
          idolFaceup.setRotation(faceup)
          idolFaceup.setPositionSmooth(toPosFaceup, false, false)
        end
      end
      if idolFacedown ~= nil then
        idolFacedown.setRotation(facedown)
        idolFacedown.setPositionSmooth(toPosFacedown, false, false)
      end
    elseif site ~= nil then
      deliverRewards(playerColor, site)
    elseif tonumber(zone.getName()) == 4 then
      deliverRewards(playerColor, zone)
    end
    discovering = false
    return 1
  end

  startLuaCoroutine(Global, 'placePawnCoroutine')
end

function getGlobalPosForIdolSlot(playerColor, points)
  local board = getPlayerBoard(playerColor)
  local idolData = idolSlotData[options.playerBoards[playerColor]]

  for _, data in ipairs(idolData) do
    if data.points == points then
      return board.positionToWorld(data.localPos)
    end
  end
end

-- function that checks the gm notes to determine what rewards the player should get
function deliverRewards(playerColor, obj)
  local rewards = obj.getGMNotes()
  local resourceLabels = { t = 'tablet', a = 'arrowhead', j = 'jewel', c = 'coin', s = 'compass' }
  local resourceCount = {}
  local deliveredAll = true
  local deliveredResources = false
  for i = 1, string.len(rewards) do
    local reward = string.sub(rewards, i, i)

    -- these resources are automatically given to the player
    if resourceLabels[reward] ~= nil then
      takeResourceButton(reward, playerColor)
      if resourceCount[reward] == nil then
        resourceCount[reward] = 1
      else
        resourceCount[reward] = resourceCount[reward] + 1
      end
      deliveredResources = true

      -- for these rewards the player must manually take action on
    elseif tonumber(reward) then
      -- draw a card from the respective bonus deck
      local card = drawCard(deckZones["bonus" .. tonumber(reward)])
      if card ~= nil then
        card.deal(1, playerColor)
        wait(0.3)
      end
      broadcastToAll(getPlayerName(playerColor) .. ' has to choose an option from the dealt bonus card.')
      deliveredAll = false
    elseif reward == 'u' then
      broadcastToAll(getPlayerName(playerColor) .. ' may upgrade one resource.')
      deliveredAll = false
    elseif reward == 'r' then
      broadcastToAll(getPlayerName(playerColor) .. ' may refresh an assistant.')
      deliveredAll = false
    elseif reward == 'e' then
      broadcastToAll(getPlayerName(playerColor) .. ' may exile a card.')
      deliveredAll = false
    elseif reward == 'i' then
      broadcastToAll(getPlayerName(playerColor) .. ' may return two compasses to take an item for free.')
      deliveredAll = false
    elseif reward == 'm' then
      broadcastToAll(getPlayerName(playerColor) .. ' may activate a campsite.')
      deliveredAll = false
    elseif reward == 'g' then
      broadcastToAll(getPlayerName(playerColor) .. ' may flip an expended guardian for reuse.')
      deliveredAll = false
    elseif reward == 'p' then
      broadcastToAll(getPlayerName(playerColor) .. ' may take one 2-point temple tile from any stack for free.')
      deliveredAll = false
    elseif reward == 'f' then -- give fear cards automatically to the player
      -- exception for miners helmet
      if not hasMinersHelmetActive(playerColor) then
        broadcastToAll(getPlayerName(playerColor) .. ' gets a fear card.')
        takeFearButton(getObjectFromGUID(deckZones.fear), playerColor)
        wait(0.3)
      else
        broadcastToAll(getPlayerName(playerColor) .. " does not get a fear card due to an active Miner's Helmet.")
      end
    elseif reward == 'd' then -- draw a card automatically for the player
      local card = drawCard(getDeckZoneGuid(playerColor))
      if card ~= nil then
        card.deal(1, playerColor)
        wait(0.3)
      end
    end
    wait(0.16)
  end
  if deliveredResources then
    local message = getPlayerName(playerColor) .. ' gets '
    local textList = {}
    for code, count in pairs(resourceCount) do
      local label = resourceLabels[code]
      if count > 1 then
        if code == 's' then
          label = 'compasses'
        else
          label = label .. 's'
        end
      end
      table.insert(textList, count .. ' ' .. label)
    end
    broadcastToAll(message .. listToText(textList) .. '.')
  end
  return deliveredAll
end

function discoverButton(zone, clickColor, alt)
  for _, object in ipairs(zone.getObjects()) do
    if object.hasTag('idol') then
      broadcastToColor('One or more idols are still at this location.', clickColor)
      return
    end
  end

  local level = tonumber(zone.getName())
  local siteNum = tonumber(zone.getDescription())
  local foundPawn = false
  for _, object in ipairs(getObjectFromGUID(siteLevels[level][siteNum].pawnSpaces[1]).getObjects()) do
    if object.hasTag('pawn') and object.getDescription() == clickColor then foundPawn = true end
  end
  if not foundPawn then
    broadcastToColor('Your archaeologist not found at this location.', clickColor)
    return
  end

  local guardianDeckZone = getObjectFromGUID(deckZones.guardians)
  local siteDeckZone = nil
  if level == 1 then
    siteDeckZone = getObjectFromGUID(deckZones.sites2)
  else
    siteDeckZone = getObjectFromGUID(deckZones.sites1)
  end

  if not drawCard(siteDeckZone, nil, nil, true) then
    broadcastToColor('Site cards not found.', clickColor)
    return
  end
  if not alt and not drawCard(guardianDeckZone, nil, nil, true) then
    broadcastToColor('Guardian cards not found.', clickColor)
    return
  end
  discovering = true
  zone.removeButton(1)
  zone.removeButton(0)

  function discoverCoroutine()
    local zonePos = zone.getPosition()
    local siteOffsetZ = 1.77
    local guardianOffsetZ = 2.53
    if level == 1 then
      siteOffsetZ = 2.1
      guardianOffsetZ = 2.6
    end
    local site = drawCard(siteDeckZone)
    site.interactable = false
    site.setRotation(faceup)
    site.setPositionSmooth({ zonePos[1], tileY, zonePos[3] + siteOffsetZ }, false, true)
    wait(0.5)
    site.lock()
    site.interactable = true

    if not alt then
      local guardian = drawCard(guardianDeckZone)
      guardian.setRotation(faceup)
      guardian.setPositionSmooth({ zonePos[1], 1.63, zonePos[3] + guardianOffsetZ }, false, true)
    end
    siteLevels[level][siteNum].discovered = true

    if not (options.solo and clickColor == 'Red') then
      if not alt then wait(0.5) end
      deliverRewards(clickColor, site)
    end
    discovering = false
    return 1
  end

  startLuaCoroutine(Global, 'discoverCoroutine')
end

function setupButtonRivalTurn()
  local buttonZone = getObjectFromGUID(playerVars.Red.playAreaZoneGuid)
  local scale = buttonZone.getScale()
  if buttonZone.getButtons() == nil or #buttonZone.getButtons() == 0 then
    local params = {
      function_owner = self,
      label = buttonLabelsRival.ready,
      click_function = 'rivalTurnButton',
      scale = { 2 / scale[1], 1 / scale[2], 2 / scale[3] },
      position = { 15.5 / scale[1], -0.44, 3.65 / scale[3] },
      width = 1800,
      height = 500,
      font_size = 250
    }
    buttonZone.createButton(params)
  else
    buttonZone.editButton({ index = 0, label = buttonLabelsRival.ready })
  end
end

---------------------- ROUNDS

function guardianFearCoroutine()
  local warmask = nil
  for _, playerColor in ipairs(seatedPlayerColors) do
    if not (options.solo and playerColor == 'Red') then
      for _, object in ipairs(getObjectFromGUID(playerVars[playerColor].playAreaZoneGuid).getObjects()) do
        if object.getName() == 'War Mask' then
          warmask = ''
          if not object.is_face_down then warmask = playerColor end
          break
        end
      end
      if warmask ~= nil then break end
    end
  end

  for _, siteLevel in ipairs(siteLevels) do
    for _, siteInfo in ipairs(siteLevel) do
      local playerColors = {}
      for _, guid in ipairs(siteInfo.pawnSpaces) do
        for _, object in ipairs(getObjectFromGUID(guid).getObjects()) do
          if object.hasTag('pawn') and warmask ~= object.getDescription() and not (options.solo and object.getDescription() == 'Red') then
            table.insert(playerColors, object.getDescription())
          end
        end
      end
      if #playerColors > 0 then
        local hasGuardian = false
        for _, object in ipairs(getObjectFromGUID(siteInfo.guid).getObjects()) do
          if object.hasTag('guardian') then hasGuardian = true end
          if object.type == 'Deck' then
            for _, card in ipairs(object.getObjects()) do
              if #card.tags > 0 and card.tags[1] == 'guardian' then
                hasGuardian = true
                break
              end
            end
          end
          if hasGuardian then break end
        end
        if hasGuardian then
          for _, playerColor in ipairs(playerColors) do
            broadcastToAll(getPlayerName(playerColor) .. ' gets Fear.')
            takeFearButton(getObjectFromGUID(deckZones.fear), playerColor)
            wait(0.5)
          end
        end
      end
    end
  end

  if options.researchTrack == 4 then
    local hasGuardian = false
    local guardianZone = getObjectFromGUID(researchTracks[4].guardianZone)
    for _, object in ipairs(guardianZone.getObjects()) do
      if object.hasTag('guardian') then
        if not object.is_face_down then hasGuardian = true end
        break
      end
    end
    if hasGuardian then
      for _, playerColor in ipairs(seatedPlayerColors) do
        if not (options.solo and playerColor == 'Red') and warmask ~= playerColor then
          for _, guid in pairs(playerVars[playerColor].researchTokens) do
            local token = getObjectFromGUID(guid)
            if token ~= nil then
              local posZ = token.getPosition()[3]
              if posZ < researchTracks[4].rows[4].z and posZ > researchTracks[4].rows[5].z then
                broadcastToAll(getPlayerName(playerColor) .. ' gets Fear from the temple guardian.')
                takeFearButton(getObjectFromGUID(deckZones.fear), playerColor)
                wait(0.5)
              end
            end
          end
        end
      end
    end
  end
  return 1
end

-- helper function to detect if a player has a faceup miners helmet in his play area
function hasMinersHelmetActive(playerColor)
  for _, object in ipairs(getObjectFromGUID(playerVars[playerColor].playAreaZoneGuid).getObjects()) do
    if object.getName() == "Miner's Helmet" then
      if not object.is_face_down then
        return true
      else
        return false
      end
    end
  end
  return false
end

function getStaff()
  local staffList = getObjectsWithTag("staff")
  if #staffList == 0 then
    broadcastToAll("Staff not found.")
    return nil
  else
    if #staffList > 1 then
      broadcastToAll("Multiple staffs found!")
    end
    return staffList[1]
  end
end

function nextRoundButton(obj, clickColor, alt)
  if not isSeated(clickColor) and clickColor ~= 'Black' or movingRow or setupInProgress or UI.getAttribute('soloMenu', 'active') == 'true' then return end
  if options.solo then
    local button = getObjectFromGUID(playerVars.Red.playAreaZoneGuid).getButtons()[1]
    if button.label == buttonLabelsRival.busy then return end
  end
  function nextRoundCoroutine()
    setupInProgress = true
    refillRowCoroutine()
    guardianFearCoroutine()

    -- lift decks, reset tents
    local playerDeckZones = {}
    local decks = {}
    for _, playerColor in ipairs(seatedPlayerColors) do
      if not (options.solo and playerColor == 'Red') then
        local vars = playerVars[playerColor]
        local deckZone = getObjectFromGUID(getDeckZoneGuid(playerColor))
        local toPos = deckZone.getPosition()
        playerDeckZones[playerColor] = deckZone
        for _, object in ipairs(deckZone.getObjects()) do
          if object.type == 'Card' or object.type == 'Deck' then
            decks[playerColor] = object
            object.setPosition({ toPos[1], tileY + 0.6, toPos[3] })
            object.lock()
            break
          end
        end

        local tent = getObjectFromGUID(vars.tentGuid)
        if tent.is_face_down then tent.flip() end
      end
    end
    wait(0.6)

    -- return pawns and tokens
    for _, playerColor in ipairs(seatedPlayerColors) do
      local vars = playerVars[playerColor]
      local pawns = vars.pawns
      local pawnPositions = vars.pawnPositions
      if options.solo and playerColor == 'Red' then
        pawns = solo.pawns
        pawnPositions = solo.pawnPositions
      end
      for i, guid in ipairs(pawns) do
        local pawn = getObjectFromGUID(guid)
        if pawn ~= nil then
          pawn.setRotationSmooth(faceup, false, true)
          pawn.setPositionSmooth(pawnPositions[i], false, false)
        end
      end
      if options.playerBoards[playerColor] == 5 then
        for i, guid in ipairs(tokens.food) do
          if i < 3 or round > 1 then
            local food = getObjectFromGUID(guid)
            if food ~= nil then
              food.setRotationSmooth(faceup, false, true)
              food.setPositionSmooth(vars.foodPositions[i], false, false)
            end
          end
        end
      end
    end
    wait(0.5)

    function goesInDeck(object)
      if object == nil then return false end
      local excludeTags = { 'assistant', 'idol', 'site1', 'site2', 'guardian' }

      local cardTags = nil
      if object.type == 'Card' then
        cardTags = object.getTags()
      else
        cardTags = object.tags
      end

      if #cardTags == 0 then return true end
      for _, tag in ipairs(excludeTags) do
        if tostring(cardTags[1]) == tag then return false end
      end
      return true
    end

    for _, playerColor in ipairs(seatedPlayerColors) do
      if not (options.solo and playerColor == 'Red') then
        local toPos = playerDeckZones[playerColor].getPosition()
        for _, object in ipairs(getObjectFromGUID(playerVars[playerColor].playAreaZoneGuid).getObjects()) do
          if object.type == 'Card' then
            if goesInDeck(object) then
              object.setRotation(facedown)
              object.setPositionSmooth({ toPos[1], tileY, toPos[3] }, false, true)
            end
          elseif object.type == 'Deck' then
            -- check deck contents in case assistants/idols/sites/guardians were grouped
            local guidsToMove = {}
            for _, card in ipairs(object.getObjects()) do
              if goesInDeck(card) then table.insert(guidsToMove, card.guid) end
            end

            -- ttsbug(?): if object disappears inside this for-loop, object becomes a non-nil reference that doesn't have an instance
            -- so get the deck/object each time a card needs to be removed from it
            local deckGuid = object.getGUID()
            for _, guid in ipairs(guidsToMove) do
              local deck = getObjectFromGUID(deckGuid)
              local cardToMove = nil
              if deck == nil then
                cardToMove = getObjectFromGUID(guid)
              else
                cardToMove = deck.takeObject({ guid = guid })
              end
              wait(0.01)
              cardToMove.setScale({ 2.3, 1, 2.3 })
              cardToMove.setRotation(facedown)
              cardToMove.setPositionSmooth({ toPos[1], tileY, toPos[3] }, false, true)
            end
          end
        end
      end
    end
    if options.solo then
      local toPos = solo.deckPositions[1]
      for _, object in ipairs(getObjectFromGUID(solo.zones.discard).getObjects()) do
        if object.type == 'Card' or object.type == 'Deck' then
          object.setRotation(facedown)
          object.setPositionSmooth({ toPos[1], tileY + 0.2, toPos[3] }, false, true)
        end
      end

      if options.objectives > 0 then
        toPos = solo.objectivePosition
        for _, guid in ipairs(solo.zones.objectives) do
          for _, object in ipairs(getObjectFromGUID(guid).getObjects()) do
            if object.type == 'Card' or object.type == 'Deck' then
              object.setRotation(facedown)
              object.setPositionSmooth(toPos, false, true)
            end
          end
        end
      end
    end
    wait(0.4)

    -- get income
    for _, playerColor in ipairs(seatedPlayerColors) do
      if options.playerBoards[playerColor] == 2 then
        local falcon = getObjectFromGUID(tokens.falcon)
        local falconPosIndex = nil
        local falconPositions = playerVars[playerColor].falconPositions
        if falcon ~= nil then
          for i, pos in ipairs(falconPositions) do
            if comparePosition(pos, falcon.getPosition()) then
              falconPosIndex = i
              break
            end
          end
        end
        if falconPosIndex == nil then
          broadcastToAll('Unable to locate falcon.', playerColor)
          wait(0.5)
        elseif falconPosIndex < 5 then
          broadcastToAll(getPlayerName(playerColor) .. ' moves their falcon.')
          falcon.setRotationSmooth(falconRotations[falconPosIndex + 1], false, true)
          falcon.setPositionSmooth(falconPositions[falconPosIndex + 1], false, true)
          wait(0.5)
        end
      elseif options.playerBoards[playerColor] == 3 then
        broadcastToAll(getPlayerName(playerColor) .. ' gets income of 1 coin.')
        takeResourceButton('c', playerColor)
        wait(0.5)
      elseif options.playerBoards[playerColor] == 4 then
        local resource = 's'
        local resourceLabel = 'compass'
        if round == 2 or round == 4 then
          resource = 't'
          resourceLabel = 'tablet'
        end
        broadcastToAll(getPlayerName(playerColor) .. ' adds 1 ' .. resourceLabel .. ' to their suitcase.')
        takeResourceButton(resource, playerColor, true)
        wait(0.5)
      end
    end

    -- shuffle
    for playerColor, deckZone in pairs(playerDeckZones) do
      if decks[playerColor] ~= nil then
        for _, object in ipairs(deckZone.getObjects()) do
          if object.type == 'Deck' and object.getGUID() ~= decks[playerColor].guid then
            object.shuffle()
            break
          end
        end
      end
    end
    if options.solo then
      for _, object in ipairs(getObjectFromGUID(solo.zones.deck).getObjects()) do
        if object.type == 'Deck' then
          object.shuffle()
          break
        end
      end
      if options.objectives > 0 then
        for _, object in ipairs(getObjectFromGUID(solo.zones.objectivesDeck).getObjects()) do
          if object.type == 'Deck' then
            object.shuffle()
            break
          end
        end
      end
    end
    wait(0.2)
    for _, deck in pairs(decks) do
      deck.unlock()
    end

    -- refresh assistants
    for _, playerColor in ipairs(seatedPlayerColors) do
      if not (options.solo and playerColor == 'Red') then
        local vars = playerVars[playerColor]
        local assistantZoneGuid = vars.allZoneGuid
        if options.playerBoards[playerColor] == 6 and vars.assistantZoneGuid ~= nil then
          assistantZoneGuid = vars.assistantZoneGuid
        end
        for _, object in ipairs(getObjectFromGUID(assistantZoneGuid).getObjects()) do
          if object.hasTag('assistant') then
            local rotation = object.getRotation()
            object.setRotationSmooth({ 0, 180, rotation[3] }, false, false)
          end
        end
      end
    end

    -- card row
    local rowStart = round - options.staff + 1
    if rowStart < 1 then rowStart = 1 end
    local rowEnd = round + options.staff
    if rowEnd > 6 then rowEnd = 6 end
    for i = rowStart, rowEnd do
      local waitUntilAfterSetPos = exile(drawCard(cardRowZoneGuids[i]))
      if waitUntilAfterSetPos then wait(0.16) end
      wait(0.16)
    end
    wait(0.4)
    round = round + 1

    -- move staff
    local staff = getStaff()
    if staff then
      staff.setPositionSmooth(staffPositions[round], false, true)
    end

    wait(0.5)
    refillRowCoroutine()

    -- starting player
    firstPlayerColor = nil
    if not (options.solo and #seatedPlayerColors == 2) then
      startPlayerIndex = startPlayerIndex + 1
      if startPlayerIndex > #seatedPlayerColors then startPlayerIndex = 1 end
      firstPlayerColor = seatedPlayerColors[startPlayerIndex]
      local token = getObjectFromGUID(tokens.firstPlayer)
      if token ~= nil then token.setPositionSmooth(playerVars[firstPlayerColor].firstPlayerPosition, false, false) end
    end
    wait(0.4)

    -- draw
    for playerColor, zone in pairs(playerDeckZones) do
      if not (options.solo and playerColor == 'Red') then
        local handSize = 5
        local drawn = #Player[playerColor].getHandObjects()
        if options.playerBoards[playerColor] == 3 then
          local card = getObjectFromGUID(cards.baroness)
          if card == nil then
            for _, object in ipairs(zone.getObjects()) do
              if object.type == 'Deck' then
                card = object.takeObject({ guid = cards.baroness })
                break
              end
            end
          end
          if card == nil then
            for _, object in ipairs(getObjectFromGUID(exileZoneGuids.other).getObjects()) do
              if object.type == 'Deck' then
                card = object.takeObject({ guid = cards.baroness })
                break
              end
            end
          end
          if card ~= nil then
            card.deal(1, playerColor)
            drawn = drawn + 1
            wait(0.01)
          end
        end
        for _, object in ipairs(zone.getObjects()) do
          if drawn >= handSize then break end
          if object.type == 'Card' then
            object.deal(1, playerColor)
            drawn = drawn + 1
          elseif object.type == 'Deck' then
            local numberToDraw = handSize - drawn
            if object.getQuantity() >= numberToDraw then
              drawn = drawn + numberToDraw
            else
              drawn = drawn + object.getQuantity()
            end
            object.deal(numberToDraw, playerColor)
          end
        end
        if options.playerBoards[playerColor] == 6 and drawn < 6 then
          local card = drawCard(deckZones.fear)
          if card == nil then
            broadcastToAll('No Fear cards left for ' .. getPlayerName(playerColor) .. ' to draw.')
          else
            broadcastToAll(getPlayerName(playerColor) .. ' draws a Fear card.')
            card.deal(1, playerColor)
          end
          wait(0.5)
        end
      end
    end

    broadcastToAll('Starting Round ' .. round)
    if not (options.solo and #seatedPlayerColors == 2) then Turns.turn_color = firstPlayerColor end

    local buttonZone = getObjectFromGUID(deckZones.fear)
    if round == 5 then
      buttonZone.editButton({ index = 0, label = buttonLabels.ready1, click_function = 'calculateScoresButton' })
    else
      buttonZone.editButton({ index = 0, label = 'Setup Round ' .. round + 1 })
    end
    setupInProgress = false

    if options.solo then
      soloStatus.firstTurn = true
      soloStatus.fulfilledObjectives = {}
      soloStatus.pawnsOut = 0
      if #seatedPlayerColors == 2 then rivalTurnCoroutine() end
    end
    return 1
  end

  startLuaCoroutine(Global, 'nextRoundCoroutine')
end

---------------------- SCORING

function calculateScoresButton(buttonZone, clickColor, alt)
  if not doneLoading or not isSeated(clickColor) and clickColor ~= 'Black' then return end
  local button = buttonZone.getButtons()[1]
  if button.label == buttonLabels.ready1 or button.label == buttonLabels.ready2 then
    broadcastToAll('Are you sure you want to calculate scores?')
    Wait.time(function() buttonZone.editButton({ index = 0, label = buttonLabels.confirm }) end, 0.2)
    resetScoringButton(buttonZone, buttonLabels.confirm, button.label)
  elseif button.label == buttonLabels.confirm then
    buttonZone.editButton({ index = 0, label = buttonLabels.busy })
    printToAll(getPlayerName(clickColor) .. ' calculated scores.')
    calculateScores()
    resetScoringButton(buttonZone)
  end
end

function resetScoringButton(buttonZone, conditionalLabel, resetLabel)
  function resetScoringButtonCoroutine()
    if conditionalLabel ~= nil then
      wait(4)
      local button = buttonZone.getButtons()[1]
      if button.label == buttonLabels.confirm then
        buttonZone.editButton({ index = 0, label = resetLabel })
      end
    else
      wait(4)
      buttonZone.editButton({ index = 0, label = buttonLabels.ready2 })
    end
    return 1
  end

  startLuaCoroutine(Global, 'resetScoringButtonCoroutine')
end

function calculateScores()
  function calculateScoresCoroutine()
    guardianFearCoroutine()
    local winners = {}
    local top = { score = 0, templeOrder = 9, research = 0 }
    local tiebreaker = false
    for _, playerColor in ipairs(seatedPlayerColors) do
      local vars = playerVars[playerColor]
      local subscores = { research = 0, temple = 0, idol = 0, guardian = 0, cards = 0, fear = 0 }
      local templeOrder = 9

      -- score the position in the temple
      for i, guid in ipairs(templeSpaceZoneGuids) do
        for _, object in ipairs(getObjectFromGUID(guid).getObjects()) do
          if string.find(object.getName(), 'Magnifying') ~= nil then
            if object.getDescription() == playerColor then
              subscores.research = subscores.research + researchTracks[options.researchTrack].templePoints[i]
              templeOrder = i
            end
            break
          end
        end
      end

      -- score the research position of the magnifying glass / journal
      for name, guid in pairs(vars.researchTokens) do
        local token = getObjectFromGUID(guid)
        if token ~= nil then
          local posZ = token.getPosition()[3]
          for i, row in ipairs(researchTracks[options.researchTrack].rows) do
            if posZ >= row.z then
              if i > 1 then subscores.research = subscores.research + row[name] end
              break
            end
          end
        end
      end

      -- score uncovered idol spaces
      if not (options.solo and playerColor == 'Red') then
        subscores.idol = subscores.idol + scoreUncoveredIdolSlots(playerColor)
      end

      -- helper functions
      local excludeGuids = {}
      if options.playerBoards[playerColor] == 6 and vars.deckZoneGuids.ritual ~= nil then
        for _, object in ipairs(getObjectFromGUID(vars.deckZoneGuids.ritual).getObjects()) do
          if object.type == 'Deck' or object.getName() == 'Fear' then table.insert(excludeGuids, object.getGUID()) end
        end
      end
      function isExcluded(object)
        for _, guid in ipairs(excludeGuids) do
          if object.getGUID() == guid then return true end
        end
        return false
      end

      function getVpValue(notes)
        local md = JSON.decode(notes) or {}
        return md.points or 0
      end

      function scoreObject(object, scoreIdols)
        if (object.type == 'Deck' or object.getName() == 'Fear') and isExcluded(object) then return end
        if object.type == 'Deck' then
          -- cards in decks
          for _, cardData in ipairs(object.getData().ContainedObjects) do
            if cardData.Tags and cardData.Tags[1] == 'idol' then
              if scoreIdols then subscores.idol = subscores.idol + 3 end
            elseif cardData.Tags and cardData.Tags[1] == 'guardian' then
              subscores.guardian = subscores.guardian + 5
            else
              -- regular cards
              local score = getVpValue(cardData.GMNotes)
              if score < 0 then
                subscores.fear = subscores.fear + score
              else
                subscores.cards = subscores.cards + score
              end
            end
          end
        elseif object.hasTag('temple') then
          subscores.temple = subscores.temple + object.getDescription()
        elseif object.hasTag('idol') then
          if scoreIdols then subscores.idol = subscores.idol + 3 end
        elseif object.hasTag('guardian') then
          subscores.guardian = subscores.guardian + 5
        elseif object.type == 'Custom_Token' and object.getName() == 'Fear' then
          subscores.fear = subscores.fear - 2
        elseif object.type == "Card" then
          -- regular cards
          local score = getVpValue(object.getGMNotes())
          if score < 0 then
            subscores.fear = subscores.fear + score
          else
            subscores.cards = subscores.cards + score
          end
        end
      end

      -- score all other objects
      local scoreIdols = true
      if options.solo and playerColor == 'Red' then scoreIdols = false end

      -- make list of objects to score
      local scoreTheseObjects = {}

      -- get all objects in play zone
      for _, object in ipairs(getObjectFromGUID(vars.allZoneGuid).getObjects()) do
        table.insert(scoreTheseObjects, object)
      end

      -- get objects from hand
      for _, object in ipairs(Player[playerColor].getHandObjects()) do
        table.insert(scoreTheseObjects, object)
      end

      -- additionally, get the deck for left sitting mechanic / journalist
      if (playerColor == "Red" or playerColor == "Yellow") and
          (options.playerBoards[playerColor] == 7 or options.playerBoards[playerColor] == 8) then
        local deckZoneGUID = playerVars[playerColor].deckZoneGuids.journo_Mech
        local deckZone = getObjectFromGUID(deckZoneGUID)
        for _, object in ipairs(deckZone.getObjects()) do
          if object.type == 'Card' or object.type == 'Deck' then
            table.insert(scoreTheseObjects, object)
          end
        end
      end

      -- additionally, get the idols for right sitting journalist
      if (playerColor == "Green" or playerColor == "Blue") and options.playerBoards[playerColor] == 7 then
        local board = getPlayerBoard(playerColor)
        local idolData = idolSlotData[options.playerBoards[playerColor]]
        
        for _, data in ipairs(idolData) do
          -- get all objects in this spot
          local searchResult = Physics.cast({
            origin       = board.positionToWorld(data.localPos):setAt("y", 2),
            direction    = { 0, -1, 0 },
            orientation  = { 0, 0, 0 },
            type         = 3,
            size         = { 0.1, 2, 0.1 },
            max_distance = 2
          })

          for _, hit in ipairs(searchResult) do
            if hit.hit_object.hasTag("idol") then
              table.insert(scoreTheseObjects, hit.hit_object)
            end
          end
        end
      end

      -- perform the scoring
      for _, object in ipairs(scoreTheseObjects) do
        scoreObject(object, scoreIdols)
      end

      -- score idols for solo rival
      if options.solo and playerColor == 'Red' then
        -- check for purple site action
        local baseIdolPoints = 2
        function findPurpleSiteActionCard(zone)
          for _, object in ipairs(zone.getObjects()) do
            if object.type == 'Card' then
              if object.getDescription() == 'site' and object.getGMNotes() == 'purple' then return true end
            elseif object.type == 'Deck' then
              for _, card in ipairs(object.getObjects()) do
                if card.description == 'site' and card.gm_notes == 'purple' then return true end
              end
            end
          end
          return false
        end

        if findPurpleSiteActionCard(getObjectFromGUID(solo.zones.discard)) or findPurpleSiteActionCard(getObjectFromGUID(solo.zones.deck)) then
          baseIdolPoints = 3
        end

        function countIdols(zone)
          local count = 0
          for _, object in ipairs(zone.getObjects()) do
            if object.type == 'Card' then
              if object.hasTag('idol') then count = count + 1 end
            elseif object.type == 'Deck' then
              for _, card in ipairs(object.getObjects()) do
                if #card.tags > 0 and card.tags[1] == 'idol' then count = count + 1 end
              end
            end
          end
          return count
        end

        local all = countIdols(getObjectFromGUID(vars.allZoneGuid))
        local dupes = countIdols(getObjectFromGUID(solo.zones.idol.dupe))
        subscores.idol = all * baseIdolPoints + (all - dupes)
      end

      local total = 0
      for category, subscore in pairs(subscores) do
        total = total + subscore
        UI.setValue(category .. playerColor, tostring(subscore))
      end
      UI.setValue('total' .. playerColor, total)
      UI.setValue('name' .. playerColor, getPlayerName(playerColor, true))

      if total > top.score then
        tiebreaker = false
        top = { score = total, templeOrder = templeOrder, research = subscores.research }
        winners = { playerColor }
      elseif total == top.score then
        tiebreaker = true
        if templeOrder < top.templeOrder then
          top = { score = total, templeOrder = templeOrder, research = subscores.research }
          winners = { playerColor }
        elseif templeOrder == top.templeOrder then
          if subscores.research > top.research then
            top = { score = total, templeOrder = templeOrder, research = subscores.research }
            winners = { playerColor }
          elseif subscores.research == top.research then
            table.insert(winners, playerColor)
          end
        end
      end
    end

    UI.setAttribute('scoreboard', 'active', true)
    for i, playerColor in ipairs(seatedPlayerColors) do
      UI.setAttribute('scoreboard' .. playerColor, 'offsetXY', 210 + (i - 1) * 70 .. ' -140')
      UI.setAttribute('scoreboard' .. playerColor, 'active', true)
    end

    if #winners == 1 then
      if tiebreaker then
        broadcastToAll(getPlayerName(winners[1]) .. ' wins by tiebreaker!')
      else
        broadcastToAll(getPlayerName(winners[1]) .. ' wins!')
      end
    elseif #winners > 1 then
      broadcastToAll(listToText(winners, true) .. ' are tied!')
    end

    local buttonZone = getObjectFromGUID(deckZones.fear)
    if #buttonZone.getButtons() < 3 then
      local params = {
        function_owner = self,
        label = 'Toggle Scoreboard',
        click_function = 'toggleScoreboardButton',
        position = { 8.23, 0, -4.25 },
        width = 2400,
        height = 500,
        font_size = 250
      }
      buttonZone.createButton(params)
    end
    return 1
  end

  startLuaCoroutine(Global, 'calculateScoresCoroutine')
end

-- score empty idol slots
function scoreUncoveredIdolSlots(playerColor)
  local idolSlotPoints = 0
  local board = getPlayerBoard(playerColor)
  local idolData = idolSlotData[options.playerBoards[playerColor]]

  for _, data in ipairs(idolData) do
    -- get all objects in this spot
    local searchResult = Physics.cast({
      origin       = board.positionToWorld(data.localPos):setAt("y", 2),
      direction    = { 0, -1, 0 },
      orientation  = { 0, 0, 0 },
      type         = 3,
      size         = { 0.1, 2, 0.1 },
      max_distance = 2
    })

    -- check if occupied by idol or deck of idols
    local empty = true
    for _, hit in ipairs(searchResult) do
      local obj = hit.hit_object
      if obj.hasTag("idol") then
        empty = false
        break
      end
    end

    -- give points if empty
    if empty then
      idolSlotPoints = idolSlotPoints + data.points
    end
  end
  return idolSlotPoints
end

function toggleScoreboardButton(obj, clickColor, alt)
  if setupInProgress or not isSeated(clickColor) and clickColor ~= 'Black' then return end
  if UI.getAttribute('scoreboard', 'active') == 'true' or UI.getAttribute('scoreboard', 'active') == 'True' then
    UI.setAttribute('scoreboard', 'active', false)
    for playerColor, _ in pairs(playerVars) do
      UI.setAttribute('scoreboard' .. playerColor, 'active', false)
    end
  else
    UI.setAttribute('scoreboard', 'active', true)
    for _, playerColor in ipairs(seatedPlayerColors) do
      UI.setAttribute('scoreboard' .. playerColor, 'active', true)
    end
  end
end

---------------------- EVENTS

function onPlayerChangeColor(playerColor)
  if playerColor == 'Grey' then return end
  Wait.time(function()
    Player[playerColor].lookAt({ position = { 0, 0, -7 }, pitch = 75, yaw = 0, distance = 66 })
  end, 0.01)
end

function onPlayerTurn(player, previousPlayer)
  -- tts bug: when rewinding time or saving a script, onPlayerTurn triggers with non-nil player that has '' color
  if not doneLoading or setupInProgress or round < 1 or player == nil or player.color == '' then return end
  turn = player.color
  Wait.time(function()
    local currentPlayerTent = nil
    local atLeastOneFaceupTent = false
    for _, playerColor in ipairs(seatedPlayerColors) do
      local tent = getObjectFromGUID(playerVars[playerColor].tentGuid)
      if tent ~= nil then
        if playerColor == player.color then currentPlayerTent = tent end
        if not tent.is_face_down then atLeastOneFaceupTent = true end
      end
    end
    if atLeastOneFaceupTent and currentPlayerTent ~= nil and currentPlayerTent.is_face_down then
      Turns.turn_color = Turns.getNextTurnColor()
    end
  end, 0.01)
end

function onObjectEnterContainer(container, enteringObject)
  editResourceBagCounter(container)
end

function onObjectLeaveContainer(container, leavingObject)
  addExileMenu(leavingObject)
  addGetRewardsMenu(leavingObject)
  addReturnMenu(leavingObject)
  addTrashMenu(leavingObject)
  editResourceBagCounter(container)
end

function editResourceBagCounter(container)
  if round > 0 and container.hasTag('resource') and container.type == 'Bag' then -- stacks count as containers, so need to specify bags
    local playerColor = container.getDescription()
    local resource = container.getGMNotes()
    local buttonZone = nil
    if container.getName() == 'suitcase' then
      buttonZone = getObjectFromGUID(playerVars[playerColor].suitcaseResourceBagZones[resource])
    else
      buttonZone = getObjectFromGUID(playerVars[playerColor].resourceBagZones[resource])
    end
    buttonZone.editButton({ index = 0, label = container.getQuantity() })
  end
end

function filterObjectEnterContainer(container, object)
  if container.hasTag('resource') then
    if object.getGMNotes() ~= container.getGMNotes() then return false end
  end
  return true
end

---------------------- CONTEXT MENU

function addExileMenu(object)
  if object.type == 'Tile' and object.getName() == 'Fear' or object.type == 'Card' and (#object.getTags() == 0 or object.hasTag('artifact') or object.hasTag('item')) then
    object.addContextMenuItem('Exile', function() exile(object) end)
  end
end

function addGetRewardsMenu(object)
  if object.type == 'Card' and (object.hasTag('site1') or object.hasTag('site2')) then
    object.addContextMenuItem('Get Rewards', function(playerColor) deliverRewards(playerColor, object) end)
  end
end

function addReturnMenu(object)
  if object.type == 'Card' and (object.hasTag('site1') or object.hasTag('site2') or object.hasTag('guardian')) then
    object.addContextMenuItem('Deck Bottom', function() returnToBottom(object) end)
  end
end

function addAssistantCycleMenu()
  for _, guid in ipairs(assistantZones) do
    for _, object in ipairs(getObjectFromGUID(guid).getObjects()) do
      if object.type == 'Deck' and object.hasTag('assistant') then
        object.addContextMenuItem('Cycle to Bottom', function() cycleAssistant(object) end)
        break
      end
    end
  end
end

function addTrashMenu(object)
  if object.hasTag('research') and object.getDescription() == '' then
    object.addContextMenuItem('Trash', function(playerColor) trash(playerColor, object) end)
  end
end

function exile(object)
  if object == nil then return end
  if object.type == 'Tile' then
    object.destruct()
  elseif object.type == "Card" then
    -- tts bug: setPositionSmooth pulls other cards that are moved when setPositionSmooth ends, so end with setPosition which has smaller window for this bug to occur
    object.use_hands = false
    local md = getMetaData(object)
    local toZone = nil
    if md.type == "Fear" then
      toZone = getObjectFromGUID(deckZones.fear)
    elseif md.type == "Artifact" then
      toZone = getObjectFromGUID(exileZoneGuids.artifacts)
    elseif md.type == "Item" then
      toZone = getObjectFromGUID(exileZoneGuids.items)
    else
      toZone = getObjectFromGUID(exileZoneGuids.other)
    end
    local toPos = toZone.getPosition()

    local deck = nil
    for _, obj in ipairs(toZone.getObjects()) do
      if obj.type == 'Card' or obj.type == 'Deck' then
        deck = obj
        break
      end
    end
    object.setRotationSmooth(toZone.getRotation(), false, true)
    object.setPositionSmooth(toPos + Vector(0, 0.6, 0), false, true)
    Wait.time(function()
      object.use_hands = true
      if deck == nil then
        object.setPosition(toPos)
      else
        deck.putObject(object)
      end
    end, 0.3)
    -- there needs to be a small delay before moving another card, if this exile ended with anything other than putObject to a deck
    return true
  end
end

function returnToBottom(object)
  function returnToBottomCoroutine()
    local zoneGuid = deckZones.guardians
    if object.hasTag('site1') then
      zoneGuid = deckZones.sites1
    elseif object.hasTag('site2') then
      zoneGuid = deckZones.sites2
    end
    local zone = getObjectFromGUID(zoneGuid)
    local toPos = zone.getPosition():setAt("y", tileY)
    local deck = nil
    for _, obj in ipairs(zone.getObjects()) do
      if obj.type == 'Card' or obj.type == 'Deck' then
        deck = obj
        obj.setPositionSmooth(toPos + Vector(0, 0.5, 0), false, true)
      end
    end
    wait(0.2)
    if deck ~= nil then deck.lock() end
    object.unlock()
    object.setRotation(facedown)
    object.setPositionSmooth(toPos, false, true)
    wait(0.3)
    if deck == nil then
      object.setPosition(toPos)
    else
      deck.unlock()
      deck.putObject(object)
    end
    return 1
  end

  startLuaCoroutine(Global, 'returnToBottomCoroutine')
end

function cycleAssistant(object)
  object.takeObject({ position = object.getPosition():setAt("y", tileY), rotation = object.getRotation() })
end

function trash(playerColor, object)
  if isSeated(playerColor) then
    getObjectFromGUID(playerVars[playerColor].trashGuid).putObject(object)
  end
end

---------------------- SOLO RIVAL

function rivalBuy(action, buyHighestPoints)
  local startIndex = 1
  local endIndex = round
  if action == 'item' then
    startIndex = round + 1
    endIndex = 6
  end

  local highest = 0
  local highestCards = {}
  local lowest = 5
  local lowestCards = {}
  for i = startIndex, endIndex do
    local card = drawCard(cardRowZoneGuids[i], nil, nil, true)
    if card.type == 'Card' then
      --local points = card.getVar('points')
      local points = JSON.decode(card.getGMNotes()).points
      if points > highest then
        highest = points
        highestCards = { card }
      elseif points == highest then
        table.insert(highestCards, card)
      end
      if points < lowest then
        lowest = points
        lowestCards = { card }
      elseif points == lowest then
        table.insert(lowestCards, card)
      end
    end
  end
  if buyHighestPoints then
    broadcastToAll('Rival buys an ' .. action .. ' with highest point value.')
    highestCards[math.random(1, #highestCards)].setPositionSmooth(solo.acquiredStuffPositions.buy, false, false)
  else
    broadcastToAll('Rival buys an ' .. action .. ' with lowest point value.')
    lowestCards[math.random(1, #lowestCards)].setPositionSmooth(solo.acquiredStuffPositions.buy, false, false)
  end
end

function rivalCheckSiteForResource(siteInfo, resource, campsite)
  function rivalCheckSiteForOpenPawnPos(pawnSpaceGuid)
    local pawnZone = getObjectFromGUID(pawnSpaceGuid)
    local zonePos = pawnZone.getPosition()
    for _, object in ipairs(pawnZone.getObjects()) do
      if object.hasTag('pawn') then return nil end
    end
    return { zonePos[1], pawnY, zonePos[3] }
  end

  if campsite then
    if string.find(getObjectFromGUID(siteInfo.guid).getGMNotes(), resource) ~= nil then
      return rivalCheckSiteForOpenPawnPos(siteInfo.pawnSpaces[1])
    end
  else
    if siteInfo.discovered then
      for _, object in ipairs(getObjectFromGUID(siteInfo.guid).getObjects()) do
        if object.hasTag('site1') or object.hasTag('site2') then
          if string.find(object.getGMNotes(), resource) ~= nil then
            return rivalCheckSiteForOpenPawnPos(siteInfo.pawnSpaces[1])
          end
          break
        end
      end
    end
  end
  return nil
end

function rivalMovePawn(toPos)
  local pawnNo = soloStatus.pawnsOut + 1
  local pawn = getObjectFromGUID(solo.pawns[pawnNo])
  if pawn == nil then
    broadcastToAll('Error: unable to locate rival pawn ' .. pawnNo .. '.')
    return false
  end
  pawn.setRotationSmooth(faceup, false, true)
  pawn.setPositionSmooth(toPos, false, false)
  soloStatus.pawnsOut = pawnNo
  return true
end

function rivalTurnCoroutine()
  getObjectFromGUID(playerVars.Red.playAreaZoneGuid).editButton({ index = 0, label = buttonLabelsRival.busy })
  wait(0.2)
  broadcastToAll("Rival's turn.", 'Red')
  wait(0.5)
  local deckPos = solo.deckPositions[2]
  local actionCard = drawCard(solo.zones.deck, faceup, { deckPos[1], tileY + 0.3, deckPos[3] })
  if actionCard == nil or actionCard.getDescription() == nil or actionCard.getDescription() == '' then
    broadcastToAll('Rival has no more action cards.')
    wait(1.2)
    broadcastToAll(getPlayerName(seatedPlayerColors[1], true) .. "'s turn.", seatedPlayerColors[1])
    setupButtonRivalTurn()
    return 1
  end
  wait(0.8)

  local action = actionCard.getDescription()
  local gmNotes = actionCard.getGMNotes()
  if action == 'artifact' or action == 'item' then
    refillRowCoroutine()
    if gmNotes == 'green' then
      rivalBuy(action, false)
    else
      rivalBuy(action, true)
    end
    soloStatus.fulfilledObjectives[action] = true
    if gmNotes == 'purple' then
      wait(1.5)
      local secondAction = 'item'
      if action == 'item' then secondAction = 'artifact' end

      rivalBuy(secondAction, false)
      soloStatus.fulfilledObjectives[secondAction] = true
    end
    wait(1.2)
    refillRowCoroutine()
  elseif action == 'arch' then
    local placedPawn = false
    local resourceText = { t = 'a tablet', a = 'an arrowhead', j = 'a jewel', c = 'a coin', s = 'a compass' }
    for i = 1, 4 do
      local possiblePawnPos = {}
      local campsite = false
      if i == 4 then campsite = true end
      for _, siteInfo in ipairs(siteLevels[i]) do
        local pos = rivalCheckSiteForResource(siteInfo, gmNotes, campsite)
        if pos ~= nil then table.insert(possiblePawnPos, pos) end
      end

      if #possiblePawnPos > 0 then
        broadcastToAll('Rival digs at a site that offers ' .. resourceText[gmNotes] .. '.')
        wait(0.5)
        rivalMovePawn(possiblePawnPos[math.random(1, #possiblePawnPos)])
        if soloStatus.pawnsOut > 2 then soloStatus.fulfilledObjectives.arch = true end
        placedPawn = true
        break
      end
    end
    if not placedPawn then broadcastToAll('No available site that offers ' .. resourceText[gmNotes] .. '.') end
  elseif action == 'site' then
    if gmNotes == 'green' and round == 5 then
      broadcastToAll('Rival does not take this action in round 5.')
    else
      local startIndex = 2
      local endIndex = 3
      local level = 1
      if round > 3 then
        startIndex = 1
        endIndex = 1
        level = 2
      end

      local possibleSiteInfos = {}
      for i = startIndex, endIndex do
        for _, siteInfo in ipairs(siteLevels[i]) do
          if not siteInfo.discovered then
            table.insert(possibleSiteInfos, siteInfo)
          else
            -- sites can become undiscovered so check for site card
            local discovered = false
            for _, object in ipairs(getObjectFromGUID(siteInfo.guid).getObjects()) do
              if object.hasTag('site1') or object.hasTag('site2') then
                discovered = true
                break
              end
            end
            if not discovered then table.insert(possibleSiteInfos, siteInfo) end
          end
        end
      end
      if #possibleSiteInfos > 0 then
        local siteInfo = possibleSiteInfos[math.random(1, #possibleSiteInfos)]
        broadcastToAll('Rival discovers a random level ' .. level .. ' site.')
        wait(0.5)
        local toPos = getObjectFromGUID(siteInfo.pawnSpaces[1]).getPosition()
        local success = rivalMovePawn({ toPos[1], pawnY, toPos[3] })
        if soloStatus.pawnsOut > 2 then soloStatus.fulfilledObjectives.arch = true end

        if success then
          wait(1.2)
          local siteZone = getObjectFromGUID(siteInfo.guid)
          for _, object in ipairs(siteZone.getObjects()) do
            if object.hasTag('idol') then
              local dupeZonePos = getObjectFromGUID(solo.zones.idol.dupe).getPosition()
              local dupePos = { dupeZonePos[1], tileY + 0.4, dupeZonePos[3] }
              if object.is_face_down then
                object.setRotationSmooth({ 0, 90, 180 }, false, true)
                object.setPositionSmooth(dupePos, false, false)
              else
                local idolReward = object.getGMNotes()
                local isDupe = false

                -- look for same type of idol to determine where this goes
                local idolZone = nil
                local idolPos = nil
                idolZone = getObjectFromGUID(solo.zones.idol[idolReward])
                idolPos = idolZone.getPosition()

                for _, obj in ipairs(idolZone.getObjects()) do
                  if obj.hasTag('idol') then
                    isDupe = true
                    break
                  end
                end
                if isDupe then
                  object.setRotationSmooth({ 0, 90, 0 }, false, true)
                  object.setPositionSmooth(dupePos, false, false)
                else
                  object.setRotationSmooth(faceup, false, true)
                  object.setPositionSmooth({ idolPos[1], tileY, idolPos[3] }, false, false)
                end
              end
              wait(0.5)
            end
          end

          local alt = true
          if (gmNotes == 'green' or gmNotes == 'purple') and (round == 1 or round == 3 or round == 5) then
            alt = false
          elseif gmNotes == 'red' and (round == 2 or round == 4) then
            alt = false
          end
          discoverButton(siteZone, 'Red', alt)
          soloStatus.fulfilledObjectives.site = true
          if not alt then wait(0.5) end
        end
      else
        broadcastToAll('No available site to discover.')
      end
    end
  elseif action == 'guardian' then
    if gmNotes == 'green' and round == 5 then
      broadcastToAll('Rival does not take this action in round 5.')
    else
      if options.researchTrack == 4 and soloStatus.magnifying.row == 5 then
        -- overcome lizard temple guardian first
        local guardianZone = getObjectFromGUID(researchTracks[4].guardianZone)
        for _, object in ipairs(guardianZone.getObjects()) do
          if object.hasTag('guardian') then
            broadcastToAll('Rival overcomes the Lizard Temple guardian.')
            wait(0.5)
            object.setRotation(faceup)
            object.setPositionSmooth(solo.acquiredStuffPositions.guardian, false, false)
            soloStatus.fulfilledObjectives.guardian = true
            break
          end
        end
      end
      if not soloStatus.fulfilledObjectives.guardian then
        -- overcome a guardian on the main board
        for i, siteLevel in ipairs(siteLevels) do
          local possibleGuardians = {}
          for _, siteInfo in ipairs(siteLevel) do
            if i == 4 or siteInfo.discovered then
              -- check for guardian
              local guardian = nil
              for _, object in ipairs(getObjectFromGUID(siteInfo.guid).getObjects()) do
                if object.hasTag('guardian') then
                  guardian = object
                  break
                end
              end
              if guardian ~= nil then
                for _, object in ipairs(getObjectFromGUID(siteInfo.pawnSpaces[1]).getObjects()) do
                  if object.hasTag('pawn') then
                    if object.getDescription() == 'Red' then table.insert(possibleGuardians, guardian) end
                    break
                  end
                end
              end
            end
          end
          if #possibleGuardians > 0 then
            local guardian = possibleGuardians[math.random(1, #possibleGuardians)]
            broadcastToAll('Rival overcomes a guardian.')
            wait(0.5)
            guardian.setRotation(faceup)
            guardian.setPositionSmooth(solo.acquiredStuffPositions.guardian, false, false)
            soloStatus.fulfilledObjectives.guardian = true
            break
          end
        end
      end
      if not soloStatus.fulfilledObjectives.guardian then
        -- research with magnifying
        broadcastToAll('No guardians to overcome.')
        wait(1)
        soloStatus.fulfilledObjectives.research = rivalResearch('magnifying', true)
      end
      if gmNotes == 'purple' then
        -- research with notebook
        wait(1.5)
        if soloStatus.notebook.row > soloStatus.magnifying.row or soloStatus.notebook.row == 0 and soloStatus.magnifying.row > 0 then
          rivalResearch('notebook', true)
        end
      end
    end
  elseif action == 'research' then
    if gmNotes == 'green' and round == 5 then
      broadcastToAll('Rival does not take this action in round 5.')
    else
      soloStatus.fulfilledObjectives.research = rivalResearch('magnifying')
      if gmNotes == 'purple' and round == 5 then
        wait(1.5)
        rivalResearch('magnifying')
      end
    end
  end
  wait(1.2)

  -- draw objectives or check fulfillment
  if options.objectives > 0 then
    local objectivesDeckZone = getObjectFromGUID(solo.zones.objectivesDeck)
    if soloStatus.firstTurn then
      for i = 1, options.objectives do
        local toPos = getObjectFromGUID(solo.zones.objectives[i]).getPosition()
        local card = drawCard(objectivesDeckZone, faceup, toPos)
        wait(0.16)
        if card == nil then break end
      end
      wait(0.4)
    end

    local objectiveMessages = {
      artifact = 'buy an artifact.',
      item = 'buy an item.',
      site = 'discover a new site.',
      research = 'advance your magnifying glass.',
      arch = 'send many archaeologists to the main board.'
    }
    for _, guid in ipairs(solo.zones.objectives) do
      local objectiveCardZone = getObjectFromGUID(guid)
      for _, object in ipairs(objectiveCardZone.getObjects()) do
        if object.type == 'Card' then
          local objective = object.getDescription()
          if not object.is_face_down and objective ~= nil and soloStatus.fulfilledObjectives[objective] then
            if soloStatus.firstTurn then
              broadcastToAll('Replacing a completed objective.')
              object.setRotation(facedown)
              object.setPositionSmooth(objectivesDeckZone.getPosition(), false, false)
              drawCard(objectivesDeckZone, faceup, objectiveCardZone.getPosition())
              wait(1.2)
            else
              broadcastToAll('Rival completes objective: ' .. objectiveMessages[objective])
              wait(0.5)
              object.flip()
              wait(0.5)
              getObjectFromGUID(bags.soloTempleTiles).takeObject({
                position = solo.acquiredStuffPositions.templeTile[math.random(1, 6)],
                rotation = faceup
              })
              wait(1.2)
            end
          end
          break
        end
      end
    end
  end
  soloStatus.firstTurn = false

  local tent = getObjectFromGUID(playerVars[seatedPlayerColors[1]].tentGuid)
  if tent == nil or not tent.is_face_down or drawCard(solo.zones.deck, nil, nil, true) == nil then
    broadcastToAll(getPlayerName(seatedPlayerColors[1], true) .. "'s turn.", seatedPlayerColors[1])
    setupButtonRivalTurn()
  else
    rivalTurnCoroutine()
  end
  return 1
end

function rivalResearch(id, doNotTakeAssistant)
  local tokenName = id
  if id == 'magnifying' then tokenName = tokenName .. ' glass' end
  broadcastToAll('Rival researches with its ' .. tokenName .. '.')
  wait(0.5)

  local token = getObjectFromGUID(playerVars.Red.researchTokens[id])
  if token == nil then
    broadcastToAll('Error: unable to locate ' .. tokenName .. '.')
    return false
  end
  local track = researchTracks[options.researchTrack]

  if options.researchTrack == 3 and soloStatus[id].row == 7 and id == 'magnifying' then
    local toPos = track.artifactPos
    token.setRotationSmooth(faceup, false, true)
    token.setPositionSmooth({ toPos[1], toPos[2] + 0.4, toPos[3] }, false, false)
    soloStatus[id].row = 5
    soloStatus[id].path = 1
    return true
  end

  if id == 'magnifying' and soloStatus[id].row == 1 or id == 'notebook' and soloStatus[id].row == 2 then
    wait(1.2)
    function moveSilver(index)
      for _, object in ipairs(getObjectFromGUID(templeTileZoneGuids[index]).getObjects()) do -- zones have tag 'temple'
        broadcastToAll('Rival takes a silver temple tile.')
        object.setRotation(faceup)
        object.setPositionSmooth(solo.acquiredStuffPositions.templeTileSilver, false, false)
        return true
      end
      return false
    end

    local rand = math.random(4, 5)
    local silverFound = moveSilver(rand)
    if not silverFound then
      if rand == 4 then
        silverFound = moveSilver(5)
      else
        silverFound = moveSilver(4)
      end
    end
    if not silverFound then broadcastToAll('No silver temple tiles found.') end
    return false
  elseif id == 'magnifying' and soloStatus[id].row == 2 then
    for _, guid in ipairs(templeSpaceZoneGuids) do
      local occupied = false
      local zone = getObjectFromGUID(guid)
      for _, object in ipairs(zone.getObjects()) do
        if string.find(object.getName(), 'Magnifying') ~= nil then occupied = true end
      end
      if not occupied then
        local toPos = zone.getPosition()
        token.setRotationSmooth(faceup, false, true)
        token.setPositionSmooth({ toPos[1], 2, toPos[3] }, false, false)
        soloStatus[id].row = 1
        soloStatus[id].path = 1
        break
      end
    end
    rivalTakeResearchBonus(track.rows[1].bonusPos)
    return true
  end

  local nextRowIndex = nil
  local forwardPaths = nil
  if soloStatus[id].row == 0 then
    nextRowIndex = #track.rows
    forwardPaths = {}
    for i, _ in ipairs(track.rows[nextRowIndex].paths) do
      table.insert(forwardPaths, i)
    end
  else
    nextRowIndex = soloStatus[id].row - 1
    forwardPaths = track.rows[soloStatus[id].row].paths[soloStatus[id].path].forward
  end

  local nextRow = track.rows[nextRowIndex]
  local nextPathIndex = forwardPaths[math.random(1, #forwardPaths)]
  local nextPath = nextRow.paths[nextPathIndex]
  local toPos = nextPath.pos

  if toPos ~= nil then
    token.setRotationSmooth(faceup, false, true)
    token.setPositionSmooth({ toPos[1], toPos[2] + 0.4, toPos[3] }, false, false)
    soloStatus[id].row = nextRowIndex
    soloStatus[id].path = nextPathIndex
    if nextPath.bonus then rivalTakeResearchBonus(toPos) end
  else
    -- the next path has multiple bonus tiles; pick one and move to its spot
    local bonusTile = nil
    local bonusPositions = {} -- duplicate of nextPath.bonusPos for removing values
    for _, pos in ipairs(nextPath.bonusPos) do
      table.insert(bonusPositions, pos)
    end

    for i = 1, #bonusPositions do
      local bonusIndex = math.random(1, #bonusPositions)
      local bonusPos = bonusPositions[bonusIndex]
      for _, object in ipairs(getObjectFromGUID(researchZoneGuid).getObjects()) do -- research zone has tag 'research'
        if object.getDescription() == nil or object.getDescription() == '' then
          if comparePosition(object.getPosition(), bonusPos) then
            bonusTile = object
            toPos = bonusPos
            break
          end
        end
      end
      if bonusTile == nil then
        table.remove(bonusPositions, bonusIndex)
      else
        break
      end
    end

    if toPos == nil then toPos = nextPath.bonusPos[1] end
    token.setRotationSmooth(faceup, false, true)
    token.setPositionSmooth({ toPos[1], toPos[2] + 0.4, toPos[3] }, false, false)
    soloStatus[id].row = nextRowIndex
    soloStatus[id].path = nextPathIndex
    if bonusTile ~= nil then
      wait(1.2)
      broadcastToAll('Rival removes a research bonus tile.')
      bonusTile.setRotation(facedown)
      bonusTile.setPositionSmooth(solo.acquiredStuffPositions.researchBonus, false, false)
    end
  end

  if id == 'magnifying' and nextRow.assistant then
    wait(1.2)
    if options.researchTrack == 2 and soloStatus[id].row == 5 then
      local card = drawCard(track.assistantZone, faceup, solo.acquiredStuffPositions.assistant)
      if card ~= nil then
        broadcastToAll('Rival rescues an assistant from the research track.')
        wait(1.2)
      end
    end

    if doNotTakeAssistant then
      broadcastToAll('Rival does not remove an assistant from the supply board for this action.')
    else
      local most = 0
      local possibleZones = {}
      for _, guid in ipairs(assistantZones) do
        local zone = getObjectFromGUID(guid)
        local obj = drawCard(zone, nil, nil, true)
        if obj ~= nil then
          local quantity = 0
          if obj.type == 'Card' then
            quantity = 1
          elseif obj.type == 'Deck' then
            quantity = obj.getQuantity()
          end

          if quantity > most then
            most = quantity
            possibleZones = { zone }
          elseif quantity == most then
            table.insert(possibleZones, zone)
          end
        end
      end
      if #possibleZones > 0 then
        broadcastToAll('Rival removes an assistant.')
        drawCard(possibleZones[math.random(1, #possibleZones)], faceup, solo.acquiredStuffPositions.assistant)
      end
    end
  end
  return true
end

function rivalTakeResearchBonus(bonusPos)
  for _, object in ipairs(getObjectFromGUID(researchZoneGuid).getObjects()) do -- research zone has tag 'research'
    if object.getDescription() == nil or object.getDescription() == '' then
      if comparePosition(object.getPosition(), bonusPos) then
        wait(1.2)
        broadcastToAll('Rival removes a research bonus tile.')
        object.setRotation(facedown)
        object.setPositionSmooth(solo.acquiredStuffPositions.researchBonus, false, false)
        break
      end
    end
  end
end

function rivalTurnButton(buttonZone, clickColor, alt)
  if round < 1 or not doneLoading or setupInProgress or not isSeated(clickColor) and clickColor ~= 'Black' then return end
  local button = buttonZone.getButtons()[1]
  if button.label == buttonLabelsRival.ready then startLuaCoroutine(Global, 'rivalTurnCoroutine') end
end

---------------------- UTIL

function getDeckZoneGuid(playerColor)
  local vars = playerVars[playerColor]
  if options.playerBoards[playerColor] == 9 then return vars.deckZoneGuids.base end
  if options.playerBoards[playerColor] == 6 then return vars.deckZoneGuids.mystic end
  if options.playerBoards[playerColor] == 7 or options.playerBoards[playerColor] == 8 then
    return vars.deckZoneGuids.journo_Mech
  end
  -- TODO: maybe add additional scripting zones for journalist and mechanic
  --if options.playerBoards[playerColor] == 7 then return vars.deckZoneGuids.journalist end
  --if options.playerBoards[playerColor] == 8 then return vars.deckZoneGuids.mechanic end
  return vars.deckZoneGuids.leader
end

function getPlayerBoard(playerColor)
  for _, object in ipairs(getObjectFromGUID(playerVars[playerColor].allZoneGuid).getObjects()) do
    if object.getName() == 'Player Board' then return object end
  end
  return nil
end

function comparePosition(pos1, pos2)
  if math.abs(pos1[1] - pos2[1]) < 0.1 and math.abs(pos1[3] - pos2[3]) < 0.1 then return true end
  return false
end

function drawCard(zone, rotation, position, checkOnly)
  -- allow providing a zone GUID or an object reference
  if zone.type == nil then
    zone = getObjectFromGUID(zone)
  end

  if zone.type ~= "Scripting" then
    log("Invalid zone!")
    return
  end

  for _, object in ipairs(zone.getObjects()) do
    if checkOnly then
      if object.type == 'Card' or object.type == 'Deck' then return object end
    elseif object.type == 'Card' then
      if position ~= nil then
        object.setRotationSmooth(rotation, false, true)
        object.setPositionSmooth(position, false, true)
      end
      return object
    elseif object.type == 'Deck' then
      return object.takeObject({ position = position, rotation = rotation })
    end
  end
  return nil
end

function getPlayerName(playerColor, excludeHexColor)
  local name = Player[playerColor].steam_name
  if name == nil then name = playerColor end
  if not excludeHexColor and hexColors[playerColor] ~= nil then name = hexColors[playerColor] .. name .. '[-]' end
  return name
end

function isSeated(playerColor)
  for _, color in ipairs(seatedPlayerColors) do
    if color == playerColor then return true end
  end
  return false
end

function listToText(list, getPlayerNames)
  if list == nil or #list == 0 then return nil end
  local text = ''
  for i, item in ipairs(list) do
    if i > 1 then
      if #list == 2 then
        text = text .. ' and '
      else -- #list > 2
        if i == #list then
          text = text .. ', and '
        else
          text = text .. ', '
        end
      end
    end
    if getPlayerNames then
      text = text .. getPlayerName(item)
    else
      text = text .. item
    end
  end
  return text
end

function temp() end

function wait(t)
  local now = Time.time
  repeat coroutine.yield(0) until Time.time > now + t
end

---@diagnostic disable: param-type-mismatch, assign-type-mismatch
-- originally scripted by jkk - https://steamcommunity.com/id/creamymello/myworkshopfiles/
-- updated by Chr1Z and covertskippy55 for the missing expedition
-- refactored by Chr1Z for twisted paths (playzones shifted by 8 units in x-direction)

require("util/TtsLuaAdditions")
local DeckLib               = require("util/DeckLib")
local PlayermatApi          = require("playermat/PlayermatApi")
local SearchLib             = require("util/SearchLib")
RESEARCH_TRACK_DATA         = require("ResearchTrackData")

TEST_VARS                   = {
  defineSeated  = false,
  hideSplash    = false,
  seatedPlayers = { 'Blue', 'Red', 'Yellow', 'Green' }
}

COLOR_LIST                  = { "Blue", "Red", "Yellow", "Green" }

RESEARCH_TOKENS             = { "magnifying", "journal", "lantern" }

PLAYER_VARS                 = {
  Red = {
    allZoneGuid          = 'b32bc6',
    playAreaZoneGuid     = '472eb8',
    pawns                = { 'b2d015', '47658b', 'bfb9eb' },
    pawnPositions        = { { -36.33, 2.30, 24.41 }, { -32.91, 2.30, 24.03 }, { -34.38, 2.30, 25.02 } },
    resourceBags         = {
      t = '7cf312',
      a = 'b5027a',
      j = '2e0235',
      c = 'ea5777',
      s = 'e10365'
    },
    resourceBagZones     = {
      t = 'e757ed',
      a = 'd0f92a',
      j = 'b56916',
      c = 'cbf8fd',
      s = '0a749b'
    },
    archivePositions     = { { -76, 1.50, 20.30 }, { -76, 1.50, 13.10 }, { -76, 1.50, 5.90 } },
    articleToothPosition = { -32, 1.57, 16.80 },
    refPositions         = { { -61, 1.48, 28.5 }, { -55, 1.48, 28.5 } },
    leaderOverview       = "c30ae7",
    firstPlayerPosition  = { -38, 1.53, 33 },
    clockPosition        = Vector(-34.60, 0.50, 27.50)
  },
  Blue = {
    allZoneGuid          = 'd9da53',
    playAreaZoneGuid     = '67c9fd',
    pawns                = { 'c8a97b', 'ddd08f', '822412' },
    pawnPositions        = { { 36.29, 2.30, 24.02 }, { 32.87, 2.30, 24.41 }, { 34.82, 2.30, 25.02 } },
    resourceBags         = {
      t = 'd40949',
      a = '20ff93',
      j = '70714a',
      c = 'bcf902',
      s = '65efcd'
    },
    resourceBagZones     = {
      t = 'c197da',
      a = '2e1fe3',
      j = '8e0e22',
      c = '12d02d',
      s = '5c8abb'
    },
    archivePositions     = { { 76, 1.50, 20.30 }, { 76, 1.50, 13.10 }, { 76, 1.50, 5.90 } },
    articleToothPosition = { 37.20, 1.57, 16.80 },
    refPositions         = { { 61, 1.48, 28.5 }, { 55, 1.48, 28.5 } },
    leaderOverview       = "c4dd33",
    firstPlayerPosition  = { 38, 1.53, 33 },
    clockPosition        = Vector(34.60, 0.50, 27.50)
  },
  Green = {
    allZoneGuid          = '05b782',
    playAreaZoneGuid     = 'df8647',
    pawns                = { '609cfd', 'ddc20b', 'b4abfd' },
    pawnPositions        = { { 36.29, 2.30, -16.98 }, { 32.87, 2.30, -16.59 }, { 34.82, 2.30, -15.98 } },
    resourceBags         = {
      t = '9bf040',
      a = '64418c',
      j = 'da3f08',
      c = '590b1a',
      s = '8b0cb8'
    },
    resourceBagZones     = {
      t = 'f4d753',
      a = '067ec4',
      j = '37db2d',
      c = '4eab66',
      s = 'b8b628'
    },
    archivePositions     = { { 76, 1.50, -20.70 }, { 76, 1.50, -27.90 }, { 76, 1.50, -35.10 } },
    articleToothPosition = { 37.20, 1.57, -24.20 },
    refPositions         = { { 61, 1.48, -12.5 }, { 55, 1.48, -12.5 } },
    leaderOverview       = "47e8e6",
    firstPlayerPosition  = { 38, 1.53, -8 },
    clockPosition        = Vector(34.60, 0.50, -13.50)
  },
  Yellow = {
    allZoneGuid          = '19cc4f',
    playAreaZoneGuid     = '7a5b2c',
    pawns                = { 'e94bc0', 'dabf30', 'b5f37c' },
    pawnPositions        = { { -36.33, 2.30, -16.59 }, { -32.91, 2.30, -16.98 }, { -34.38, 2.30, -15.98 } },
    resourceBags         = {
      t = 'cf6aea',
      a = 'd28bcd',
      j = '355261',
      c = '57c250',
      s = 'f20389'
    },
    resourceBagZones     = {
      t = '9b072b',
      a = 'dba428',
      j = 'f72570',
      c = '71fc56',
      s = 'f0ec52'
    },
    archivePositions     = { { -76, 1.50, -20.70 }, { -76, 1.50, -27.90 }, { -76, 1.50, -35.10 } },
    articleToothPosition = { -32, 1.57, -24.20 },
    refPositions         = { { -61, 1.48, -12.5 }, { -55, 1.48, -12.5 } },
    leaderOverview       = "d40f4c",
    firstPlayerPosition  = { -38, 1.53, -8 },
    clockPosition        = Vector(-34.60, 0.50, -13.50)
  }
}

-- points for idol slots
IDOL_SLOT_DATA              = {
  Captain    = { 1, 2, 3, 4 },
  Falconer   = { 1, 2, 3, 4 },
  Baroness   = { 1, 2, 3, 4 },
  Professor  = { 1, 2, 3, 4 },
  Explorer   = { 1, 2, 3, 4 },
  Mystic     = { 1, 2, 2, 3, 4 },
  Journalist = { 2, 3, 4, 0, 0 },
  Mechanic   = { 1, 2, 3, 4 },
  Base       = { 1, 2, 3, 4 }
}

DARK_TABLET_DATA            = {
  bucketSize     = Vector(2.25, 2, 3),
  leftBucketPos  = Vector(-25.5, 1.7, -22.4),
  rightBucketPos = Vector(0.17, 1.7, -22.4),
  offsetX        = 1.65,
  offsetZ        = 2.15,
  bucketVp       = { -1, -2, -2, -3, -3, -4, -5 }
}

STARTER_DECK_DATA           = {
  Yellow     = { "0001", "0002", "0003", "0004" },
  Green      = { "0005", "0006", "0007", "0008" },
  Blue       = { "0009", "0010", "0011", "0012" },
  Red        = { "0013", "0014", "0015", "0016" },
  Falconer   = { "1001", "1002", "1003", "1004" },
  Explorer   = { "1005", "1006", "1007", "1008" },
  Professor  = { "1009", "1010", "1011", "1012" },
  Mystic     = { "1013", "1014", "1015", "1016" },
  Baroness   = { "1017", "1018", "1019", "1020" },
  Captain    = { "1021", "1022", "1023", "1024" },
  Mechanic   = { "2001", "2002", "2003", "2004" },
  Journalist = { "2005", "2006", "2007", "2008" }
}

seatedPlayerColors          = {}
startPlayerIndex            = 0

options                     = {
  solo          = false,
  objectives    = 3,
  playerBoards  = {
    Blue   = 9,
    Green  = 9,
    Yellow = 9,
    Red    = 9
  },
  board         = 1,
  researchTrack = 1,
  staff         = 1,
  leaders       = 'random',
  campaign      = false,
  expansions    = {
    expeditionLeaders = true,
    missingExpedition = true,
    twistedPaths      = true,
    promos            = true
  }
}

BAG_GUIDS                   = {
  resources       = {
    t = '831df9',
    a = '84369b',
    j = 'e283e9',
    c = '1ee5ea',
    s = 'c85087'
  },
  fear            = '69002b',
  blocking        = '8c3f25',
  researchBonus   = 'e90e2a',
  leaderRef       = '0a5188',
  miscTokens      = '47fde4',
  solo            = 'cabb5b',
  soloTempleTiles = 'c13fff',
  campaignItems   = '5c483d'
}

DECK_ZONE_GUIDS             = {
  sites1    = '702902',
  sites2    = 'e0c338',
  guardians = 'b51480',
  bonus1    = "bonus1",
  bonus2    = "bonus2",
  bonus3    = "bonus3",
  bonus4    = "bonus4",
  bonus5    = "bonus5"
}

ASSISTANT_DECK_GUID         = '538a5c'
IDOL_DECK_GUID              = 'ab4a80'

EXPANSION_DECKS             = {
  expeditionLeaders = {
    assistants = 'cf87b7',
    idols      = '9988c4',
    sites1     = '37a6dd',
    sites2     = '486402',
    guardians  = 'b876d5'
  },
  missingExpedition = {
    assistants = 'b640aa',
    idols      = '2e956e',
    sites1     = '408800',
    sites2     = '10d945',
    guardians  = '6fbe77'
  },
  twistedPaths = {
    assistants = '629725',
    idols      = 'b2f00e',
    sites1     = 'eb952d',
    sites2     = '632057',
    guardians  = 'd8eb77'
  }
}

BUTTON_BLOCK_GUID           = "b1c55f"

TOKEN_GUIDS                 = {
  falcon                    = '9ef0a8',
  suitcase                  = 'f78694',
  food                      = { '4c7454', '7ae3bf', 'a4129d' },
  firstPlayer               = 'b1383c',
  journalistArticles        = 'a40186',
  journalistNewspapers      = 'd73b83',
  MechanicWheel             = 'd3657d',
  MechanicMonkey            = '168247',
  MechanicGoldTokens        = '428f5c',
  MechanicGoldTokenAttacher = '3cc576'
}

SPECIAL_DELIVERY_GUID       = '49e35e'
SUITCASE_RESOURCE_BAG_GUIDS = { t = 'da4493', s = '4ecc7c' }
FALCON_ROTATIONS            = { { 0, 225, 0 }, { 0, 190, 0 }, { 0, 148, 0 }, { 0, 115, 0 }, { 0, 90, 0 } }
ASSISTANT_POSITIONS         = { { 9.15, 1.63, -30.73 }, { 13.83, 1.63, -30.73 }, { 18.52, 1.63, -30.73 } }
ASSISTANT_ZONES             = { 'a432ac', 'a44647', '3ffbd7' }

PLAYERMAT_STATE_TO_LEADER   = {
  [1] = "Captain",
  [2] = "Falconer",
  [3] = "Baroness",
  [4] = "Professor",
  [5] = "Explorer",
  [6] = "Mystic",
  [7] = "Journalist",
  [8] = "Mechanic",
  [9] = "Base"
}

OTHER_EXILED_SPOT           = {
  pos = Vector(-26.5, 2, 47),
  rot = Vector(0, 90, 0)
}

-- local data for the card board
CARD_BOARD_DATA             = {
  exiledArtifact  = { pos = Vector(2.2, 2, -0.012), rot = Vector(0, 90, 0) },
  exiledItem      = { pos = Vector(-2.2, 2, -0.012), rot = Vector(0, -90, 0) },
  exiledFear      = { pos = Vector(0, 2, -0.012) },
  reserveArtifact = { pos = Vector(4.413, 2, -0.012) },
  reserveItem     = { pos = Vector(-4.413, 2, -0.012) },
  reserveFear     = { pos = Vector(0, 2, -0.012) }
}

INVERSE_BOARD_SCALE         = Vector(1 / 30, 1, 1 / 30)

MAIN_BOARD_DATA             = {
  base = {
    camp        = {
      { pos = Vector(-18.06, 1.6, -21.30), reward = "cc" },
      { pos = Vector(-12.50, 1.6, -20.40), reward = "ss" },
      { pos = Vector(-6.94, 1.6, -19.39),  reward = "tt" },
      { pos = Vector(-1.36, 1.6, -20.28),  reward = "a" },
      { pos = Vector(4.20, 1.6, -21.37),   reward = "j" }
    },
    lvl1        = {
      { pos = Vector(-17.46, 1.6, -11.15) },
      { pos = Vector(-10.35, 1.6, -9.11) },
      { pos = Vector(-3.30, 1.6, -10.61) },
      { pos = Vector(3.48, 1.6, -10.88) },
      { pos = Vector(-17.70, 1.6, -1.10) },
      { pos = Vector(-10.62, 1.6, -0.38) },
      { pos = Vector(-3.87, 1.6, -1.82) },
      { pos = Vector(3.72, 1.6, -2.03) }
    },
    lvl2        = {
      { pos = Vector(-17.49, 1.6, 9.61) },
      { pos = Vector(-10.47, 1.6, 10.21) },
      { pos = Vector(-3.36, 1.6, 11.23) },
      { pos = Vector(3.54, 1.6, 9.49) }
    },
    marketStart = Vector(-18.18, 1.65, 19.6),
    marketEnd   = Vector(18.18, 1.65, 19.6)
  },
  spider = {
    camp        = {
      { pos = Vector(-26.44, 1.6, -14.77), reward = "cc" },
      { pos = Vector(-20.40, 1.6, -13.93), reward = "ss" },
      { pos = Vector(-14.35, 1.6, -13.41), reward = "tt~" },
      { pos = Vector(-8.60, 1.6, -13.64),  reward = "a" },
      { pos = Vector(-2.96, 1.6, -14.55),  reward = "*" }
    },
    lvl1        = {
      { pos = Vector(-25.80, 1.6, -4.85) },
      { pos = Vector(-18.47, 1.6, -2.71) },
      { pos = Vector(-11.20, 1.6, -4.17) },
      { pos = Vector(-4.31, 1.6, -4.40), reward = "#" },
      { pos = Vector(-25.96, 1.6, 5.49) },
      { pos = Vector(-18.75, 1.6, 6.21) },
      { pos = Vector(-11.75, 1.6, 4.84) },
      { pos = Vector(-4.08, 1.6, 4.61),  reward = "$" }
    },
    lvl2        = {
      { pos = Vector(-26.11, 1.6, 16.64) },
      { pos = Vector(-18.88, 1.6, 17.23) },
      { pos = Vector(-11.63, 1.6, 17.78) },
      { pos = Vector(-4.54, 1.6, 16.43), reward = "q" }
    },
    marketStart = Vector(-25.93, 1.65, 25.96),
    marketEnd   = Vector(10.90, 1.65, 25.96)
  },
  owl = {
    camp        = {
      { pos = Vector(-26.36, 1.6, -20.46), reward = "c%" },
      { pos = Vector(-20.43, 1.6, -19.55), reward = "ss" },
      { pos = Vector(-14.45, 1.6, -19.07), reward = "tt" },
      { pos = Vector(-8.66, 1.6, -19.28),  reward = "fca" },
      { pos = Vector(-3.14, 1.6, -20.04),  reward = "j" }
    },
    lvl1        = {
      { pos = Vector(-25.78, 1.6, -9.68) },
      { pos = Vector(-18.42, 1.6, -9.26) },
      { pos = Vector(-11.17, 1.6, -9.15) },
      { pos = Vector(-4.29, 1.6, -9.29) },
      { pos = Vector(-24.50, 1.6, 3.57), doubleIdol = true },
      { pos = Vector(-17.62, 1.6, 3.67), doubleIdol = true },
      { pos = Vector(-10.97, 1.6, 3.66), doubleIdol = true },
      { pos = Vector(-3.63, 1.6, 3.52),  doubleIdol = true }
    },
    lvl2        = {
      { pos = Vector(-24.37, 1.6, 16.01) },
      { pos = Vector(-17.47, 1.6, 16.68) },
      { pos = Vector(-10.58, 1.6, 16.52) },
      { pos = Vector(-3.76, 1.6, 15.79) }
    },
    marketStart = Vector(-24.35, 1.65, 25.35),
    marketEnd   = Vector(11.1, 1.65, 25.35)
  }
}

-- global offsets
SITE_OFFSETS                = {
  spotLeft      = Vector(-1.1, 0, -3.54),
  spotRight     = Vector(1.1, 0, -3.54),
  spotLvl1      = Vector(0, 0, -3.65),
  spotLvl2      = Vector(0, 0, -4.1),
  guardian      = Vector(0, 0.05, 0.7),
  idolLeft      = Vector(-1, 0.2, -2.1),
  idolRight     = Vector(1, 0.2, -2.1),
  idolMiddle    = Vector(0, 0.2, -1.76),
  buttonShift   = Vector(0, 0, 0.225),
  buttonUpShift = Vector(0, 0, 0.25),
  below         = Vector(0, 0, -1.42),
  right         = Vector(1.65, 0, 0),
  left          = Vector(-2.2, 0, 0)
}

solo                        = {
  board = 'a30382',
  boardPosition = { -43.26, 1.53, 18.96 },
  objectives = 'd8547e',
  objectivePosition = { -51, 1.53, -0.80 },
  zones = {
    deck = '7196a9',
    discard = '0ecbe9',
    idol = {
      c    = '184e31',
      p    = 'de4ec0',
      s    = '7fa25b',
      fa   = '6892c0',
      ftt  = '1caf8d',
      g    = '6892c0',
      d    = '53c99c',
      t    = '500131',
      r    = 'af87d7',
      e    = '69ed89',
      u    = 'fdf87e',
      dupe = '91df7a'
    },
    objectivesDeck = '250afb',
    objectives = { 'd18d8f', 'c9584b', '36d489', '08da31' }
  },
  pawns = { '47658b', 'bfb9eb', 'b2d015', 'fb9f5d', '9f84c9', 'e5b510' },
  pawnPositions = { { -28.50, 2.20, 20 }, { -26.50, 2.20, 20 }, { -24.50, 2.20, 20 }, { -28.50, 2.20, 18 }, { -26.50, 2.20, 18 }, { -24.50, 2.20, 18 } },
  actionDecks = { arch = 'f682fb', other = '52b0e5' },
  actionCards = {
    artifact = { '35cf03', '8643d5', '6862ec' },
    item     = { '0b253e', 'ff70b0', '344897' },
    site     = { '3e3e03', '0fe862', '79c5eb' },
    guardian = { 'ee3c46', '4a8a22', '5e9528' },
    research = { 'd5cc24', 'ea0b21', 'f06250' }
  },
  actionCardTypes = { 'artifact', 'item', 'site', 'guardian', 'research' },
  deckPositions = { { -52.57, 1.65, 17.70 }, { -48.58, 1.60, 17.70 } },
  setupPositions = { { -52.57, 1.53, 42.48 }, { -48.58, 1.53, 42.48 } },
  acquiredStuffPositions = {
    idolA            = { -34.85, 1.50, 10.15 },
    researchBonus    = { -32.16, 2.28, 10.15 },
    templeTile       = { { -45.60, 1.93, 11 }, { -42, 1.93, 11 }, { -38.40, 1.93, 11 }, { -45.60, 1.93, 9.30 }, { -42, 1.93, 9.30 }, { -38.40, 1.93, 9.30 } },
    templeTileSilver = { -49.90, 1.93, 10.15 },
    templeTileGold   = { -54.10, 1.93, 10.15 },
    guardian         = { -42.25, 2.10, 17.71 },
    buy              = { -35.12, 2.10, 18.95 },
    assistant        = { -26.50, 2, 10.15 }
  }
}

soloStatus                  = {
  firstTurn           = true,
  fulfilledObjectives = {},
  pawnsOut            = 0,
  magnifying          = { row = 0, path = 0 },
  journal             = { row = 0, path = 0 }
}

function addColorToString(playerColor, str)
  return "[" .. Color.fromString(playerColor):toHex() .. "]" .. (str or playerColor) .. "[-]"
end

tableY            = 1.5
tileY             = 1.6
pawnY             = 2.3
faceup            = Vector(0, 180, 0)
facedown          = Vector(0, 180, 180)
buttonLabels      = {
  ready1  = 'Calculate Scores',
  ready2  = 'Recalculate Scores',
  confirm = addColorToString("Green", "Confirm"),
  busy    = addColorToString("Red", "Scoring")
}
buttonLabelsRival = { ready = 'Rival Turn', busy = addColorToString("Red", "Busy") }

waitQueue         = {}
round             = 0
doneLoading       = false
setupInProgress   = false
movingRow         = false
turn              = nil -- tts bug: the player turn is not set correctly when loading/rewinding

-- MARK: GENERAL CODE

function onSave()
  return JSON.encode({
    seatedPlayerColors = seatedPlayerColors,
    startPlayerIndex   = startPlayerIndex,
    options            = options,
    round              = round,
    soloStatus         = soloStatus,
    turn               = turn
  })
end

function onLoad(saveState)
  local loadedData = JSON.decode(saveState)
  if loadedData ~= nil and loadedData.seatedPlayerColors ~= nil and loadedData.round > 0 then
    seatedPlayerColors = loadedData.seatedPlayerColors
    startPlayerIndex   = loadedData.startPlayerIndex
    options            = loadedData.options
    round              = loadedData.round
    soloStatus         = loadedData.soloStatus
    turn               = loadedData.turn
  end

  for _, obj in ipairs(getObjects()) do
    onObjectSpawn(obj)
  end

  createGlobalXml()

  Wait.frames(function()
    if round == 0 then
      menuOptions()
    elseif round > 0 then
      drawPlayAreas()
      setupButtons()
      createBoardButtons()
      for _, object in ipairs(getObjects()) do
        addExileMenu(object)
        addGetRewardsMenu(object)
        addReturnMenu(object)
        addTrashMenu(object)
      end
      addAssistantCycleMenu()
    end
    if turn ~= nil and Turns.enable and Turns.turn_color ~= turn then Turns.turn_color = turn end
    Wait.time(function() doneLoading = true end, 0.5)
  end, 10)
end

function onObjectSpawn(obj)
  if obj.hasTag("NotInteractable") then
    obj.interactable = false
  end
end

function getCardBoardLocation(cardType, state)
  if state ~= "exiled" then
    state = "reserve"
  end
  local data = CARD_BOARD_DATA[state .. cardType]
  return getObjectFromGUID("reserve").positionToWorld(data.pos), data.rot or Vector(0, 0, 0)
end

function getBoardData(board)
  board = board or getObjectByTag("MainBoard")
  if not board then return {} end

  local stateId = board.getStateId()

  if stateId == 3 then
    return MAIN_BOARD_DATA.spider
  elseif stateId == 4 then
    return MAIN_BOARD_DATA.owl
  end

  return MAIN_BOARD_DATA.base
end

function createBoardButtons(board)
  board = board or getObjectByTag("MainBoard")

  if not board then
    log("Board not found!")
    return
  end

  board.clearButtons()

  local data = getBoardData(board)
  boardButtonIndex = 0

  -- special handling for Spider Temple
  local isSpiderTemple = options.board == 3

  -- camp site buttons
  for i, site in ipairs(data.camp) do
    local extraOffset1 = Vector((isSpiderTemple and i == 3) and -1.1 or 0, 0, 0)
    local extraOffset2 = Vector((isSpiderTemple and i == 3) and 1.1 or 0, 0, 0)
    addMoveButton(board, site.pos, SITE_OFFSETS.spotLeft, SITE_OFFSETS.below + extraOffset1, site.reward, true)
    addMoveButton(board, site.pos, SITE_OFFSETS.spotRight, SITE_OFFSETS.below + extraOffset2, site.reward, true)
  end

  -- lvl 1 site buttons
  for i, site in ipairs(data.lvl1) do
    local offset = (isSpiderTemple and (i == 4 or i == 8)) and SITE_OFFSETS.below or SITE_OFFSETS.right
    addMoveButton(board, site.pos, SITE_OFFSETS.spotLvl1, offset, site.reward)
    addSiteButton(board, site.pos, 1)
    addSiteAndGuardianButton(board, site.pos, 1)
  end

  -- lvl 2 site buttons
  for i, site in ipairs(data.lvl2) do
    local offset = (isSpiderTemple and i == 4) and SITE_OFFSETS.below or SITE_OFFSETS.right
    addMoveButton(board, site.pos, SITE_OFFSETS.spotLvl2, offset, site.reward)
    addSiteButton(board, site.pos, 2)
    addSiteAndGuardianButton(board, site.pos, 2)
  end

  -- buy buttons
  if data.marketStart and data.marketEnd then
    for i = 1, 6 do
      addMarketButton(board, i)
    end
  end

  if isSpiderTemple then
    local buttonPos      = getDarkTabletBucketPos(8)

    _G["gainDarkTablet"] = function(_, playerColor) gainResource("q", playerColor) end
    board.createButton({
      click_function = "gainDarkTablet",
      label          = "Take DT",
      position       = convertGlobalPosToBoard(buttonPos - Vector(0, 0, 1.4)),
      scale          = INVERSE_BOARD_SCALE,
      font_size      = 330,
      width          = 1600,
      height         = 600
    })

    _G["returnDarkTablet"] = function(_, playerColor) gainResource("q", playerColor, true) end
    board.createButton({
      click_function = "returnDarkTablet",
      label          = "Return DT",
      position       = convertGlobalPosToBoard(buttonPos - Vector(0, 0, 2.8)),
      scale          = INVERSE_BOARD_SCALE,
      font_size      = 330,
      width          = 1600,
      height         = 600
    })
  end
end

function addMarketButton(board, i)
  local marketPos = getMarketPos(i)

  local funcName  = "buy" .. i
  _G[funcName]    = function(_, playerColor, alt) buyFromMarket(playerColor, marketPos, alt) end

  board.createButton({
    click_function = funcName,
    label          = "Take / Buy",
    position       = convertGlobalPosToBoard(marketPos + Vector(0, 0, 5.2)),
    scale          = INVERSE_BOARD_SCALE,
    font_size      = 390,
    width          = 2125,
    height         = 600
  })
end

function attemptMove(playerColor, spotPos, sitePos, reward, isCamp)
  if not doneLoading or setupInProgress or not isSeated(playerColor) then return end

  -- check for available pawn
  local pawn = getAvailableArcheologist(playerColor)
  if not pawn then return end

  -- check if space is occupied
  local occupants = SearchLib.atPosition(spotPos, "isPawnOrBlocked")
  if #occupants > 0 then
    if occupants[1].hasTag("blocked") then
      broadcastToColor("This space is blocked!", playerColor, "Red")
    else
      broadcastToColor("This space is already occupied!", playerColor, "Red")
    end
    return
  end

  -- search for site tile / idols and gain rewards
  if not isCamp then
    local siteFound = false
    for _, obj in ipairs(SearchLib.inArea(sitePos, nil, Vector(3, 1, 3))) do
      if obj.hasTag("site1") or obj.hasTag("site2") then
        deliverRewards(playerColor, obj)
        siteFound = true
      elseif obj.hasTag("idol") then
        local delivered = true
        if not obj.is_face_down then
          delivered = deliverRewards(playerColor, obj)
        end

        if delivered then
          local idolPosition4 = getGlobalPosForIdolSlot(playerColor, 4) - Vector(0, 0, 3)
          local toPosFacedown = idolPosition4:setAt("y", tileY + 0.3)
          obj.setRotation(facedown)
          obj.setPositionSmooth(toPosFacedown, false, false)
        else
          local idolPosition3 = getGlobalPosForIdolSlot(playerColor, 3) - Vector(0, 0, 3)
          local toPosFaceup   = idolPosition3:setAt("y", tileY + 0.3)
          obj.setRotation(faceup)
          obj.setPositionSmooth(toPosFaceup, false, false)
        end
      end
    end

    -- notify for discover costs
    if not siteFound then
      printToAll(getPlayerName(playerColor) .. " needs to pay costs for discovering a new site!", "White")
    end
  end

  -- move pawn
  pawn.setPositionSmooth(spotPos:setAt("y", pawnY))

  -- if there's a reward defined (camp spots / dark tablets), gain it
  if reward then
    deliverRewards(playerColor, nil, reward)
  end
end

function getSitePawns(sitePos, lvl)
  local searchPos = sitePos:copy():setAt("y", pawnY)
  if lvl == 2 then
    searchPos = searchPos + SITE_OFFSETS.spotLvl2
  else
    searchPos = searchPos + SITE_OFFSETS.spotLvl1
  end

  return SearchLib.inArea(searchPos, nil, Vector(3, 1, 1), "isPawn")
end

function placeSite(playerColor, sitePos, lvl)
  if not isSeated(playerColor) then return end

  -- ensure the player's pawn is placed
  local legal = false
  for _, obj in ipairs(getSitePawns(sitePos, lvl)) do
    if obj.getDescription() == playerColor then
      legal = true
      break
    end
  end

  if not legal then
    broadcastToColor("You need to have an archeologist at this site!", playerColor, "Red")
    return
  end

  -- place site
  local site = placeCardFromZone(DECK_ZONE_GUIDS["sites" .. lvl], sitePos:setAt("y", 1.6), faceup)
  if not site then
    broadcastToColor("Couldn't find a suitable site!", playerColor, "Red")
    return
  end
  site.setLock(true)

  -- gain rewards
  local delivered = deliverRewards(playerColor, site)
  return delivered
end

function placeGuardian(playerColor, guardianPos, allRewardsDelivered)
  if not isSeated(playerColor) then return end
  placeCardFromZone(DECK_ZONE_GUIDS.guardians, guardianPos, allRewardsDelivered and faceup or facedown)
end

function placeCardFromZone(zoneGuid, position, rotation)
  local zone = getObjectFromGUID(zoneGuid)
  if not zone or not position then return end

  for _, obj in ipairs(zone.getObjects()) do
    if obj.type == "Deck" then
      return obj.takeObject({ position = position, rotation = rotation })
    elseif obj.type == "Card" then
      obj.setRotation(rotation)
      obj.setPositionSmooth(position)
      return obj
    end
  end

  return false
end

function getBoardFuncName()
  boardButtonIndex = boardButtonIndex + 1
  return "boardButton" .. boardButtonIndex
end

function addMoveButton(board, sitePos, spotOffset, buttonOffset, reward, isCamp)
  local funcName = getBoardFuncName()
  local spotPos  = sitePos + spotOffset

  _G[funcName]   = function(_, playerColor) attemptMove(playerColor, spotPos, sitePos, reward, isCamp) end

  board.createButton({
    click_function = funcName,
    label          = "+",
    position       = convertGlobalPosToBoard(spotPos + buttonOffset),
    scale          = INVERSE_BOARD_SCALE,
    font_size      = 450,
    width          = 520,
    height         = 520
  })
end

function addSiteButton(board, sitePos, lvl)
  local funcName = getBoardFuncName()

  _G[funcName]   = function(_, playerColor) placeSite(playerColor, sitePos, lvl) end

  board.createButton({
    click_function = funcName,
    label          = "+ Site Only",
    position       = convertGlobalPosToBoard(sitePos - SITE_OFFSETS.buttonShift + SITE_OFFSETS.buttonUpShift),
    scale          = INVERSE_BOARD_SCALE,
    font_size      = 325,
    width          = 2250,
    height         = 420
  })
end

function addSiteAndGuardianButton(board, sitePos, lvl)
  local funcName    = getBoardFuncName()
  local guardianPos = sitePos + SITE_OFFSETS.guardian

  _G[funcName]      = function(_, playerColor)
    local success = placeSite(playerColor, sitePos, lvl)
    placeGuardian(playerColor, guardianPos, success)

    if not success then
      broadcastToAll("Flip the Guardian after resolving choices from the rewards.")
    end
  end

  board.createButton({
    click_function = funcName,
    label          = "+ Site & Guardian",
    position       = convertGlobalPosToBoard(guardianPos + SITE_OFFSETS.buttonShift + SITE_OFFSETS.buttonUpShift),
    scale          = INVERSE_BOARD_SCALE,
    font_size      = 275,
    width          = 2250,
    height         = 420
  })
end

function convertGlobalPosToBoard(pos)
  return (pos - Vector(0, 0, 4)):scale(INVERSE_BOARD_SCALE):scale(Vector(1, 1, -1)):setAt("y", 0.11)
end

-- MARK: START MENU UI

function createGlobalXml()
  local uiTable = {}

  -- Categories for the main scoreboard column
  local scoreboardCategories = {
    "Player",
    "Leader",
    "Research Tokens",
    "Temple Tiles",
    "Idols",
    "Guardians",
    "Items and Artifacts",
    "Fear",
    "Dark Tablets",
    "Altars",
    "Total"
  }

  -- Player colors, offsetXY, and initial values for the player scoreboards
  local playerScores = {
    { color = "Red",    offsetXY = "190 -140" },
    { color = "Blue",   offsetXY = "260 -140" },
    { color = "Green",  offsetXY = "330 -140" },
    { color = "Yellow", offsetXY = "400 -140" }
  }

  --- 1. Scoreboard (Labels Column)
  local scoreboardLabels = {
    tag        = "TableLayout",
    attributes = {
      id                  = "scoreboard",
      active              = false,
      rectAlignment       = "UpperLeft",
      offsetXY            = "70 -140",
      height              = 300,
      width               = 150,
      cellPadding         = "5 5 0 0",
      cellBackgroundColor = "clear",
      rowBackgroundColor  = "rgba(0, 0, 0, 0.97)"
    },
    children   = {}
  }

  -- Generate the rows for the labels column
  for _, label in ipairs(scoreboardCategories) do
    table.insert(scoreboardLabels.children, {
      tag = "Row",
      attributes = { id = "ScoreboardRow-" .. label },
      children = {
        {
          tag = "Cell",
          children = {
            {
              tag = "Text",
              attributes = {
                color     = "white",
                alignment = "MiddleRight",
                text      = label .. "  "
              }
            }
          }
        }
      }
    })
  end

  table.insert(uiTable, scoreboardLabels)

  --- 2. Player Scoreboards (Red, Blue, Green, Yellow)

  -- IDs/prefixes corresponding to the categories
  local scoreIds = {
    "name",
    "leader",
    "research",
    "temple",
    "idol",
    "guardian",
    "cards",
    "fear",
    "darkTablets",
    "altars",
    "total"
  }

  for _, playerData in ipairs(playerScores) do
    local colorName = playerData.color
    local scoreboard = {
      tag        = "TableLayout",
      attributes = {
        id                  = "scoreboard" .. colorName,
        active              = false,
        rectAlignment       = "UpperLeft",
        offsetXY            = playerData.offsetXY,
        height              = 300,
        width               = 80,
        cellPadding         = "5 5 0 0",
        cellBackgroundColor = "clear",
        rowBackgroundColor  = "rgba(0, 0, 0, 0.97)",
      },
      children   = {}
    }

    -- Generate the rows for the player score column
    for i, idPrefix in ipairs(scoreIds) do
      local initialValue = (idPrefix == "name") and "" or "0"

      table.insert(scoreboard.children, {
        tag = "Row",
        attributes = { id = "ScoreboardRow-" .. idPrefix .. colorName },
        children = {
          {
            tag = "Cell",
            children = {
              {
                tag = "Text",
                attributes = {
                  id        = idPrefix .. colorName,
                  color     = colorName,
                  alignment = "MiddleCenter",
                  text      = initialValue
                }
              }
            }
          }
        }
      })
    end

    table.insert(uiTable, scoreboard)
  end

  --- 3. Options Menu Top Panel
  table.insert(uiTable, {
    tag        = "Panel",
    attributes = {
      id            = "optionsMenuTop",
      active        = false,
      rectAlignment = "LowerRight",
      offsetXY      = "0 500",
      height        = 40,
      width         = 435,
      color         = "rgb(0, 0.39, 0.65)"
    },
    children   = {
      {
        tag = "Text",
        attributes = {
          color    = "White",
          fontSize = 16,
          text     = "Select Game Options"
        }
      }
    }
  })

  --- 4. Options Menu Left Table
  local leftOptions = {
    {
      title   = "Board",
      height  = 200,
      toggles = {
        { id = "board1", text = "Bird Temple" },
        { id = "board2", text = "Snake Temple" },
        { id = "board3", text = "Spider Temple" },
        { id = "board4", text = "Owl Temple" },
        { id = "board5", text = "Random",       isOn = "True" }
      }
    },
    {
      title = "Research Track",
      height = 260,
      toggles = {
        { id = "research1", text = "Bird Temple" },
        { id = "research2", text = "Snake Temple" },
        { id = "research3", text = "Monkey Temple" },
        { id = "research4", text = "Lizard Temple" },
        { id = "research5", text = "Tree Temple" },
        { id = "research6", text = "Waterfall Temple" },
        { id = "research9", text = "Randomize Temple", isOn = "True" }
      }
    }
  }

  local optionsMenuLeft = {
    tag = "TableLayout",
    attributes = {
      id                  = "optionsMenuLeft",
      active              = false,
      rectAlignment       = "LowerRight",
      offsetXY            = "-210 10",
      height              = 490,
      width               = 225,
      cellPadding         = "24 0 12 12",
      cellBackgroundColor = "clear",
      rowBackgroundColor  = "rgba(1, 1, 1, 0.85)",
    },
    children = {}
  }

  for _, section in ipairs(leftOptions) do
    -- 1. Create the base vertical layout structure for the section
    local verticalLayoutChildren = {
      {
        tag = "Text",
        attributes = {
          id        = section.title:gsub("%s+", "") .. "Title",
          fontStyle = "Bold",
          alignment = "MiddleLeft",
          text      = section.title
        }
      }
    }

    -- 2. Loop through all toggles in this section and add them to the verticalLayoutChildren
    for _, toggle in ipairs(section.toggles) do
      table.insert(verticalLayoutChildren, {
        tag        = "Toggle",
        attributes = {
          onValueChanged = "uiToggle",
          id             = toggle.id,
          text           = toggle.text,
          isOn           = toggle.isOn
        }
      })
    end

    -- 3. Construct the Row structure using the complete verticalLayoutChildren
    local row = {
      tag = "Row",
      attributes = { preferredHeight = section.height },
      children = {
        {
          tag = "Cell",
          children = {
            tag = "ToggleGroup",
            children = {
              tag      = "VerticalLayout",
              children = verticalLayoutChildren
            }
          }
        }
      }
    }

    table.insert(optionsMenuLeft.children, row)
  end

  table.insert(uiTable, optionsMenuLeft)

  --- 5. Options Menu Right Table
  local rightOptions = {
    {
      title = "Moon Staff",
      height = 95,
      group = true,
      toggles = {
        { id = "staff1", text = "Blue" },
        { id = "staff2", text = "Red", isOn = "True" },
      }
    },
    {
      title = "Leader Selection",
      height = 115,
      group = true,
      toggles = {
        { id = "leaders1", text = "Random", isOn = "True" },
        { id = "leaders2", text = "Manual" },
        { id = "leaders3", text = "None" }
      }
    },
    {
      title = "Time Tracking",
      height = 95,
      group = true,
      toggles = {
        { id = "time1", text = "Enabled", isOn = "True" },
        { id = "time2", text = "Disabled" }
      }
    },
    {
      title = "Expansion Selection",
      height = 145,
      group = false,
      toggles = {
        { id = "expeditionLeaders", text = "Expedition Leaders",     isOn = "True" },
        { id = "missingExpedition", text = "The Missing Expedition", isOn = "True" },
        { id = "twistedPaths",      text = "Twisted Paths",          isOn = "True" },
        { id = "promos",            text = "Promos",                 isOn = "True" }
      }
    }
  }

  local optionsMenuRight = {
    tag = "TableLayout",
    attributes = {
      id                  = "optionsMenuRight",
      active              = false,
      rectAlignment       = "LowerRight",
      offsetXY            = "0 10",
      height              = 490,
      width               = 210,
      cellPadding         = "0 0 12 12",
      cellBackgroundColor = "clear",
      rowBackgroundColor  = "rgba(1, 1, 1, 0.85)"
    },
    children = {}
  }

  for _, section in ipairs(rightOptions) do
    local rowContent = {
      tag = (section.group and "ToggleGroup" or "VerticalLayout"),
      children = {
        tag = "VerticalLayout",
        children = {
          {
            tag = "Text",
            attributes = {
              fontStyle = "Bold",
              alignment = "MiddleLeft",
              text      = section.title
            }
          }
        }
      }
    }

    for _, toggle in ipairs(section.toggles) do
      table.insert(rowContent.children.children, {
        tag        = "Toggle",
        attributes = {
          onValueChanged = "uiToggle",
          id             = toggle.id,
          text           = toggle.text,
          isOn           = toggle.isOn
        }
      })
    end

    table.insert(optionsMenuRight.children, {
      tag = "Row",
      attributes = { preferredHeight = section.height },
      children = {
        {
          tag = "Cell",
          children = rowContent
        }
      }
    })
  end

  -- Final empty row in optionsMenuRight
  table.insert(optionsMenuRight.children, { tag = "Row", attributes = { preferredHeight = 60 } })

  table.insert(uiTable, optionsMenuRight)

  --- 6. Options Menu Buttons Panel
  table.insert(uiTable, {
    tag = "Panel",
    attributes = {
      id            = "optionsMenuButtons",
      active        = false,
      rectAlignment = "LowerRight",
      height        = 40,
      width         = 435,
      color         = "rgba(1, 1, 1, 0.85)"
    },
    children = {
      tag = "HorizontalLayout",
      children = {
        {
          tag = "Button",
          attributes = {
            onClick   = "menuStart(1)",
            color     = "Green",
            textColor = "white",
            fontSize  = 16,
            text      = "Setup Campaign"
          }
        },
        {
          tag = "Button",
          attributes = {
            onClick   = "menuStart(2)",
            color     = "Green",
            textColor = "white",
            fontSize  = 16,
            text      = "Setup Standard Game"
          }
        }
      }
    }
  })

  --- 7. Continue Menu Table
  table.insert(uiTable, {
    tag = "TableLayout",
    attributes = {
      id                  = "continueMenu",
      active              = false,
      rectAlignment       = "LowerRight",
      offsetXY            = "0 80",
      height              = 192,
      width               = 290,
      columnWidths        = "25 135 130",
      cellPadding         = "10 10 0 0",
      cellBackgroundColor = "clear",
      rowBackgroundColor  = "rgba(1, 1, 1, 0.85)",
    },
    children = {
      {
        tag = "Row",
        attributes = { preferredHeight = 115 },
        children = {
          {
            tag = "Cell",
            attributes = { columnSpan = 3 },
            children = {
              tag = "Text",
              attributes = {
                alignment = "MiddleCenter",
                text =
                "Click 'Continue' after all players have selected different expedition leaders.\n\nTo select a leader, right-click your player board and select a state:\n\t"
              }
            }
          }
        }
      },
      {
        tag = "Row",
        attributes = { preferredHeight = 77 },
        children = {
          { tag = "Cell" },
          {
            tag = "Cell",
            children = {
              tag = "Text",
              attributes = {
                alignment = "UpperLeft",
                text = "\t1 - Captain\n\t2 - Falconer\n\t3 - Baroness\n\t4 - Professor\n\t5 - Explorer\n\t"
              }
            }
          },
          {
            tag = "Cell",
            children = {
              tag = "Text",
              attributes = {
                alignment = "UpperLeft",
                text = "\t6 - Mystic\n\t7 - Journalist\n\t8 - Mechanic\n\t9 - Random\n\t"
              }
            }
          }
        }
      }
    }
  })

  --- 8. Continue Menu Buttons Table
  local continueMenuButtonsData = {
    {
      onClick = "menuStart(4)",
      color   = "Green",
      text    = "Continue"
    },
    {
      onClick = "menuOptions",
      color   = "rgb(0.67, 0.08, 0.07)",
      text    = "Back"
    }
  }

  local continueMenuButtons = {
    tag = "TableLayout",
    attributes = {
      id                  = "continueMenuButtons",
      active              = false,
      rectAlignment       = "LowerRight",
      height              = 80,
      width               = 290,
      cellBackgroundColor = "clear",
      rowBackgroundColor  = "rgba(1, 1, 1, 0.85)"
    },
    children = {}
  }

  for _, buttonData in ipairs(continueMenuButtonsData) do
    table.insert(continueMenuButtons.children, {
      tag = "Row",
      attributes = { preferredHeight = 40 },
      children = {
        {
          tag = "Cell",
          attributes = { columnSpan = 3 },
          children = {
            tag = "Button",
            attributes = {
              onClick   = buttonData.onClick,
              color     = buttonData.color,
              textColor = "white",
              fontSize  = 16,
              text      = buttonData.text
            }
          }
        }
      }
    })
  end

  table.insert(uiTable, continueMenuButtons)

  --- 9. Solo Menu Table
  local soloMenuSliders = {
    { id = "red",    text = "Red Actions: 0",    sliderId = "redSlider",    minValue = "0", maxValue = "5", value = "0" },
    { id = "purple", text = "Purple Actions: 0", sliderId = "purpleSlider", minValue = "0", maxValue = "5", value = "0" }
  }

  local soloMenu = {
    tag        = "TableLayout",
    attributes = {
      id                  = "soloMenu",
      active              = false,
      rectAlignment       = "LowerRight",
      height              = 279,
      width               = 270,
      columnWidths        = "20 230 20",
      cellBackgroundColor = "clear",
      rowBackgroundColor  = "rgba(1, 1, 1, 0.85)"
    },
    children   = {
      { tag = "Row", attributes = { preferredHeight = 10 }, children = { { tag = "Cell" }, { tag = "Cell" }, { tag = "Cell" } } },
      {
        tag = "Row",
        attributes = { preferredHeight = 30 },
        children = {
          {
            tag = "Cell",
            attributes = { columnSpan = 3 },
            children = {
              tag = "Text",
              attributes = {
                fontStyle = "Bold",
                alignment = "MiddleCenter",
                text      = "Choose Rival Strength"
              }
            }
          }
        }
      },
    }
  }

  for _, item in ipairs(soloMenuSliders) do
    table.insert(soloMenu.children, {
      tag = "Row",
      attributes = { preferredHeight = 30 },
      children = {
        { tag = "Cell" },
        {
          tag = "Cell",
          children = {
            tag = "Text",
            attributes = {
              id        = item.id .. "Text",
              alignment = "MiddleLeft",
              text      = item.text
            }
          }
        },
        { tag = "Cell" }
      }
    })
    table.insert(soloMenu.children, {
      tag = "Row",
      attributes = { preferredHeight = 20 },
      children = {
        { tag = "Cell" },
        {
          tag = "Cell",
          children = {
            tag = "Slider",
            attributes = {
              id             = item.sliderId,
              onValueChanged = "uiSlider",
              minValue       = item.minValue,
              maxValue       = item.maxValue,
              value          = item.value,
              wholeNumbers   = "true"
            }
          }
        },
        { tag = "Cell" }
      }
    })
  end

  table.insert(soloMenu.children,
    { tag = "Row", attributes = { preferredHeight = 5 }, children = { { tag = "Cell" }, { tag = "Cell" }, { tag = "Cell" } } })

  -- Difficulty Row
  table.insert(soloMenu.children, {
    tag = "Row",
    attributes = { preferredHeight = "30" },
    children = {
      { tag = "Cell" },
      {
        tag = "Cell",
        children = {
          tag        = "Text",
          attributes = {
            id        = "rivalDifficulty",
            alignment = "MiddleLeft",
            text      = "Difficulty: 0"
          }
        }
      },
      { tag = "Cell" }
    }
  })

  -- Objectives Row and Slider
  table.insert(soloMenu.children, {
    tag = "Row",
    attributes = { preferredHeight = 30 },
    children = {
      { tag = "Cell" },
      {
        tag = "Cell",
        children = {
          tag        = "Text",
          attributes = {
            id        = "objectiveText",
            alignment = "MiddleLeft",
            text      = "Objectives: 3"
          }
        }
      },
      { tag = "Cell" }
    }
  })

  table.insert(soloMenu.children, {
    tag = "Row",
    attributes = { preferredHeight = 20 },
    children = {
      { tag = "Cell" },
      {
        tag = "Cell",
        children = {
          tag        = "Slider",
          attributes = {
            id             = "objectiveSlider",
            onValueChanged = "uiSlider",
            minValue       = 0,
            maxValue       = 4,
            value          = 3,
            wholeNumbers   = "true"
          }
        }
      },
      { tag = "Cell" }
    }
  })

  table.insert(soloMenu.children,
    {
      tag = "Row",
      attributes = { preferredHeight = 14 },
      children = {
        { tag = "Cell" },
        { tag = "Cell" },
        { tag = "Cell" }
      }
    })

  -- Start Game Button
  table.insert(soloMenu.children, {
    tag = "Row",
    attributes = { preferredHeight = 40 },
    children = {
      {
        tag = "Cell",
        attributes = { columnSpan = 3 },
        children = {
          tag = "Button",
          attributes = {
            onClick   = "menuStartSolo",
            color     = "Green",
            textColor = "white",
            fontSize  = 16,
            text      = "Start Game"
          }
        }
      }
    }
  })

  table.insert(uiTable, soloMenu)

  if round > 0 then
    TEST_VARS.hideSplash = true
  end

  -- splash screen creation
  local splashXml = {
    tag = "Panel",
    attributes = {
      id              = "SplashScreen",
      width           = 750,
      height          = 750,
      rectAlignment   = "MiddleCenter",
      backgroundColor = "rgba(0,0,0,0.9)",
      padding         = "20 20 20 20",
      image           =
      "https://steamusercontent-a.akamaihd.net/ugc/10804150965801777798/4350B9F445190EA9D8AA126C853C66EE4BDA2217/",
      active          = not TEST_VARS.hideSplash
    },
    children = {
      {
        tag = "Button",
        attributes = {
          ignoreLayout = true,
          offsetXY     = "335 335",
          width        = 40,
          height       = 40,
          fontSize     = 35,
          text         = "X",
          onClick      = "closeSplashScreen",
          colors       = "#DDDDDD|#FFFFFF|#AAAAAA|#888888"
        }
      },
      {
        tag = "Panel",
        attributes = {
          ignoreLayout = true,
          offsetXY     = "0 -250",
          width        = 700,
          height       = 200,
          color        = "#FFFFFF55"
        },
        children = {
          {
            tag = "Text",
            attributes = {
              fontSize      = 20,
              fontStyle     = "Bold",
              font          =
              "https://steamusercontent-a.akamaihd.net/ugc/11580651411710945045/C51521EBDE5474EBF3788016FF6D11C30E5D5634/",
              text          =
              [[This mod includes the 'Expedition Leaders', 'The Missing Expedition' and 'Twisted Paths' expansions.

If you encounter any broken scripts or missing textures, please report them on the Steam Workshop page or contact 'Chr1Z' on Discord.

The latest expansion required a lot of code to be rewritten, so please bear with me if something is not working. Note: Solo mode is NOT working yet!]],
              textAlignment = "LowerLeft",
              textColor     = "Black"
            }
          }
        }
      }
    }
  }

  table.insert(uiTable, splashXml)

  UI.setXmlTable(uiTable)
end

-- Function called by the button to hide the UI
function closeSplashScreen()
  UI.setAttribute("SplashScreen", "active", false)
end

function uiOff()
  UI.setAttribute('optionsMenuTop', 'active', false)
  UI.setAttribute('optionsMenuLeft', 'active', false)
  UI.setAttribute('optionsMenuRight', 'active', false)
  UI.setAttribute('optionsMenuButtons', 'active', false)
  UI.setAttribute('continueMenu', 'active', false)
  UI.setAttribute('continueMenuButtons', 'active', false)
  UI.setAttribute('soloMenu', 'active', false)
end

function menuClose()
  uiOff()
  round = -1
end

function menuOptions()
  uiOff()
  UI.setAttribute('optionsMenuTop', 'active', true)
  UI.setAttribute('optionsMenuLeft', 'active', true)
  UI.setAttribute('optionsMenuRight', 'active', true)
  UI.setAttribute('optionsMenuButtons', 'active', true)
end

function uiToggle(_, value, id)
  UI.setAttribute(id, 'isOn', value)

  if value == "True" or value == "true" or value == true then
    if (id == "board3" or id == "board4") then
      -- grey out research track selection
      UI.setAttribute("ResearchTrackTitle", "color", "#99999999")
      UI.setAttribute("ResearchTrackTitle", "text", "Research Track (disabled)")
    elseif (id == "board1" or id == "board2" or id == "board5") then
      -- enable research track selection
      UI.setAttribute("ResearchTrackTitle", "color", "Black")
      UI.setAttribute("ResearchTrackTitle", "text", "Research Track")
    end
  end
end

function uiSlider(_, value, id)
  UI.setAttribute(id, 'value', value)
  Wait.time(function()
    if id == 'objectiveSlider' then
      local objectives = UI.getAttribute('objectiveSlider', 'value')
      UI.setAttribute('objectiveText', "text", 'Objectives: ' .. objectives)
    else
      local red = UI.getAttribute('redSlider', 'value')
      local purple = UI.getAttribute('purpleSlider', 'value')
      UI.setAttribute('redText', "text", 'Red Actions: ' .. red)
      UI.setAttribute('purpleText', "text", 'Purple Actions: ' .. purple)
      local difficulty = 'N/A'
      if red + purple <= 5 then difficulty = red + 2 * purple end
      UI.setAttribute('rivalDifficulty', "text", 'Difficulty: ' .. difficulty)
    end
  end, 0.01)
end

function checkToggle(id, tbl)
  local value = false
  if UI.getAttribute(id, 'isOn') == 'True' then value = true end
  if tbl ~= nil then tbl[id] = value end
  return value
end

-- MARK: SETUP

function setupGame()
  setupInProgress = true
  AllCardsBag     = getObjectFromGUID("4bfea4")
  decks           = {}
  boards          = {}

  if options.campaign == true then
    detectSeatedPlayers()
    wait(0.1)
    if #seatedPlayerColors == 0 then return 1 end
    if #seatedPlayerColors > 3 then
      broadcastToAll("Campaign mode cannot be played with more than 2 players, please reload the mod and try again.")
      return 1
    end
    setupArtifactsItemsFear()
    wait(0.1)
    setupPlayerAreas()
    wait(0.1)
    waitForBoardLoading()
    wait(0.1)
    setupStartingResources()
    wait(0.1)
    setupCampaignMisc()
  else
    getOptionsFromUI()
    wait(0.1)
    detectSeatedPlayers()
    wait(0.1)
    if #seatedPlayerColors == 0 then return 1 end
    optionOverride()
    wait(0.1)
    setupDecks()
    wait(0.1)
    setupBoard()
    wait(0.1)
    setupMoonstaff()
    wait(0.1)
    setupArtifactsItemsFear()
    wait(0.1)
    setupResearchTrack()
    wait(0.1)
    setupPlayerAreas()
    wait(0.1)
    waitForBoardLoading()
    wait(0.1)
    setupStartingResources()
    wait(0.1)
    setupMiscThings()
  end
  return 1
end

function checkDoneSpawning()
  for _, board in pairs(boards) do
    if board.spawning or board.loading_custom then return false end
  end
  return true
end

function getOptionsFromUI()
  local expansions = { 'expeditionLeaders', 'missingExpedition', "twistedPaths", 'promos' }
  for _, expansion in ipairs(expansions) do
    checkToggle(expansion, options.expansions)
  end

  options.board = nil
  for i = 1, 4 do
    if checkToggle('board' .. i) then
      options.board = i
      break
    end
  end

  options.researchTrack = nil
  for i = 1, 6 do
    if checkToggle('research' .. i) then
      options.researchTrack = i
      break
    end
  end

  if checkToggle('leaders1') then
    options.leaders = 'random'
  elseif checkToggle('leader2') then
    options.leaders = 'choose'
  else
    options.leaders = 'none'
  end

  options.board         = options.board or math.random(4)
  options.researchTrack = options.researchTrack or math.random(6)
  options.staff         = checkToggle('staff1') and 1 or 2
  options.timeTracking  = checkToggle('time1')
end

function optionOverride()
  if options.researchTrack == 4 and options.expansions.expeditionLeaders == false and options.expansions.missingExpedition == false then
    broadcastToAll('The Lizard Temple has been selected. Expedition Leaders expansion will be used.')
    options.expansions.expeditionLeaders = true
  end

  if options.expansions.missingExpedition == true and options.expansions.expeditionLeaders == false and #seatedPlayers > 2 then
    broadcastToAll('Not enough real leaders available, enabling Expedition Leaders.')
    options.expansions.expeditionLeaders = true
  end

  -- Twisted Paths handling
  if options.board == 3 then
    broadcastToAll('The Spider Temple has been selected. Twisted Paths expansion will be used.')
    options.researchTrack = 7
    options.expansions.twistedPaths = true
  elseif options.board == 4 then
    broadcastToAll('The Owl Temple has been selected. Twisted Paths expansion will be used.')
    options.researchTrack = 8
    options.expansions.twistedPaths = true
  end
end

function detectSeatedPlayers()
  local allColors = { 'Red', 'Blue', 'Green', 'Yellow' }
  seatedPlayerColors = {}
  local absentColors = {}

  if TEST_VARS.defineSeated then
    seatedPlayers = TEST_VARS.seatedPlayers
  else
    seatedPlayers = getSeatedPlayers()
  end

  options.playerBoards = {}
  local leaders = { false, false, false, false, false, false, false, false }
  for _, color in ipairs(allColors) do
    local seated = false
    for _, seatedPlayerColor in ipairs(seatedPlayers) do
      if seatedPlayerColor == color then
        seated = true
        table.insert(seatedPlayerColors, color)
        local playerBoard = PlayermatApi.getPlayermats(color)
        local stateId = playerBoard.getStateId()
        options.playerBoards[color] = stateId
        if stateId ~= 9 then
          if leaders[stateId] then
            broadcastToAll('Duplicate expedition leaders were chosen.')
            return
          end
          leaders[stateId] = true
        end
      end
    end
    if not seated then table.insert(absentColors, color) end
  end

  if #seatedPlayerColors == 0 then
    broadcastToAll('All players must select colors before setup.')
    menuOptions()
    return
  elseif #seatedPlayerColors == 1 or options.campaign == true then
    for _, seatedPlayer in ipairs(seatedPlayerColors) do
      if seatedPlayer == 'Red' then
        broadcastToAll('Rival plays as red. Choose a different color.')
        return
      end
    end
    options.solo = true
    table.insert(seatedPlayerColors, 'Red')
    table.remove(absentColors, 1)
  end

  -- delete not seated
  for _, playerColor in ipairs(absentColors) do
    for _, object in ipairs(getObjectFromGUID(PLAYER_VARS[playerColor].allZoneGuid).getObjects()) do
      if object.getGUID() ~= "4ee1f2" then
        object.destruct()
      end
    end

    for _, name in ipairs(RESEARCH_TOKENS) do
      local token = getResearchToken(name, playerColor)
      if token ~= nil then token.destruct() end
    end
  end
end

function setupBoard()
  -- Check the current board and if its not what was chosen via options, change it
  local board = getObjectByTag("MainBoard")

  if board.getStateId() ~= options.board then
    board = board.setState(options.board)
  end

  Wait.frames(function()
    createBoardButtons(board)

    -- remove temple tile and draw reward idols when playing Owl Temple
    if options.researchTrack == 8 then
      printToAll("Owl Temple: Automatically removed idols with 2-point temple tile or card draw reward.")
      local idolDeckInfo = decks.idols.getObjects()
      for i = #idolDeckInfo, 1, -1 do
        local idolInfo = idolDeckInfo[i]
        if idolInfo.gm_notes == "p" or idolInfo.gm_notes == "d" then
          decks.idols.takeObject({ index = idolInfo.index }).destruct()
        end
      end
    end

    -- distribute idols to the tier 1 and tier 2 sites. Tier 2 sites get 2 (one face up one face down)
    local data = getBoardData()
    for _, siteType in ipairs({ "lvl1", "lvl2" }) do
      for _, site in ipairs(data[siteType]) do
        if siteType == "lvl2" or site.doubleIdol then
          decks.idols.takeObject({ position = site.pos + SITE_OFFSETS.idolLeft, rotation = faceup })
          decks.idols.takeObject({ position = site.pos + SITE_OFFSETS.idolRight, rotation = facedown })
        else
          decks.idols.takeObject({ position = site.pos + SITE_OFFSETS.idolMiddle, rotation = faceup })
        end
      end
    end
  end, 20)

  -- place dark tablet reserve
  if options.researchTrack == 7 then
    local tokenBag = getObjectFromGUID(BAG_GUIDS.miscTokens)
    local tokenData

    for _, objData in ipairs(tokenBag.getData().ContainedObjects) do
      if objData.GMNotes == "q" then
        tokenData = objData
        break
      end
    end

    if not tokenData then return end

    -- work out positions
    for i = 1, 7 do
      local bucketPos = getDarkTabletBucketPos(i)
      for j = 1, #seatedPlayerColors do
        spawnObjectData({ data = tokenData, position = bucketPos + getDarkTabletOffset(j) })
      end
    end
  end
end

function setupMoonstaff()
  local staff = getStaff()
  if not staff then return end

  -- ensure correct position
  staff.setPosition(getMarketPos(1.5) + Vector(0, 0, 0.5))

  -- check the moon staff and if its not what was chosen via options, change it
  if staff.getStateId() ~= options.staff then
    staff.setState(options.staff)
  end
end

function setupResearchTrack()
  local trackInfo = RESEARCH_TRACK_DATA[options.researchTrack]

  -- Check the research board and if its not what was chosen via options, change it
  local researchTrack = getObjectByTag("ResearchTrack")

  if researchTrack then
    if options.researchTrack == 7 or options.researchTrack == 8 then
      -- Spider / Owl Temple are build into the board
      researchTrack.destruct()
    elseif researchTrack.getStateId() ~= options.researchTrack then
      boards.researchTrack = researchTrack.setState(options.researchTrack)
    end
  end

  -- place boni
  local bonusBag = getObjectFromGUID(BAG_GUIDS.researchBonus)

  -- maybe remove Twisted Paths bonus tiles
  if not options.expansions.twistedPaths then
    local bagData = bonusBag.getData()
    for i = #bagData.ContainedObjects, 1, -1 do
      local objData = bagData.ContainedObjects[i]
      if objData.Memo == "tp" then
        bonusBag.takeObject({ index = i - 1 }).destruct()
      end
    end
  end

  bonusBag.shuffle()

  for i, list in ipairs(trackInfo.bonusPositions) do
    if i == 4 then
      for _, pos in ipairs(list) do
        for j = 1, #seatedPlayerColors do
          bonusBag.takeObject({ position = Vector(pos) + Vector(0, j * 0.1, 0), rotation = facedown })
        end
      end
    elseif i == 1 or #seatedPlayerColors > i then
      for _, pos in ipairs(list) do
        bonusBag.takeObject({ position = pos, rotation = faceup })
      end
    end
  end

  -- place temple tiles
  local tokenBag = getObjectFromGUID(BAG_GUIDS.miscTokens)
  local tileSpawnData = {}

  for _, tokenData in ipairs(tokenBag.getData().ContainedObjects) do
    if tokenData.Tags and tokenData.Tags[1] == "temple" then
      tileSpawnData[tokenData.Description] = tokenData
    end
  end

  -- special temple setup for Owl Temple
  if options.researchTrack == 8 then
    for _, data in ipairs(trackInfo.templeTileData) do
      for i, templeTilePosition in ipairs(data.positions) do
        if data.value == 10 and i == 3 and #seatedPlayerColors < 3 then
          -- skip this
        else
          spawnObjectData({
            data     = tileSpawnData[tostring(data.value)],
            position = templeTilePosition:setAt("y", tileY)
          })
        end

        -- spawn additional copies of first two 1-point tiles
        if data.value == 1 and i < 3 and #seatedPlayerColors > 1 then
          local TILE_COUNT = { 0, 1, 1, 2 } -- one copy is already spawned by the code above

          for j = 1, TILE_COUNT[#seatedPlayerColors] do
            spawnObjectData({
              data     = tileSpawnData[tostring(data.value)],
              position = templeTilePosition:setAt("y", tileY + j * 0.11)
            })
          end
        end
      end
    end

    -- super special hard-coded idol positions
    if #seatedPlayerColors > 1 then
      local IDOL_COUNT = { 0, 2, 2, 3 }
      for i = 1, IDOL_COUNT[#seatedPlayerColors] do
        decks.idols.takeObject({ position = { 20.16, 1.6, 22.46 }, rotation = facedown })
      end
    end

    decks.idols.takeObject({ position = { 8.37, 1.6, 16.72 }, rotation = facedown })
    decks.idols.takeObject({ position = { 10.54, 1.6, 16.75 }, rotation = facedown })

    -- place lanterns
    local miscBag = getObjectFromGUID(BAG_GUIDS.miscTokens)
    for i, playerColor in ipairs(seatedPlayerColors) do
      local firstChar = playerColor:sub(1, 1):lower()
      miscBag.takeObject({
        guid     = "lantern" .. firstChar,
        position = Vector(2.5 + i * 1.5, 1.65, -24.9),
        rotation = facedown
      })
    end
  else
    for _, data in ipairs(trackInfo.templeTileData) do
      for _, templeTilePosition in ipairs(data.positions) do
        for i = 1, #seatedPlayerColors do
          spawnObjectData({
            data     = tileSpawnData[tostring(data.value)],
            position = templeTilePosition:setAt("y", tileY + (i - 1) * 0.11)
          })
        end
      end
    end
  end

  -- special position for research tokens for Spider Temple / Owl Temple
  if trackInfo.researchTokenLeft then
    for i, playerColor in ipairs(COLOR_LIST) do
      local basePos = Vector.lerp(trackInfo.researchTokenLeft, trackInfo.researchTokenRight, (i - 1) / 3)
      local journal = getResearchToken("journal", playerColor)
      if journal then
        journal.setPositionSmooth(basePos)
      end

      local magnifying = getResearchToken("magnifying", playerColor)
      if magnifying then
        magnifying.setPositionSmooth(basePos + Vector(0, 0.15, 0))
      end
    end
  end

  -- maybe place assistants equal to the number of players
  if trackInfo.assistantPos then
    local newDecks = decks.assistants.cut(#seatedPlayerColors)
    wait(0.01)
    decks.assistants = newDecks[1]
    newDecks[2].setRotationSmooth({ 0, 90, 0 }, false, true)
    newDecks[2].setPositionSmooth(trackInfo.assistantPos, false, true)
  end

  -- maybe get a random artifact with 3 cost (for Monkey Temple)
  if trackInfo.artifactPos then
    for _, cardData in ipairs(decks.artifacts.getData().ContainedObjects) do
      local md = JSON.decode(cardData.GMNotes) or {}
      if md.cost == 3 then
        local card = decks.artifacts.takeObject({
          guid = cardData.GUID,
          position = trackInfo.artifactPos,
          rotation = faceup
        })
        card.lock()
        break
      end
    end
  end

  -- maybe get a random guardian
  if trackInfo.guardianPos then
    decks.guardians.takeObject({ position = trackInfo.guardianPos, rotation = facedown })
  end

  -- maybe place a site 1 location per player
  if trackInfo.site1pos then
    local newDecks = decks.sites1.cut(#seatedPlayerColors)
    wait(0.01)
    decks.sites1 = newDecks[1]
    newDecks[2].setRotationSmooth(facedown, false, true)
    newDecks[2].setPositionSmooth(trackInfo.site1pos, false, true)
  end

  -- maybe place idols equal to the number of players
  if trackInfo.idolPositions then
    for _, idolPos in ipairs(trackInfo.idolPositions) do
      for i = 1, #seatedPlayerColors do
        decks.idols.takeObject({ position = idolPos, rotation = facedown })
      end
    end
  end

  -- set idols aside
  if decks.idols ~= nil then
    decks.idols.setPosition(Vector(-5, 1.6, 39))
    decks.idols.setName("Idol Reserve")
  end

  -- maybe place waterfall tiles
  if trackInfo.waterfallPositions then
    for _, posList in ipairs(trackInfo.waterfallPositions) do
      for _, objData in ipairs(tokenBag.getData().ContainedObjects) do
        if objData.Nickname == "Waterfall" then
          tokenBag.takeObject({ guid = objData.GUID, position = posList[math.random(#posList)] })
          break
        end
      end
    end
  end
end

function setupArtifactsItemsFear()
  for _, cardType in ipairs({ "Artifact", "Item" }) do
    local cardList = {}
    -- always add base game cards
    local result = AllCardsBag.call("getCardsByExpansionAndType", { expansion = "Base Game", type = cardType })
    addCardsToList(cardList, result)

    -- maybe add cards from "Expedition Leaders"
    if options.expansions.expeditionLeaders then
      result = AllCardsBag.call("getCardsByExpansionAndType", { expansion = "Expedition Leaders", type = cardType })
      addCardsToList(cardList, result)
    end

    -- maybe add cards from "Missing Expedition"
    if options.expansions.missingExpedition then
      result = AllCardsBag.call("getCardsByExpansionAndType", { expansion = "Missing Expedition", type = cardType })
      addCardsToList(cardList, result)
    end

    -- maybe add cards from "Promo 1"
    if options.expansions.promos then
      result = AllCardsBag.call("getCardsByExpansionAndType", { expansion = "Promo 1", type = cardType })
      addCardsToList(cardList, result)
    end

    local deck = AllCardsBag.call("spawnCardList", {
      cardList = cardList,
      position = getCardBoardLocation(cardType),
      rotation = facedown
    })
    deck.setName(cardType .. " Deck")
    deck.shuffle()

    -- add deck to global index
    if cardType == "Artifact" then
      decks.artifacts = deck
    elseif cardType == "Item" then
      decks.items = deck
    end
    wait(1)
  end

  -- generate fear deck
  local cardList = {}
  for i = 1, (19 - #seatedPlayers * 2) do
    table.insert(cardList, "0000")
  end
  local deck = AllCardsBag.call("spawnCardList", {
    cardList = cardList,
    position = getCardBoardLocation("Fear"),
    rotation = faceup
  })
  deck.setName("Fear Deck")
  decks.fear = deck
end

function addCardsToList(list, cards)
  for _, v in ipairs(cards) do
    table.insert(list, v)
  end
end

function setupPlayerAreas()
  -- determine available states
  local availableLeaders = {}

  -- first 6 states come from the first expansion
  if options.expansions.expeditionLeaders then
    for i = 1, 6 do
      table.insert(availableLeaders, i)
    end
  end

  -- next two states come from the second expansion
  if options.expansions.missingExpedition then
    for i = 7, 8 do
      table.insert(availableLeaders, i)
    end
  end

  -- track manual leader selection
  if options.leaders == 'choose' then
    for _, playerColor in ipairs(seatedPlayerColors) do
      local stateId = PlayermatApi.getPlayermats(playerColor).getStateId()
      if stateId ~= 9 then
        -- remove leader from pool
        for i, id in ipairs(availableLeaders) do
          if id == stateId then
            table.remove(availableLeaders, i)
            break
          end
        end
      end
    end
  end

  local bag = getObjectFromGUID(BAG_GUIDS.miscTokens)
  local clockData
  for _, objData in ipairs(bag.getData().ContainedObjects) do
    if objData["Nickname"] == "Time" then
      clockData = objData
      clockData["Locked"] = true
      break
    end
  end

  for _, playerColor in ipairs(seatedPlayerColors) do
    if options.solo and playerColor == 'Red' then
      -- Setup the solo player board
      for _, object in ipairs(getObjectFromGUID(PLAYER_VARS[playerColor].allZoneGuid).getObjects()) do
        if object.getGUID() ~= "4ee1f2" and object.getName() ~= 'Red Archaeologist' then object.destruct() end
      end

      local soloBag = getObjectFromGUID(BAG_GUIDS.solo)
      soloBag.takeObject({
        guid              = solo.board,
        position          = solo.boardPosition,
        rotation          = faceup,
        callback_function = function(x) x.setLock(true) end
      })
    else
      -- If not the solo player board
      local playerBoard = PlayermatApi.getPlayermats(playerColor)
      if playerBoard == nil then
        broadcastToAll('Cannot find ' .. playerColor .. "'s player board. Please reload the mod.")
        return 1
      end

      -- if random leader selection is enabled OR they choose to randomize during leader picking
      if options.leaders == 'random' or (options.leaders == 'choose' and playerBoard.getStateId() == 9) then
        local leaderId = 9
        if #availableLeaders ~= 0 then
          local rand = math.random(1, #availableLeaders)
          leaderId = availableLeaders[rand]

          -- remove leader from pool
          for i, id in ipairs(availableLeaders) do
            if id == leaderId then
              table.remove(availableLeaders, i)
              break
            end
          end
        end
        options.playerBoards[playerColor] = leaderId
        if playerBoard.getStateId() ~= leaderId then playerBoard.setState(leaderId) end
      elseif options.leaders == "none" then
        options.playerBoards[playerColor] = 9
        if playerBoard.getStateId() ~= 9 then playerBoard.setState(9) end
      else
        options.playerBoards[playerColor] = playerBoard.getStateId()
      end

      -- maybe spawn clocks
      if options.timeTracking then
        clockData["Tags"] = { "NotInteractable", "Time", playerColor }
        clockData["ColorDiffuse"] = Color[playerColor]
        local pos = PLAYER_VARS[playerColor].clockPosition
        clockData.Transform.posX = pos.x
        clockData.Transform.posY = pos.y
        clockData.Transform.posZ = pos.z
        spawnObjectData({ data = clockData })
      end
    end
  end
end

function pauseClocks()
  for _, playerColor in ipairs(COLOR_LIST) do
    editClockQueue(playerColor, true)
  end
  broadcastToAll("All clocks have been paused. They will resume at the start of the next turn.")
end

function waitForBoardLoading()
  boards.board = getObjectByTag("MainBoard")

  for _, playerColor in ipairs(seatedPlayerColors) do
    boards[playerColor] = PlayermatApi.getPlayermats(playerColor)
  end

  repeat coroutine.yield(0) until checkDoneSpawning()

  for _, board in pairs(boards) do
    board.lock()
    if options.campaign == false then
      board.interactable = false
    end
  end

  drawPlayAreas()
end

function setupDecks()
  -- maybe move card reserve
  if options.researchTrack == 7 or options.researchTrack == 8 then
    getObjectFromGUID("reserve").setPosition({ 50, 1.48, 45 })
  end

  -- combine/delete expansion decks
  local searchResult = SearchLib.atPosition(getCardBoardLocation("Fear"), "isDeck")
  if #searchResult > 0 then
    decks.fear = searchResult[1]
  end

  -- Go through the expansion dictionary which holds multiple dictionaries containing the guids for various expansion decks/items
  for expansion, subTable in pairs(EXPANSION_DECKS) do
    for option, guid in pairs(subTable) do
      local expansionDeck = getObjectFromGUID(guid)
      local deck = nil
      if option == 'idols' then
        deck = getObjectFromGUID(IDOL_DECK_GUID)
      elseif option == 'assistants' then
        deck = getObjectFromGUID(ASSISTANT_DECK_GUID)
      else
        for _, object in ipairs(getObjectFromGUID(DECK_ZONE_GUIDS[option]).getObjects()) do
          if object.type == 'Deck' then
            deck = object
            break
          end
        end
      end

      if deck == nil then
        broadcastToAll('Cannot find ' .. option .. ' deck. Please reload the mod.')
        return 1
      elseif expansionDeck == nil then
        broadcastToAll('Cannot find ' .. option .. ' expansion deck. Please reload the mod.')
        return 1
      end
      deck.unlock()
      decks[option] = deck

      -- If this expansion is checked, we add the content from it to the respective deck (idols, guardians, artifacts, items, assistants, sites)
      if options.expansions[expansion] then
        deck.putObject(expansionDeck)
      else
        expansionDeck.destruct()
      end
    end
  end

  -- shuffle decks
  for _, deck in pairs(decks) do
    if deck ~= nil then
      deck.shuffle()
    end
  end
end

function setupMiscThings()
  -- remove or shuffle bonus encounter cards
  for i = 1, 5 do
    local zone = getObjectFromGUID(DECK_ZONE_GUIDS["bonus" .. i])
    for _, obj in ipairs(zone.getObjects()) do
      if obj.type == "Deck" then
        if options.expansions.missingExpedition then
          obj.shuffle()
        else
          obj.destruct()
        end
      end
      break
    end
  end

  -- distribute blocking
  local blockBag     = getObjectFromGUID(BAG_GUIDS.blocking)
  local blockMapping = { [2] = 5, [3] = 3 }
  local blockAmount  = blockMapping[#seatedPlayerColors] or 0

  if blockAmount > 0 then
    local data = getBoardData()
    local selection = { 1, 2, 3, 4, 5 }
    for i = 1, blockAmount do
      local randomIndex = math.random(1, #selection)
      local siteInfo    = data.camp[selection[randomIndex]]
      local block       = blockBag.takeObject({
        position = (siteInfo.pos + SITE_OFFSETS.spotRight):setAt("y", 1.63),
        rotation = faceup
      })
      block.lock()
      table.remove(selection, randomIndex)
    end
  end

  -- place assistants
  local totalAssistantCount = 12
  if options.expansions.expeditionLeaders then
    totalAssistantCount = totalAssistantCount + 3
  end

  if options.expansions.missingExpedition then
    totalAssistantCount = totalAssistantCount + 4
  end

  if options.expansions.twistedPaths then
    totalAssistantCount = totalAssistantCount + 8
  end

  -- snake temple has one assistant per player in a special spot
  if options.researchTrack == 2 then
    totalAssistantCount = totalAssistantCount - #seatedPlayers
  end

  -- divide by number of stacks (3) and round down
  local stackCount = math.floor(totalAssistantCount / 3 + 0.5)
  local newDecks = decks.assistants.cut(stackCount)
  wait(0.01)
  newDecks[2].setRotationSmooth(faceup, false, true)
  newDecks[2].setPositionSmooth(ASSISTANT_POSITIONS[1], false, true)

  local moreNewDecks = newDecks[1].cut(stackCount)
  wait(0.01)
  moreNewDecks[2].setRotationSmooth(faceup, false, true)
  moreNewDecks[2].setPositionSmooth(ASSISTANT_POSITIONS[2], false, true)
  moreNewDecks[1].setRotationSmooth(faceup, false, true)
  moreNewDecks[1].setPositionSmooth(ASSISTANT_POSITIONS[3], false, true)

  -- fill market
  wait(0.4)
  round = 1
  refillRowCoroutine()
  wait(0.2)
  setupButtons()
  wait(0.2)
  addAssistantCycleMenu()

  -- start player
  local firstPlayerMarker = getObjectFromGUID(TOKEN_GUIDS.firstPlayer)
  if firstPlayerMarker ~= nil then
    firstPlayerMarker.lock()
    firstPlayerMarker.setRotation(faceup)
    firstPlayerMarker.setPositionSmooth(PLAYER_VARS[firstPlayerColor].firstPlayerPosition)
  end

  if options.solo then
    UI.setAttribute('soloMenu', 'active', true)
  else
    for _, playerColor in ipairs(seatedPlayerColors) do
      if options.playerBoards[playerColor] == 3 then
        decks[playerColor].takeObject({ guid = SPECIAL_DELIVERY_GUID }).deal(1, playerColor)
        decks[playerColor].deal(4, playerColor)
      else
        decks[playerColor].deal(5, playerColor)
      end
      if options.playerBoards[playerColor] == 6 then decks.fear.deal(1, playerColor) end
      getTent(playerColor).unlock()
    end
    broadcastToAll('Starting Round 1')
    Turns.turn_color = firstPlayerColor
    Turns.enable = true
    setupInProgress = false
  end
end

function onClick_getFearCard(_, playerColor)
  getFearCard(playerColor)
end

-- Create buttons that are used for both standard play and campaign play
function setupButtonsMisc()
  -- take fear button
  local buttonBlock = getObjectFromGUID(BUTTON_BLOCK_GUID)
  local params = {
    function_owner = self,
    label          = 'Take',
    click_function = 'onClick_getFearCard',
    position       = { 0, 0, -2.9 },
    width          = 800,
    height         = 380,
    font_size      = 200
  }
  buttonBlock.createButton(params)

  -- take resources buttons
  params.label = 'Take'
  params.scale = { 2 / 1.5, 2, 2 / 1.5 }
  params.position = { 0, 0, 1.8 }
  for resource, guid in pairs(BAG_GUIDS.resources) do
    params.click_function = 'takeResource' .. resource
    getObjectFromGUID(guid).createButton(params)

    _G['takeResource' .. resource] = function(obj, clickColor, alt)
      if not doneLoading or not isSeated(clickColor) then return end
      gainResource(resource, clickColor)
    end
  end

  -- player resource bag counters creation
  params = {
    function_owner = self,
    position       = { 0, 0, 1.9 },
    width          = 700,
    height         = 700,
    font_size      = 400
  }
  for _, playerColor in ipairs(seatedPlayerColors) do
    if not (options.solo and playerColor == 'Red') then
      local vars = PLAYER_VARS[playerColor]
      for resource, guid in pairs(vars.resourceBagZones) do
        local bag = getObjectFromGUID(vars.resourceBags[resource])
        params.label = tostring(bag.getQuantity())
        params.click_function = 'clickResourceBag' .. resource .. playerColor
        getObjectFromGUID(guid).createButton(params)

        _G['clickResourceBag' .. resource .. playerColor] = function(obj, clickColor, alt)
          if not doneLoading or clickColor ~= playerColor then return end
          if alt then
            if bag.getQuantity() > 0 then
              trashObject(playerColor, bag.takeObject())
            end
          else
            gainResource(resource, clickColor)
          end
        end
      end
      if options.playerBoards[playerColor] == 4 then
        for resource, guid in pairs(SUITCASE_RESOURCE_BAG_GUIDS) do
          local bag = getObjectFromGUID(guid)
          if bag ~= nil then
            local fName    = 'clickResourceBag' .. resource .. 'Suitcase'
            local bagScale = bag.getScale()

            bag.createButton({
              function_owner = self,
              position       = { 0, 0, 1.9 / bagScale.z },
              width          = 700,
              height         = 700,
              font_size      = 400,
              label          = tostring(bag.getQuantity()),
              click_function = fName,
              scale          = Vector(1 / bagScale.x, 1 / bagScale.y, 1 / bagScale.z)
            })

            _G[fName] = function(obj, clickColor, alt)
              if not doneLoading or clickColor ~= playerColor then return end
              if alt then
                if obj.getQuantity() > 0 then
                  trashObject(playerColor, obj.takeObject())
                end
              else
                gainResource(resource, clickColor, true)
              end
            end
          end
        end
      end
    end
  end
end

--This function will do a variety of things to setup the campaign including moving campiagn related objects to the table, determining first player, etc
function setupCampaignMisc()
  local campaignBag = getObjectFromGUID(BAG_GUIDS.campaignItems)

  -- shuffle bonus encounter cards and reposition them to make space for the chapter 6 deck
  for i = 1, 5 do
    local zone = getObjectFromGUID(DECK_ZONE_GUIDS["bonus" .. i])
    for _, obj in ipairs(zone.getObjects()) do
      if obj.type == "Deck" then
        obj.setPosition(obj.getPosition() + Vector(-4.0, 0, 0))
        obj.shuffle()
      end
    end
  end

  setupButtonsMisc()

  -- place the chapter 6 encounter deck on the board
  campaignBag.takeObject({
    position = { 18.5, 1.54, 47 },
    guid     = '0ac1dc',
    smooth   = false,
    rotation = { 0, 180, 180 }
  })

  -- place the campaign book at the edge of the table
  campaignBag.takeObject({
    position          = { -27.86, 1.50, 50.34 },
    callback_function = function(x)
      x.setLock(true)
      x.setPositionSmooth({ 36, 6.80, 55 })
      x.setRotationSmooth({ 60, 180, 0 })
    end,
    smooth            = true,
    guid              = '0cf9c7',
  })

  -- place the campaign tracker at the edge of the table
  campaignBag.takeObject({
    position          = { -27.86, 1.50, 50.34 },
    callback_function = function(x)
      x.setLock(true)
      x.setPositionSmooth({ 45, 6.80, 55 })
      x.setRotationSmooth({ 60, 180, 0 })
    end,
    smooth            = true,
    guid              = 'c64617',
  })

  -- place the overview cards in two rows below the campaign book
  local overViewGuids = { '7e55f6', '2f7531', '248eeb', 'f1bd54', '78cbcd', '74971a' }
  local startLoc = { 33.0, 1.55, 47.0 }
  local newLoc = {}
  for i, g in ipairs(overViewGuids) do
    if i <= 3 then
      newLoc = { startLoc[1] + (8 * (i - 1)), startLoc[2], startLoc[3] }
    else
      newLoc = { startLoc[1] + (8 * (i - 4)), startLoc[2], 40 }
    end
    campaignBag.takeObject({
      position = newLoc,
      rotation = { 0, 180, 180 },
      smooth   = false,
      guid     = g,
    })
  end

  -- If two players are playing place the pidgeon TOKEN_GUIDS on the board
  if #seatedPlayerColors == 3 then
    campaignBag.takeObject({
      position = { -15, 1.51, 36.50 },
      smooth   = true,
      rotation = { 0, 180, 180 },
      guid     = '20c269',
    })
  end

  -- Iterate through the expansion decks and grab the decks containing the expansion content (idols, assistants, guardians, sties)
  -- Grab the decks of the base game belonging to each of those types, then add the expansion decks to the base decks
  local baseDeck = nil
  local expDeck = nil
  for key, value in pairs(EXPANSION_DECKS) do   -- Outer table containing the list of expansions
    for deckType, guidString in pairs(value) do -- Inner table containing the deck types and guids per expansion from outer table
      -- Delete the missing expedition site decks as they cannot be used in the campaign
      if key == 'missingExpedition' and (deckType == 'sites1' or deckType == 'sites2') then
        getObjectFromGUID(guidString).destruct()
        -- for idols and assistants, the base deck guids are defined as global variables and not as deck zones
      elseif deckType == 'idols' then
        baseDeck = getObjectFromGUID(IDOL_DECK_GUID)
        expDeck = getObjectFromGUID(guidString)
        baseDeck.putObject(expDeck)
      elseif deckType == 'assistants' then
        baseDeck = getObjectFromGUID(ASSISTANT_DECK_GUID)
        expDeck = getObjectFromGUID(guidString)
        baseDeck.putObject(expDeck)
      else
        -- for the other deck types, their guids are not stored but instead we have to use their deck zones to grab the deck guid
        for _, object in ipairs(getObjectFromGUID(DECK_ZONE_GUIDS[deckType]).getObjects()) do
          if object.type == 'Deck' then
            baseDeck = object
            break
          end
        end
        expDeck = getObjectFromGUID(guidString)
        baseDeck.putObject(expDeck) -- put expansion deck into base deck of the same type
      end
    end
  end

  -- Determine a first player thats not the red bot
  repeat
    startPlayerIndex = math.random(1, #seatedPlayerColors)
    firstPlayerColor = seatedPlayerColors[startPlayerIndex]
  until firstPlayerColor ~= 'Red'

  for _, playerColor in ipairs(seatedPlayerColors) do
    if playerColor ~= 'Red' then
      if options.playerBoards[playerColor] == 3 then
        -- Special handling for the Baroness
        decks[playerColor].takeObject({ guid = SPECIAL_DELIVERY_GUID }).deal(1, playerColor)
        decks[playerColor].deal(4, playerColor)
      else
        decks[playerColor].deal(5, playerColor)
      end
      if options.playerBoards[playerColor] == 6 then decks.fear.deal(1, playerColor) end
    end
  end

  local soloBag = getObjectFromGUID(BAG_GUIDS.solo)
  -- Place the bot player base action deck
  soloBag.takeObject({
    position = { -59.79, 1.50, -0.04 },
    rotation = { 0, 180, 0 },
    smooth   = true,
    guid     = solo.actionDecks[1],
  })

  -- Place the bot player advanced (green,red,purple) action deck
  soloBag.takeObject({
    position          = { -55.79, 1.50, -0.04 },
    rotation          = { 0, 180, 0 },
    smooth            = true,
    guid              = solo.actionDecks[2],
    callback_function = function(x)
      -- Iterate through the advanced deck and seperate out the different colors to be their own decks
      for _, card in ipairs(x.getObjects()) do
        if card.gm_notes == 'red' then
          x.takeObject({
            position = { -51.79, 1.50, -0.04 },
            smooth   = true,
            guid     = card.guid
          })
        elseif card.gm_notes == 'purple' then
          x.takeObject({
            position = { -47.79, 1.50, -0.04 },
            smooth   = true,
            guid     = card.guid
          })
        end
      end
    end
  })

  -- Set turn to randomized player and begin game!
  broadcastToAll('Campaign Starts!')
  Turns.turn_color = firstPlayerColor
  Turns.enable     = true
  setupInProgress  = false
  round            = 1
end

function setupStartingResources()
  -- distribute starting player decks and TOKEN_GUIDS
  local tokenBag = getObjectFromGUID(BAG_GUIDS.miscTokens)
  local refBag   = getObjectFromGUID(BAG_GUIDS.leaderRef)
  for _, playerColor in ipairs(seatedPlayerColors) do
    if options.solo and playerColor == 'Red' then -- if playing solo and this is the red player, setup the pawns
      for i, guid in ipairs(solo.pawns) do
        if i < 4 then
          local pawn = getObjectFromGUID(guid) -- setup the red pawns already on the board as part of startup board state
          if pawn ~= nil then
            pawn.setRotationSmooth(faceup, false, true)
            pawn.setPositionSmooth(solo.pawnPositions[i], false, true)
          end
        else -- take the rest of red pawns from the solo bag and set them up
          local soloBag = getObjectFromGUID(BAG_GUIDS.solo)
          soloBag.takeObject({ guid = guid, position = solo.pawnPositions[i], rotation = faceup })
        end
      end
    else
      local playerBoardState = options.playerBoards[playerColor]
      if playerBoardState ~= 1 then
        local pawn = getObjectFromGUID(PLAYER_VARS[playerColor].pawns[3])
        if pawn ~= nil then pawn.destruct() end
      end

      -- collect data for deck spawning
      local cardList
      local deckPos = PlayermatApi.getZonePosition(playerColor, "Deck")
      local boardLocation = PlayermatApi.getPlayermats(playerColor).getPosition()

      if playerBoardState == 9 then
        -- if the player board is the base board, grab the player deck for the board color
        cardList = STARTER_DECK_DATA[playerColor]
      else
        local refIndex = playerBoardState * 2 - 2
        for i = 1, 2 do
          refBag.takeObject({
            position          = PLAYER_VARS[playerColor].refPositions[i],
            rotation          = faceup,
            smooth            = false,
            callback_function = function(o)
              if refIndex ~= 0 then
                o = o.setState(refIndex + i)
                o.lock()
              end
            end
          })
        end

        getObjectFromGUID(PLAYER_VARS[playerColor].leaderOverview).Book.setPage(refIndex)

        cardList = STARTER_DECK_DATA[PLAYERMAT_STATE_TO_LEADER[playerBoardState]]

        if playerBoardState == 2 then -- Setup for the falcon
          tokenBag.takeObject({
            guid     = TOKEN_GUIDS.falcon,
            position = PlayermatApi.getZonePosition(playerColor, "Falcon" .. 2),
            rotation = FALCON_ROTATIONS[2]
          })
        elseif playerBoardState == 4 then -- Setup for the professor
          local profStuff = {}
          local suitcase = tokenBag.takeObject({
            guid     = TOKEN_GUIDS.suitcase,
            position = PlayermatApi.getZonePosition(playerColor, "Suitcase"),
            rotation = faceup
          })
          table.insert(profStuff, suitcase)

          for resource, guid in pairs(SUITCASE_RESOURCE_BAG_GUIDS) do -- Place and setup the professor's Bag
            local toPos = PlayermatApi.getZonePosition(playerColor, "Suitcase_" .. resource)
            local resourceBag = tokenBag.takeObject({
              guid     = guid,
              position = { toPos[1], 1.63, toPos[3] },
              rotation = faceup
            })
            table.insert(profStuff, resourceBag)
          end

          wait(0.3)

          for _, obj in ipairs(profStuff) do
            obj.setDescription(playerColor)
            obj.lock()
          end

          -- add cards to archive
          for i = 1, 3 do
            decks.artifacts.takeObject({
              position = PLAYER_VARS[playerColor].archivePositions[i],
              rotation = faceup,
              smooth   = false
            })
          end
        elseif playerBoardState == 5 then -- Setup for the explorer
          local pawn = getObjectFromGUID(PLAYER_VARS[playerColor].pawns[2])
          if pawn ~= nil then pawn.destruct() end
          for i, guid in ipairs(TOKEN_GUIDS.food) do
            local foodPos = PlayermatApi.getZonePosition(playerColor, "Food" .. i)
            if i == 3 then
              foodPos = { 5, 1.6, 39 }
            end
            tokenBag.takeObject({ guid = guid, position = foodPos, rotation = faceup })
          end
        elseif playerBoardState == 7 then -- Setup for the journalist
          -- Grab the newspaper token deck, shuffle, then place two newspapers into their location relative to the player board
          tokenBag.takeObject({
            guid              = TOKEN_GUIDS.journalistNewspapers,
            position          = Vector(-55.98, 1.55, 53.02),
            smooth            = true,
            callback_function = function(x)
              x.shuffle()
              x.takeObject({
                position          = boardLocation + Vector(8.82, 0.06, -0.58),
                smooth            = true,
                callback_function = function(y) y.setLock(true) end
              })
              x.takeObject({
                position          = boardLocation + Vector(14.74, 0.06, -0.59),
                smooth            = true,
                callback_function = function(y) y.setLock(true) end
              })
              x.destruct()
            end
          })
          -- As journalist place article TOKEN_GUIDS on to the player board for "featured articles". 3 or more players sets only two articles and 2 or less set all 3 articles.
          tokenBag.takeObject({
            guid              = TOKEN_GUIDS.journalistArticles,
            position          = PLAYER_VARS[playerColor].articleToothPosition,
            smooth            = true,
            callback_function = function(x)
              local count = (#seatedPlayers <= 2) and 3 or 2

              for i = 1, count do
                x.takeObject({ position = boardLocation + Vector(5.98 + i * 2.89, 0.06, 4.54) })
              end

              -- place the remaining article TOKEN_GUIDS to the left of each site
              local data = getBoardData()
              for _, siteType in ipairs({ "lvl1", "lvl2" }) do
                for _, site in ipairs(data[siteType]) do
                  if siteType == "lvl1" then
                    x.takeObject({ position = site.pos + SITE_OFFSETS.spotLvl1 + SITE_OFFSETS.left })
                  else
                    x.takeObject({ position = site.pos + SITE_OFFSETS.spotLvl2 + SITE_OFFSETS.left })
                  end
                end
              end
            end
          })
        elseif playerBoardState == 8 then -- Setup for the mechanic
          tokenBag.takeObject({
            position          = PLAYER_VARS[playerColor].articleToothPosition,
            smooth            = true,
            guid              = TOKEN_GUIDS.MechanicGoldTokens,
            rotation          = facedown,
            callback_function = function(x)
              -- shuffle golden teeth deck, split it into 4 stacks of two each and move 3 of those 4 stacks to above the player board
              x.shuffle()

              local scaleVector = Vector(1, 1, 1)
              if playerColor == "Red" or playerColor == "Yellow" then
                scaleVector = Vector(-1, 1, 1)
              end

              local offsets = {
                Vector(13.50, 0.2, 7.2):scale(scaleVector),
                Vector(16.25, 0.2, 7.2):scale(scaleVector),
                Vector(19, 0.2, 7.2):scale(scaleVector)
              }

              for _, offset in ipairs(offsets) do
                for i = 1, 2 do
                  x.takeObject({ position = boardLocation + offset })
                end
              end
            end
          })

          -- Place the mechanic monkey assistant
          tokenBag.takeObject({
            position = PlayermatApi.getZonePosition(playerColor, "Monkey"),
            smooth   = true,
            guid     = TOKEN_GUIDS.MechanicMonkey
          })
          tokenBag.takeObject({
            position          = PlayermatApi.getZonePosition(playerColor, "GoldToothAttacher"),
            rotation          = { 0, 0, 0 },
            smooth            = true,
            guid              = TOKEN_GUIDS.MechanicGoldTokenAttacher,
            callback_function = function(x) x.setLock(true) end
          })

          -- Place the spinning wheel for mechanic and lock it in place
          tokenBag.takeObject({
            position          = boardLocation + Vector(13.88, 0.05, -0.09),
            rotation          = { 0, 316.32, 0 },
            smooth            = true,
            guid              = TOKEN_GUIDS.MechanicWheel,
            callback_function = function(x) x.setLock(true) end
          })
        end
      end

      -- add two fear cards to the deck
      table.insert(cardList, "0000")
      table.insert(cardList, "0000")

      -- spawn the deck
      decks[playerColor] = AllCardsBag.call("spawnCardList", {
        cardList = cardList,
        rotation = facedown,
        position = deckPos
      })
    end
  end

  wait(0.5)

  -- shuffle decks
  for _, deck in pairs(decks) do
    if deck ~= nil then
      deck.shuffle()
    end
  end

  -- starting resources
  firstPlayerColor = 'Red'
  if not (options.solo and #seatedPlayerColors == 2) then
    startPlayerIndex = math.random(1, #seatedPlayerColors)
    firstPlayerColor = seatedPlayerColors[startPlayerIndex]
  end

  if options.solo and (options.campaign == false or options.campaign == nil) and #seatedPlayerColors == 2 then
    gainResource('c', seatedPlayerColors[1])
    gainResource('s', seatedPlayerColors[1])
  else
    local passedFirstPlayer = false
    local turnOrder = 0
    local resourcesPerTurnOrder = { { c = 2, s = 0 }, { c = 1, s = 1 }, { c = 2, s = 1 }, { c = 1, s = 2 } }
    for i = 1, 2 do
      for _, playerColor in ipairs(seatedPlayerColors) do
        if playerColor == firstPlayerColor then
          if passedFirstPlayer then break end
          passedFirstPlayer = true
        end
        if passedFirstPlayer then
          turnOrder = turnOrder + 1
          for resource, count in pairs(resourcesPerTurnOrder[turnOrder]) do
            for j = 1, count do
              gainResource(resource, playerColor)
              wait(0.1)
            end
          end
        end
      end
    end
  end
end

function menuStart(_, value, _)
  uiOff()
  closeSplashScreen()
  local menuChoice = tonumber(value)
  if menuChoice == 1 then
    -- If the player chose campaign set a variety of options then show the manual leader choosing UI
    options.campaign                     = true
    options.leaders                      = 'choose'
    options.solo                         = true
    options.expansions.expeditionLeaders = true
    options.expansions.missingExpedition = true
    options.expansions.twistedPaths      = true
    UI.setAttribute('continueMenu', 'active', true)
    UI.setAttribute('continueMenuButtons', 'active', true)
  elseif menuChoice == 2 and checkToggle('leaders2') then
    -- Only show the manual choice menu if player chose that during setup options
    UI.setAttribute('continueMenu', 'active', true)
    UI.setAttribute('continueMenuButtons', 'active', true)
  else
    startLuaCoroutine(Global, "setupGame")
  end
end

function menuStartSolo()
  local red          = tonumber(UI.getAttribute('redSlider', 'value'))
  local purple       = tonumber(UI.getAttribute('purpleSlider', 'value'))
  local actionCounts = { 5 - red - purple, red, purple }
  if red + purple > 5 then
    broadcastToAll('Cannot use more than five red and purple action cards combined.')
    return
  end

  options.objectives = tonumber(UI.getAttribute('objectiveSlider', 'value'))
  uiOff()

  function menuStartSoloCoroutine()
    local bag = getObjectFromGUID(BAG_GUIDS.solo)
    if options.objectives > 0 then
      bag.takeObject({
        guid = solo.objectives,
        position = solo.objectivePosition,
        rotation = facedown
      })
    end
    local index = 0
    for _, guid in pairs(solo.actionDecks) do
      index = index + 1
      bag.takeObject({ guid = guid, position = solo.setupPositions[index], rotation = facedown })
    end
    wait(0.4)

    local actionDeck = getObjectFromGUID(solo.actionDecks.arch)
    local otherActionCards = getObjectFromGUID(solo.actionDecks.other)
    for i = 3, 1, -1 do
      if actionCounts[i] > 0 then
        for j = 1, actionCounts[i] do
          local rand = math.random(1, #solo.actionCardTypes)
          local actionType = solo.actionCardTypes[rand]
          actionDeck.putObject(otherActionCards.takeObject({ guid = solo.actionCards[actionType][i] }))
          table.remove(solo.actionCardTypes, rand)
        end
      end
    end
    wait(1.4)
    actionDeck.setRotationSmooth(facedown, false, true)
    actionDeck.setPositionSmooth(solo.deckPositions[1], false, true)
    wait(0.5)

    actionDeck.shuffle()
    if options.objectives > 0 then getObjectFromGUID(solo.objectives).shuffle() end
    for _, playerColor in ipairs(seatedPlayerColors) do
      if playerColor ~= 'Red' then
        local deckPos = PlayermatApi.getZonePosition(playerColor, "Deck")
        for _, object in ipairs(SearchLib.atPosition(deckPos, "isDeck")) do
          object.shuffle()
          break
        end
      end
    end
    wait(0.5)

    for _, playerColor in ipairs(seatedPlayerColors) do
      if playerColor ~= 'Red' then
        local deckPos = PlayermatApi.getZonePosition(playerColor, "Deck")
        local deck = SearchLib.atPosition(deckPos, "isDeck")[1]

        if options.playerBoards[playerColor] == 3 then
          deck.takeObject({ guid = SPECIAL_DELIVERY_GUID }).deal(1, playerColor)
          deck.deal(4, playerColor)
        else
          deck.deal(5, playerColor)
        end

        if options.playerBoards[playerColor] == 6 then
          drawCardFromPosition(getCardBoardLocation("Fear")).deal(1, playerColor)
        end

        getTent(playerColor).unlock()
      end
    end
    broadcastToAll('Starting Round 1')
    setupInProgress = false
    if options.solo and #seatedPlayerColors == 2 then rivalTurnCoroutine() end
    return 1
  end

  startLuaCoroutine(Global, 'menuStartSoloCoroutine')
end

function drawPlayAreas()
  local vectorLines = {}
  for _, playerColor in ipairs(seatedPlayerColors) do
    local zone       = getObjectFromGUID(PLAYER_VARS[playerColor].playAreaZoneGuid)
    local pos        = zone.getPosition()
    local scale      = zone.getScale()
    local vectorLine = { points = {}, color = playerColor, thickness = 0.2, rotation = { 0, 0, 0 } }
    table.insert(vectorLine.points, { pos.x - scale.x / 2, 1.5, pos.z + scale.z / 2 })
    table.insert(vectorLine.points, { pos.x + scale.x / 2, 1.5, pos.z + scale.z / 2 })
    table.insert(vectorLine.points, { pos.x + scale.x / 2, 1.5, pos.z - scale.z / 2 })
    table.insert(vectorLine.points, { pos.x - scale.x / 2, 1.5, pos.z - scale.z / 2 })
    table.insert(vectorLine.points, { pos.x - scale.x / 2, 1.5, pos.z + scale.z / 2 })
    table.insert(vectorLine.points, { pos.x + scale.x / 2, 1.5, pos.z + scale.z / 2 })
    table.insert(vectorLines, vectorLine)
  end
  Global.setVectorLines(vectorLines)
end

-- MARK: BUTTONS
-- Create buttons primarily used for standard play
function setupButtons()
  local params = {
    function_owner = self,
    label          = 'Setup Round ' .. round + 1,
    click_function = 'nextRoundButton',
    position       = { 0, 1.2, 0 },
    width          = 2400,
    height         = 500,
    font_size      = 250
  }

  if round == 5 then
    params.label = 'Calculate Scores'
    params.click_function = 'calculateScoresButton'
  end

  local buttonBlock = getObjectFromGUID(BUTTON_BLOCK_GUID)
  buttonBlock.createButton(params)

  -- pause clocks button
  if options.timeTracking then
    params.label          = "Pause Clocks"
    params.click_function = "pauseClocks"
    params.position       = { 0, 1.2, 1.5 }
    buttonBlock.createButton(params)
  end

  setupButtonsMisc()

  if options.solo then setupButtonRivalTurn() end
end

function getRightMostEmptyDarkTabletSpot()
  for i = 7, 1, -1 do
    local bucketPos    = getDarkTabletBucketPos(i)
    local bucketSearch = SearchLib.inArea(bucketPos, nil, DARK_TABLET_DATA.bucketSize, "isResource")

    if #bucketSearch < #seatedPlayerColors then
      for j = 1, #seatedPlayerColors do
        local spotPos    = bucketPos + getDarkTabletOffset(j)
        local spotSearch = SearchLib.atPosition(spotPos, "isResource")
        if #spotSearch == 0 then return spotPos:setAt("y", 1.65) end
      end
    end
  end
end

function gainResource(resource, playerColor, remove)
  if resource == "q" then
    -- special handling for Dark Tablets from the Spider Temple
    if remove then
      for _, obj in ipairs(getObjectFromGUID(PLAYER_VARS[playerColor].allZoneGuid).getObjects()) do
        if obj.hasTag("resource") and obj.getGMNotes() == "q" then
          local targetPos = getRightMostEmptyDarkTabletSpot()

          obj.setRotation(faceup)
          obj.setPositionSmooth(targetPos)

          broadcastToAll(getPlayerName(playerColor) .. " returned a Dark Tablet.", "White")
          return
        end
      end

      broadcastToColor("Couldn't find Dark Tablets in your play area.", playerColor, "Red")
      return
    end

    for i = 1, 7 do
      local bucketPos = getDarkTabletBucketPos(i)
      local searchResult = SearchLib.inArea(bucketPos, nil, DARK_TABLET_DATA.bucketSize, "isResource")
      if #searchResult > 0 then
        local targetPos = getGlobalPosForIdolSlot(playerColor, 3):setAt("y", 2.5) - Vector(0, 0, 3)
        searchResult[1].setPositionSmooth(targetPos)
        broadcastToAll(getPlayerName(playerColor) .. " gained a dark tablet from slot no. " .. i .. ".")

        if #searchResult == 1 then
          printToAll("Dark Tablet VP updated to " .. DARK_TABLET_DATA.bucketVp[i], "White")
        end
        return
      end
    end

    broadcastToAll("Couldn't locate Dark Tablets!", "Red")
    return
  end

  local fromBag = getObjectFromGUID(BAG_GUIDS.resources[resource])
  if fromBag == nil then return end

  if remove then
    local toBag = getObjectFromGUID(SUITCASE_RESOURCE_BAG_GUIDS[resource])
    if toBag == nil then return end
    toBag.putObject(fromBag.takeObject())
  else
    local toBag = getObjectFromGUID(PLAYER_VARS[playerColor].resourceBags[resource])
    if toBag == nil then return end
    toBag.putObject(fromBag.takeObject())
  end
end

function getFearCard(playerColor)
  if not doneLoading or not isSeated(playerColor) then return end
  local card    = drawCardFromPosition(getCardBoardLocation("Fear")) or getObjectFromGUID(BAG_GUIDS.fear).takeObject()
  local toPos   = getObjectFromGUID(PLAYER_VARS[playerColor].playAreaZoneGuid).getPosition()
  local xOffset = 16.5
  if playerColor == 'Red' or playerColor == 'Yellow' then xOffset = 0 - xOffset end
  card.setPositionSmooth({ toPos[1] + xOffset, tableY + 0.5, toPos[3] }, false, true)
end

-- helper function to get the metadata for a card
function getMetaData(card)
  if card.type ~= "Card" then return {} end

  local md = JSON.decode(card.getGMNotes()) or {}
  if md.type == "Item" then
    md.resource = "coin"
  elseif md.type == "Artifact" then
    md.resource = "compass"
  end
  return md
end

function buyFromMarket(playerColor, marketPos, isRightClick)
  if not doneLoading or setupInProgress or movingRow or not isSeated(playerColor) then return end

  movingRow = true
  Wait.time(function() movingRow = false end, 0.5)

  local card        = drawCardFromPosition(marketPos)
  local vars        = PLAYER_VARS[playerColor]
  local coloredName = getPlayerName(playerColor)

  if not card then return end

  local md = getMetaData(card)
  local suffix
  if md.resource == "compass" then
    suffix = ' compass' .. (md.cost > 1 and "es" or "")
  elseif md.resource == "coin" then
    suffix = ' coin' .. (md.cost > 1 and "s" or "")
  end

  if isRightClick then
    -- right-click -> "buy": automatically remove resources
    local bag
    if md.resource == "compass" then
      bag = getObjectFromGUID(vars.resourceBags.s)
    elseif md.resource == "coin" then
      bag = getObjectFromGUID(vars.resourceBags.c)
    end

    if bag.getQuantity() < md.cost then
      broadcastToColor('You do not have enough' .. suffix .. ' to buy ' .. card.getName() .. ".", playerColor)
      return
    end

    broadcastToAll(coloredName .. ' spends ' .. md.cost .. suffix .. ' to buy ' .. card.getName() .. ".")
    for i = 1, md.cost do
      Wait.time(function() trashObject(playerColor, bag.takeObject()) end, i * 0.1)
    end
  end

  if md.type == "Artifact" then
    local toPos = getObjectFromGUID(vars.playAreaZoneGuid).getPosition()
    local xOffset = 11.5
    if playerColor == 'Red' or playerColor == 'Yellow' then
      xOffset = 0 - xOffset
    end
    DeckLib.placeOrMergeIntoDeck(card, Vector(toPos[1] + xOffset, tableY + 0.5, toPos[3]))
  else
    local deckPos = PlayermatApi.getZonePosition(playerColor, "Deck")
    DeckLib.placeOrMergeIntoDeck(card, deckPos, facedown, true)
  end
  broadcastToAll(coloredName .. ' bought ' .. card.getName() .. ' (' .. md.cost .. suffix .. ").")
end

-- i goes from 1 to 6
function getMarketPos(i)
  local data = getBoardData()
  return Vector.lerp(data.marketStart, data.marketEnd, (i - 1) / 5)
end

-- i goes from 1 to 7
function getDarkTabletBucketPos(i)
  return Vector.lerp(DARK_TABLET_DATA.leftBucketPos, DARK_TABLET_DATA.rightBucketPos, (i - 1) / 6)
end

-- i goes from 1 to 4
function getDarkTabletOffset(i)
  local xMult = 1
  if i == 1 or i == 3 then
    xMult = -1
  end

  local zMult = 1
  if i == 3 or i == 4 then
    zMult = -1
  end

  return Vector(DARK_TABLET_DATA.offsetX / 2 * xMult, 0, DARK_TABLET_DATA.offsetZ / 2 * zMult)
end

function refillRowCoroutine()
  if movingRow then return 1 end
  movingRow = true
  Wait.time(function() movingRow = false end, 0.5)

  -- get cards/decks in the row
  local artifacts = {}
  local items     = {}

  for i = 1, 6 do
    local searchResult = SearchLib.atPosition(getMarketPos(i), "isCard")
    if #searchResult > 0 then
      if i <= round then
        table.insert(artifacts, searchResult[1])
      else
        table.insert(items, searchResult[1])
      end
    end
  end

  if #artifacts < round or #items < 6 - round then
    -- shift
    if #artifacts > 0 and #artifacts < round then
      for i = 1, #artifacts do
        artifacts[#artifacts - i + 1].setPositionSmooth(getMarketPos(round - i + 1):setAt("y", tileY), false, true)
      end
    end

    if #items > 0 and #items < 6 - round then
      for i = 1, #items do
        items[i].setPositionSmooth(getMarketPos(round + i):setAt("y", tileY), false, true)
      end
    end

    if #artifacts > 0 and #artifacts < round or #items > 0 and #items < 6 - round then wait(0.26) end

    -- refill
    if #artifacts < round then
      for i = 1, round - #artifacts do
        local card = drawCardFromPosition(getCardBoardLocation("Artifact"), getMarketPos(i):setAt("y", tileY), faceup)
        if card == nil then break end
        wait(0.16)
      end
    end

    if #items < 6 - round then
      for i = round + #items + 1, 6 do
        local card = drawCardFromPosition(getCardBoardLocation("Item"), getMarketPos(i):setAt("y", tileY), faceup)
        if card == nil then break end
        wait(0.16)
      end
    end
    wait(0.2)
  end
  return 1
end

function getAvailableArcheologist(playerColor)
  if options.playerBoards[playerColor] == 5 then
    local pawn = getObjectByName(playerColor .. " Archaeologist")
    if pawn ~= nil then return pawn end
    broadcastToColor('Your archaeologist was not found.', playerColor)
  else
    for _, obj in ipairs(SearchLib.onObject(getTent(playerColor))) do
      if obj.hasTag('pawn') and obj.getDescription() == playerColor then
        return obj
      end
    end
    broadcastToColor('No archaeologists found on your tent.', playerColor)
  end
end

function getTent(playerColor)
  for _, tent in ipairs(getObjectsWithTag("tent")) do
    local tentColor = PlayermatApi.getMatColorByPosition(tent.getPosition())
    if tentColor == playerColor then
      return tent
    end
  end
end

function getResearchToken(type, playerColor)
  if type == "magnifying" then type = "Magnifying Glass" end
  if type == "journal" then type = "Journal" end
  if type == "lantern" then type = "Lantern" end
  return getObjectByName(playerColor .. " " .. type)
end

function getLocalIdolSlotPositions(playerColor)
  local mat               = PlayermatApi.getPlayermats(playerColor)
  local idolSnapPositions = {}

  for _, snap in ipairs(mat.getSnapPoints()) do
    if snap.tags[1] == "idol" then
      table.insert(idolSnapPositions, snap.position)
    end
  end

  table.sort(idolSnapPositions, function(a, b) return a.x > b.x end)

  return idolSnapPositions
end

function getGlobalPosForIdolSlot(playerColor, points)
  local mat               = PlayermatApi.getPlayermats(playerColor)
  local idolSnapPositions = getLocalIdolSlotPositions(playerColor)
  local leader            = PLAYERMAT_STATE_TO_LEADER[options.playerBoards[playerColor]]

  for i, slotPoints in ipairs(IDOL_SLOT_DATA[leader]) do
    if slotPoints == points then
      return mat.positionToWorld(idolSnapPositions[i])
    end
  end
end

TEXT_REWARDS = {
  ["u"] = ' may upgrade one resource.',
  ["o"] = ' may gain 1 coin or 1 compass.',
  ["r"] = ' may refresh an assistant.',
  ["y"] = ' gets to use the effect on the silver side of one assistant available in the supply.',
  ["z"] = ' gets to use the effect on the gold side of one assistant available in the supply.',
  ["e"] = ' may exile a card.',
  ["i"] = ' may return two compasses to take an item for free.',
  ["m"] = ' may activate a campsite.',
  ["g"] = ' may flip an expended guardian for reuse.',
  ["%"] = ' may gain the reward from an available idol on the board.',
  ["~"] = ' may discard a card to gain a dark tablet.',
  ["#"] = ' may pay a coin to gain a dark tablet.',
  ["$"] = ' may take a Fear card to get a dark tablet.',
  ["p"] = ' may take one 2-point temple tile from any stack for free.'
}

-- function that checks the gm notes to determine what rewards the player should get
function deliverRewards(playerColor, obj, str)
  local rewards = obj and obj.getGMNotes() or str
  if not rewards or rewards == "" then return true end

  local resourceLabels     = { t = 'tablet', a = 'arrowhead', j = 'jewel', c = 'coin', s = 'compass', q = 'dark tablet' }
  local resourceCount      = {}
  local deliveredAll       = true
  local deliveredResources = false
  local p                  = getPlayerName(playerColor)

  for i = 1, string.len(rewards) do
    local reward = string.sub(rewards, i, i)

    -- these resources are automatically given to the player
    if resourceLabels[reward] ~= nil then
      gainResource(reward, playerColor)
      resourceCount[reward] = (resourceCount[reward] or 0) + 1
      deliveredResources = true

      -- for these rewards the player must manually take action on
    elseif tonumber(reward) then
      -- draw a card from the respective bonus deck
      local card = drawCard(DECK_ZONE_GUIDS["bonus" .. tonumber(reward)])
      if card ~= nil then card.deal(1, playerColor) end
      broadcastToAll(p .. ' has to choose an option from the dealt bonus card.')
      deliveredAll = false
    elseif TEXT_REWARDS[reward] then
      broadcastToAll(p .. TEXT_REWARDS[reward])
      deliveredAll = false
    elseif reward == "*" then
      local bag = getObjectFromGUID(PLAYER_VARS[playerColor].resourceBags.c)
      if not bag or bag.getQuantity() == 0 then
        broadcastToColor("You do not have 1 coin to get a jewel.", playerColor)
      else
        broadcastToAll(p .. " pays a coin to get a jewel.")
        trashObject(playerColor, bag.takeObject())
        gainResource("j", playerColor)
      end
    elseif reward == 'f' then
      -- exception for miners helmet (but not for idols)
      if (obj and obj.hasTag("idol")) or not hasMinersHelmetActive(playerColor) then
        broadcastToAll(p .. ' gets a Fear card.')
        getFearCard(playerColor)
      else
        broadcastToAll(p .. " does not get a Fear card due to an active Miner's Helmet.")
      end
    elseif reward == 'd' then
      PlayermatApi.drawCard(playerColor)
    end
  end

  if deliveredResources then
    local message = p .. ' gets '
    local textList = {}
    for code, count in pairs(resourceCount) do
      local label = resourceLabels[code]
      if count > 1 then
        if code == 's' then
          label = 'compasses'
        else
          label = label .. 's'
        end
      end
      table.insert(textList, count .. ' ' .. label)
    end
    broadcastToAll(message .. listToText(textList) .. '.')
  end

  return deliveredAll
end

function setupButtonRivalTurn()
  local buttonZone = getObjectFromGUID(PLAYER_VARS.Red.playAreaZoneGuid)
  local scale = buttonZone.getScale()
  if buttonZone.getButtons() == nil or #buttonZone.getButtons() == 0 then
    local params = {
      function_owner = self,
      label          = buttonLabelsRival.ready,
      click_function = 'rivalTurnButton',
      scale          = { 2 / scale[1], 1 / scale[2], 2 / scale[3] },
      position       = { 15.5 / scale[1], -0.44, 3.65 / scale[3] },
      width          = 1800,
      height         = 500,
      font_size      = 250
    }
    buttonZone.createButton(params)
  else
    buttonZone.editButton({ index = 0, label = buttonLabelsRival.ready })
  end
end

-- MARK: ROUNDS

function getWarMaskOwner()
  for _, playerColor in ipairs(seatedPlayerColors) do
    if not (options.solo and playerColor == 'Red') then
      for _, object in ipairs(getObjectFromGUID(PLAYER_VARS[playerColor].playAreaZoneGuid).getObjects()) do
        if object.getName() == 'War Mask' then
          if object.is_face_down then
            return ""
          end
          return playerColor
        end
      end
    end
  end
  return ""
end

function resolveFearFromGuardians()
  local warMaskOwner = getWarMaskOwner()

  local data = getBoardData()
  for _, siteType in ipairs({ "camp", "lvl1", "lvl2" }) do
    for _, site in ipairs(data[siteType]) do
      local searchResult = SearchLib.atPosition(site.pos, "isGuardian")
      if #searchResult > 0 then
        for _, pawn in ipairs(getSitePawns(site.pos, (siteType == "lvl2") and 2 or nil)) do
          local playerColor = pawn.getDescription()
          if warMaskOwner ~= playerColor and not (options.solo and playerColor == "Red") then
            broadcastToAll(getPlayerName(playerColor) .. ' gets a Fear card from a guardian.')
            getFearCard(playerColor)
          end
        end
      end
    end
  end

  if options.researchTrack == 4 then
    -- handle Lizard Temple guardian
    local searchResult = SearchLib.atPosition(RESEARCH_TRACK_DATA[4].guardianPos, "isGuardian")
    if #searchResult > 0 and not searchResult[1].is_face_down then
      for _, playerColor in ipairs(seatedPlayerColors) do
        if not (options.solo and playerColor == 'Red') and warMaskOwner ~= playerColor then
          for _, name in ipairs(RESEARCH_TOKENS) do
            local token = getResearchToken(name, playerColor)
            if token ~= nil then
              local posZ = token.getPosition()[3]
              if posZ < RESEARCH_TRACK_DATA[4].rows[4].z and posZ > RESEARCH_TRACK_DATA[4].rows[5].z then
                broadcastToAll(getPlayerName(playerColor) .. ' gets Fear from the temple guardian.')
                getFearCard(playerColor)
              end
            end
          end
        end
      end
    end
  end
end

-- helper function to detect if a player has a faceup miners helmet in his play area
function hasMinersHelmetActive(playerColor)
  for _, object in ipairs(getObjectFromGUID(PLAYER_VARS[playerColor].playAreaZoneGuid).getObjects()) do
    if object.getName() == "Miner's Helmet" then
      return not object.is_face_down
    end
  end
  return false
end

function getStaff()
  local staffList = getObjectsWithTag("staff")
  if #staffList == 0 then
    broadcastToAll("Staff not found.")
    return nil
  end

  if #staffList > 1 then
    broadcastToAll("Multiple staffs found!")
  end
  return staffList[1]
end

function goesInDeck(object)
  if object == nil then return false end

  local excludeTags = { 'assistant', 'idol', 'site1', 'site2', 'guardian', "SpecialDelivery" }

  local cardTags = nil
  if object.type == 'Card' then
    cardTags = object.getTags()
  else
    cardTags = object.tags
  end

  if not cardTags or #cardTags == 0 then return true end

  for _, tag in ipairs(excludeTags) do
    if cardTags[1] == tag then return false end
  end

  return true
end

function nextRoundCoroutine()
  setupInProgress = true
  refillRowCoroutine()
  resolveFearFromGuardians()

  -- reset tents
  for _, tent in ipairs(getObjectsWithTag("tent")) do
    if tent.is_face_down then
      tent.flip()
    end
  end

  wait(0.6)

  -- return pawns and TOKEN_GUIDS
  for _, playerColor in ipairs(seatedPlayerColors) do
    local pawns         = PLAYER_VARS[playerColor].pawns
    local pawnPositions = PLAYER_VARS[playerColor].pawnPositions
    if options.solo and playerColor == 'Red' then
      pawns = solo.pawns
      pawnPositions = solo.pawnPositions
    end

    for i, guid in ipairs(pawns) do
      local pawn = getObjectFromGUID(guid)
      if pawn ~= nil then
        pawn.setRotationSmooth(faceup, false, true)
        pawn.setPositionSmooth(pawnPositions[i], false, false)
      end
    end

    -- snack token handling for Explorer
    if options.playerBoards[playerColor] == 5 then
      for i, guid in ipairs(TOKEN_GUIDS.food) do
        if i < 3 or round > 1 then
          local food = getObjectFromGUID(guid)
          if food ~= nil then
            food.setRotation(faceup)

            local foodPos = PlayermatApi.getZonePosition(playerColor, "Food" .. i)
            food.setPositionSmooth(foodPos, false, false)
          end
        end
      end
    end
  end

  wait(0.5)

  for _, playerColor in ipairs(seatedPlayerColors) do
    if not (options.solo and playerColor == 'Red') then
      local cards = {}
      for _, object in ipairs(getObjectFromGUID(PLAYER_VARS[playerColor].playAreaZoneGuid).getObjects()) do
        if object.type == 'Card' then
          if goesInDeck(object) then
            object.setRotation(facedown)
            table.insert(cards, object)
          end
        elseif object.type == 'Deck' then
          -- check deck contents in case assistants/idols/sites/guardians were grouped
          local guidsToMove = {}
          for _, card in ipairs(object.getObjects()) do
            if goesInDeck(card) then table.insert(guidsToMove, card.guid) end
          end

          -- ttsbug(?): if object disappears inside this for-loop, object becomes a non-nil reference that doesn't have an instance
          -- so get the deck/object each time a card needs to be removed from it
          local deckGuid = object.getGUID()
          for _, guid in ipairs(guidsToMove) do
            local deck = getObjectFromGUID(deckGuid)
            local cardToMove = nil
            if deck == nil then
              cardToMove = getObjectFromGUID(guid)
              cardToMove.setRotation(facedown)
            else
              cardToMove = deck.takeObject({ guid = guid, rotation = facedown })
            end
            wait(0.01)
            table.insert(cards, cardToMove)
          end
        end
      end

      -- group the cards, shuffle them and put below deck
      if #cards > 0 then
        local list = group(cards)
        wait(0.3)
        list[1].shuffle()

        local deckPos = PlayermatApi.getZonePosition(playerColor, "Deck")
        DeckLib.placeOrMergeIntoDeck(list[1], deckPos, facedown, true)
      end
    end
  end

  if options.solo then
    local toPos = solo.deckPositions[1]
    for _, object in ipairs(getObjectFromGUID(solo.zones.discard).getObjects()) do
      if object.type == 'Card' or object.type == 'Deck' then
        object.setRotation(facedown)
        object.setPositionSmooth({ toPos[1], tileY + 0.2, toPos[3] }, false, true)
      end
    end

    if options.objectives > 0 then
      for _, guid in ipairs(solo.zones.objectives) do
        for _, object in ipairs(getObjectFromGUID(guid).getObjects()) do
          if object.type == 'Card' or object.type == 'Deck' then
            object.setRotation(facedown)
            object.setPositionSmooth(solo.objectivePosition, false, true)
          end
        end
      end
    end
  end

  wait(0.4)

  -- get income
  for _, playerColor in ipairs(seatedPlayerColors) do
    if options.playerBoards[playerColor] == 2 then
      local falcon = getObjectFromGUID(TOKEN_GUIDS.falcon)
      local falconPosIndex = nil
      if falcon ~= nil then
        local currentPos = falcon.getPosition()
        for i = 1, 5 do
          local falconPos = PlayermatApi.getZonePosition(playerColor, "Falcon" .. i)
          if positionIsClose(falconPos, currentPos) then
            falconPosIndex = i
            break
          end
        end
      end

      if falconPosIndex == nil then
        broadcastToAll('Unable to locate falcon.', playerColor)
      elseif falconPosIndex < 5 then
        broadcastToAll(getPlayerName(playerColor) .. ' moves their falcon.')
        falcon.setRotationSmooth(FALCON_ROTATIONS[falconPosIndex + 1], false, true)
        falcon.setPositionSmooth(PlayermatApi.getZonePosition(playerColor, "Falcon" .. falconPosIndex + 1), false, true)
      end
      wait(0.5)
    elseif options.playerBoards[playerColor] == 3 then
      broadcastToAll(getPlayerName(playerColor) .. ' gets income of 1 coin.')
      gainResource('c', playerColor)
      wait(0.5)
    elseif options.playerBoards[playerColor] == 4 then
      local resource = 's'
      local resourceLabel = 'compass'
      if round == 2 or round == 4 then
        resource = 't'
        resourceLabel = 'tablet'
      end
      broadcastToAll(getPlayerName(playerColor) .. ' adds 1 ' .. resourceLabel .. ' to their suitcase.')
      gainResource(resource, playerColor, true)
      wait(0.5)
    end
  end

  if options.solo then
    for _, object in ipairs(getObjectFromGUID(solo.zones.deck).getObjects()) do
      if object.type == 'Deck' then
        object.shuffle()
        break
      end
    end

    if options.objectives > 0 then
      for _, object in ipairs(getObjectFromGUID(solo.zones.objectivesDeck).getObjects()) do
        if object.type == 'Deck' then
          object.shuffle()
          break
        end
      end
    end
  end

  wait(0.2)

  -- refresh assistants
  for _, playerColor in ipairs(seatedPlayerColors) do
    if not (options.solo and playerColor == 'Red') then
      for _, object in ipairs(getObjectFromGUID(PLAYER_VARS[playerColor].allZoneGuid).getObjects()) do
        if object.hasTag('assistant') then
          local rotation = object.getRotation():setAt("y", 180)
          object.setRotationSmooth(rotation, false, false)
        end
      end
    end
  end

  -- card row
  local rowStart = round - options.staff + 1
  if rowStart < 1 then rowStart = 1 end
  local rowEnd = round + options.staff
  if rowEnd > 6 then rowEnd = 6 end
  for i = rowStart, rowEnd do
    local waitUntilAfterSetPos = exile(drawCardFromPosition(getMarketPos(i)))
    if waitUntilAfterSetPos then wait(0.16) end
    wait(0.16)
  end
  wait(0.4)
  round = round + 1

  -- move staff
  local staff = getStaff()
  if staff then
    staff.setPositionSmooth(getMarketPos(round + 0.5) + Vector(0, 0, 0.5), false, true)
  end

  wait(0.5)
  refillRowCoroutine()

  -- starting player
  firstPlayerColor = nil
  if not (options.solo and #seatedPlayerColors == 2) then
    startPlayerIndex = startPlayerIndex + 1
    if startPlayerIndex > #seatedPlayerColors then startPlayerIndex = 1 end
    firstPlayerColor = seatedPlayerColors[startPlayerIndex]
    local token = getObjectFromGUID(TOKEN_GUIDS.firstPlayer)
    if token ~= nil then
      token.setPositionSmooth(PLAYER_VARS[firstPlayerColor].firstPlayerPosition)
    end
  end
  wait(0.4)

  -- draw up to 5 cards
  for _, playerColor in ipairs(seatedPlayerColors) do
    if not (options.solo and playerColor == 'Red') then
      local handSize = 5
      local drawn = #Player[playerColor].getHandObjects()
      if options.playerBoards[playerColor] == 3 then
        -- return special delivery to the hand of the Baroness
        local specialDelivery = getObjectFromGUID(SPECIAL_DELIVERY_GUID)
        if specialDelivery == nil then
          local deckPos = PlayermatApi.getZonePosition(playerColor, "Deck")
          for _, object in ipairs(SearchLib.atPosition(deckPos, "isDeck")) do
            specialDelivery = object.takeObject({ guid = SPECIAL_DELIVERY_GUID })
            break
          end
        end

        if specialDelivery == nil then
          for _, object in ipairs(SearchLib.atPosition(OTHER_EXILED_SPOT.pos, "isDeck")) do
            specialDelivery = object.takeObject({ guid = SPECIAL_DELIVERY_GUID })
            break
          end
        end

        if specialDelivery ~= nil then
          specialDelivery.deal(1, playerColor)
          drawn = drawn + 1
          wait(0.01)
        end
      end

      local deckPos = PlayermatApi.getZonePosition(playerColor, "Deck")
      for _, object in ipairs(SearchLib.atPosition(deckPos, "isCardOrDeck")) do
        if drawn >= handSize then break end
        if object.type == 'Card' then
          object.deal(1, playerColor)
          drawn = drawn + 1
        elseif object.type == 'Deck' then
          local numberToDraw = handSize - drawn
          if object.getQuantity() >= numberToDraw then
            drawn = drawn + numberToDraw
          else
            drawn = drawn + object.getQuantity()
          end
          object.deal(numberToDraw, playerColor)
        end
      end

      if options.playerBoards[playerColor] == 6 and drawn < 6 then
        local card = drawCardFromPosition(getCardBoardLocation("Fear"))
        if card == nil then
          broadcastToAll('No fear cards left for ' .. getPlayerName(playerColor) .. ' to draw.')
        else
          broadcastToAll(getPlayerName(playerColor) .. ' draws a fear card.')
          card.deal(1, playerColor)
        end
        wait(0.5)
      end
    end
  end

  broadcastToAll('Starting Round ' .. round)
  if not (options.solo and #seatedPlayerColors == 2) then Turns.turn_color = firstPlayerColor end

  local buttonBlock = getObjectFromGUID(BUTTON_BLOCK_GUID)
  if round == 5 then
    buttonBlock.editButton({ index = 0, label = buttonLabels.ready1, click_function = 'calculateScoresButton' })
  else
    buttonBlock.editButton({ index = 0, label = 'Setup Round ' .. round + 1 })
  end

  setupInProgress = false

  if options.solo then
    soloStatus.firstTurn = true
    soloStatus.fulfilledObjectives = {}
    soloStatus.pawnsOut = 0
    if #seatedPlayerColors == 2 then rivalTurnCoroutine() end
  end

  return 1
end

function nextRoundButton(obj, clickColor, alt)
  local soloMenuActive = UI.getAttribute('soloMenu', 'active')
  if soloMenuActive == "false" or soloMenuActive == "False" then
    soloMenuActive = false
  elseif soloMenuActive == "true" or soloMenuActive == "True" then
    soloMenuActive = true
  end

  if (not isSeated(clickColor) and clickColor ~= 'Black') or movingRow or setupInProgress or soloMenuActive then return end

  if options.solo then
    local button = getObjectFromGUID(PLAYER_VARS.Red.playAreaZoneGuid).getButtons()[1]
    if button.label == buttonLabelsRival.busy then return end
  end

  -- check for hand cards and prompt to continue
  local emptyHands = true
  for _, playerColor in ipairs(seatedPlayerColors) do
    for _, handObj in pairs(Player[playerColor].getHandObjects()) do
      if handObj.type == "Card" then
        emptyHands = false
        break
      end
    end
  end

  if emptyHands then
    startLuaCoroutine(Global, 'nextRoundCoroutine')
  else
    local dialogColor = findRealPlayerColor(clickColor)
    Player[dialogColor].showConfirmDialog("Some players have cards in their hand. Continue?",
      function() startLuaCoroutine(Global, 'nextRoundCoroutine') end)
  end
end

-- this attempts to find the first instance of a player to handle hotseat mess
function findRealPlayerColor(searchColor)
  local searchSteamId = Player[searchColor].steam_id
  for _, playerColor in ipairs(getSeatedPlayers()) do
    if Player[playerColor].steam_id == searchSteamId then
      return playerColor
    end
  end
  return searchColor
end

-- MARK: SCORING

function calculateScoresButton(buttonZone, clickColor, alt)
  if not doneLoading or not isSeated(clickColor) and clickColor ~= 'Black' then return end
  local button = buttonZone.getButtons()[1]
  if button.label == buttonLabels.ready1 or button.label == buttonLabels.ready2 then
    broadcastToAll('Are you sure you want to calculate scores?')

    Wait.time(function()
      if options.researchTrack == 7 then
        broadcastToAll("Make sure that all unused dark tablets are returned to the dark tablet supply!")
      end
    end, 0.5)

    Wait.time(function() buttonZone.editButton({ index = 0, label = buttonLabels.confirm }) end, 0.2)
    resetScoringButton(buttonZone, buttonLabels.confirm, button.label)
  elseif button.label == buttonLabels.confirm then
    buttonZone.editButton({ index = 0, label = buttonLabels.busy })
    printToAll(getPlayerName(clickColor) .. ' calculated scores.')
    calculateScores()
    resetScoringButton(buttonZone)
  end
end

function resetScoringButton(buttonZone, conditionalLabel, resetLabel)
  Wait.time(function()
    if conditionalLabel ~= nil then
      local button = buttonZone.getButtons()[1]
      if button.label == buttonLabels.confirm then
        buttonZone.editButton({ index = 0, label = resetLabel })
      end
    else
      buttonZone.editButton({ index = 0, label = buttonLabels.ready2 })
    end
  end, 4)
end

function getVpValue(notes)
  if notes == nil or notes == "" or string.sub(notes, 1, 1) ~= '{' then return 0 end
  local md = JSON.decode(notes) or {}
  return md.points or 0
end

function findPurpleSiteActionCard(zoneGuid)
  for _, object in ipairs(getObjectFromGUID(zoneGuid).getObjects()) do
    if object.type == 'Card' then
      if object.getDescription() == 'site' and object.getGMNotes() == 'purple' then return true end
    elseif object.type == 'Deck' then
      for _, card in ipairs(object.getObjects()) do
        if card.description == 'site' and card.gm_notes == 'purple' then return true end
      end
    end
  end
  return false
end

function countIdols(zoneGuid)
  local count = 0
  for _, object in ipairs(getObjectFromGUID(zoneGuid).getObjects()) do
    if object.type == 'Card' then
      if object.hasTag('idol') then count = count + 1 end
    elseif object.type == 'Deck' then
      for _, card in ipairs(object.getObjects()) do
        if #card.tags > 0 and card.tags[1] == 'idol' then count = count + 1 end
      end
    end
  end
  return count
end

function getDarkTabletValue()
  if options.researchTrack ~= 7 then return 0 end

  local val = 0
  for i = 1, 7 do
    local bucketPos = getDarkTabletBucketPos(i)
    local searchResult = SearchLib.inArea(bucketPos, nil, DARK_TABLET_DATA.bucketSize, "isResource")
    if #searchResult == 0 then
      val = DARK_TABLET_DATA.bucketVp[i]
    else
      return val
    end
  end
  return val
end

function getAltarWinners(altarTablets)
  local winners = {}
  local maxVal  = 0

  for playerColor, score in pairs(altarTablets) do
    if score > maxVal then
      -- Found a new leader: clear the old list and update maxVal
      maxVal = score
      winners = { playerColor }
    elseif score == maxVal then
      -- Tied with the current leader: add to the list
      table.insert(winners, playerColor)
    end
  end

  return winners
end

function isPointInBucket(targetPos, data)
  -- Calculate the half-extents (distance from center to edge)
  local halfX = data.size[1] * 0.5
  local halfY = data.size[2] * 0.5
  local halfZ = data.size[3] * 0.5

  -- Check if target is within the bounds of each axis
  local inX = targetPos.x >= (data.pos[1] - halfX) and targetPos.x <= (data.pos[1] + halfX)
  if not inX then return false end

  local inY = targetPos.y >= (data.pos[2] - halfY) and targetPos.y <= (data.pos[2] + halfY)
  if not inY then return false end

  local inZ = targetPos.z >= (data.pos[3] - halfZ) and targetPos.z <= (data.pos[3] + halfZ)
  if not inZ then return false end

  return true
end

function calculateScores()
  resolveFearFromGuardians()
  local winners          = {}
  local top              = { score = 0, templeOrder = 9, research = 0 }
  local tiebreaker       = false
  local trackInfo        = RESEARCH_TRACK_DATA[options.researchTrack]

  local darkTabletValue  = getDarkTabletValue()
  local totalDarkTablets = {}
  local altarVp          = {}

  if options.researchTrack == 7 then
    -- check for altars with artifact
    for _, data in ipairs(trackInfo.altarData) do
      local searchResult = SearchLib.atPosition(data.position, "isCard")
      if #searchResult > 0 then
        local altarTablets = {}

        -- count tablets for this altar
        for i, playerColor in ipairs(COLOR_LIST) do
          local tabletPos               = data.position + trackInfo.altarOffsets[i]
          local tabletHits              = SearchLib.atPosition(tabletPos, "isResource")
          altarTablets[playerColor]     = (altarTablets[playerColor] or 0) + #tabletHits
          totalDarkTablets[playerColor] = (totalDarkTablets[playerColor] or 0) + #tabletHits
        end

        -- figure out which players get the altar points
        local altarWinners = getAltarWinners(altarTablets)
        for _, playerColor in ipairs(altarWinners) do
          altarVp[playerColor] = (altarVp[playerColor] or 0) + data.value
        end
      end
    end
  end

  for _, playerColor in ipairs(seatedPlayerColors) do
    local subscores             = { research = 0, temple = 0, idol = 0, guardian = 0, cards = 0, fear = 0 }
    local templeOrder           = 9
    local scoredMagnifyingGlass = false

    -- score the position in the temple
    if trackInfo.templePositions then
      for i, pos in ipairs(trackInfo.templePositions) do
        for _, obj in ipairs(SearchLib.atPosition(pos)) do
          if string.find(obj.getName(), 'Magnifying') ~= nil then
            if obj.getDescription() == playerColor then
              subscores.research    = subscores.research + trackInfo.templePoints[i]
              templeOrder           = i
              scoredMagnifyingGlass = true
            end
            break
          end
        end
      end
    end

    -- score the research position of the magnifying glass / journal / lantern
    for _, name in ipairs(RESEARCH_TOKENS) do
      if name ~= "magnifying" or not scoredMagnifyingGlass then -- ensure that MG is only scored once
        local token = getResearchToken(name, playerColor)
        if token ~= nil then
          -- special handling for the Spider Temple
          if options.researchTrack == 7 then
            for i, row in ipairs(trackInfo.rows) do
              -- check if the token is in the defined bucket
              if isPointInBucket(token.getPosition(), row.bucketData) then
                subscores.research = subscores.research + (row[name] or 0)
              end
            end
          else
            local posZ = token.getPosition()[3]
            for i, row in ipairs(trackInfo.rows) do
              if posZ >= row.z then
                -- take the magnifying glass score for lantern
                if name == "lantern" then name = "magnifying" end
                subscores.research = subscores.research + (row[name] or 0)
                break
              end
            end
          end
        end
      end
    end

    -- score uncovered idol spaces
    if not (options.solo and playerColor == 'Red') then
      subscores.idol = subscores.idol + scoreUncoveredIdolSlots(playerColor)
    end

    -- exclude ritual pile for the Mystic
    local excludeMap = {}
    if options.playerBoards[playerColor] == 6 then
      local ritualPosition = PlayermatApi.getZonePosition(playerColor, "Ritual")
      for _, object in ipairs(SearchLib.atPosition(ritualPosition, "isCardOrDeck")) do
        excludeMap[object] = true
      end
    end

    -- scoring function
    function scoreObject(object, scoreIdols)
      if (object.type == 'Deck' or object.getName() == 'Fear') and excludeMap[object] then return end
      if object.type == 'Deck' then
        -- cards in decks
        for _, cardData in ipairs(object.getData().ContainedObjects) do
          if cardData.Tags and cardData.Tags[1] == 'idol' then
            if scoreIdols then subscores.idol = subscores.idol + 3 end
          elseif cardData.Tags and cardData.Tags[1] == 'guardian' then
            subscores.guardian = subscores.guardian + 5
          else
            -- regular cards
            local score = getVpValue(cardData.GMNotes)
            if score < 0 then
              subscores.fear = subscores.fear + score
            else
              subscores.cards = subscores.cards + score
            end
          end
        end
      elseif object.hasTag('temple') then
        subscores.temple = subscores.temple + (tonumber(object.getDescription()) or 0)
      elseif object.hasTag('idol') then
        if scoreIdols then subscores.idol = subscores.idol + 3 end
      elseif object.hasTag('guardian') then
        subscores.guardian = subscores.guardian + 5
      elseif object.type == 'Custom_Token' and object.getName() == 'Fear' then
        subscores.fear = subscores.fear - 2
      elseif object.type == "Card" then
        -- regular cards
        local score = getVpValue(object.getGMNotes())
        if score < 0 then
          subscores.fear = subscores.fear + score
        else
          subscores.cards = subscores.cards + score
        end
      end
    end

    -- score all other objects
    local scoreIdols = true
    if options.solo and playerColor == 'Red' then scoreIdols = false end

    -- make list of objects to score
    local scoreTheseObjects = {}

    -- get all objects in play zone
    for _, object in ipairs(getObjectFromGUID(PLAYER_VARS[playerColor].allZoneGuid).getObjects()) do
      table.insert(scoreTheseObjects, object)
    end

    -- get objects from hand
    for _, object in ipairs(Player[playerColor].getHandObjects()) do
      table.insert(scoreTheseObjects, object)
    end

    -- perform the scoring
    for _, object in ipairs(scoreTheseObjects) do
      scoreObject(object, scoreIdols)
    end

    -- score altars / dark tablets for Spider Temple
    subscores.darkTablets = ((totalDarkTablets[playerColor] or 0) * darkTabletValue) or 0
    subscores.altars      = altarVp[playerColor] or 0

    -- score idols for solo rival
    if options.solo and playerColor == 'Red' then
      -- check for purple site action
      local baseIdolPoints = 2

      if findPurpleSiteActionCard(solo.zones.discard) or findPurpleSiteActionCard(solo.zones.deck) then
        baseIdolPoints = 3
      end

      local all      = countIdols(PLAYER_VARS[playerColor].allZoneGuid)
      local dupes    = countIdols(solo.zones.idol.dupe)
      subscores.idol = all * baseIdolPoints + (all - dupes)
    end

    local total = 0
    for category, subscore in pairs(subscores) do
      total = total + subscore
      UI.setAttribute(category .. playerColor, "text", subscore)
    end

    -- maybe hide Spider Temple rows
    if options.researchTrack ~= 7 then
      UI.setAttribute("ScoreboardRow-altars", "active", false)
      UI.setAttribute("ScoreboardRow-darkTablets", "active", false)
      UI.setAttribute("ScoreboardRow-altars" .. playerColor, "active", false)
      UI.setAttribute("ScoreboardRow-darkTablets" .. playerColor, "active", false)
    end

    UI.setAttribute('total' .. playerColor, "text", total)
    UI.setAttribute('name' .. playerColor, "text", getPlayerName(playerColor, true))
    UI.setAttribute('leader' .. playerColor, "text", PLAYERMAT_STATE_TO_LEADER[options.playerBoards[playerColor]])

    if total > top.score then
      tiebreaker = false
      top        = { score = total, templeOrder = templeOrder, research = subscores.research }
      winners    = { playerColor }
    elseif total == top.score then
      tiebreaker = true
      if templeOrder < top.templeOrder then
        top = { score = total, templeOrder = templeOrder, research = subscores.research }
        winners = { playerColor }
      elseif templeOrder == top.templeOrder then
        if subscores.research > top.research then
          top = { score = total, templeOrder = templeOrder, research = subscores.research }
          winners = { playerColor }
        elseif subscores.research == top.research then
          table.insert(winners, playerColor)
        end
      end
    end
  end

  UI.setAttribute('scoreboard', 'active', true)
  for i, playerColor in ipairs(seatedPlayerColors) do
    UI.setAttribute('scoreboard' .. playerColor, 'offsetXY', 210 + (i - 1) * 70 .. ' -140')
    UI.setAttribute('scoreboard' .. playerColor, 'active', true)
  end

  if #winners == 1 then
    if tiebreaker then
      broadcastToAll(getPlayerName(winners[1]) .. ' wins by tiebreaker!')
    else
      broadcastToAll(getPlayerName(winners[1]) .. ' wins!')
    end
  elseif #winners > 1 then
    broadcastToAll(listToText(winners, true) .. ' are tied!')
  end

  local buttonBlock = getObjectFromGUID(BUTTON_BLOCK_GUID)
  if #buttonBlock.getButtons() < 3 then
    local params = {
      function_owner = self,
      label          = 'Toggle Scoreboard',
      click_function = 'toggleScoreboardButton',
      position       = { 0, 1.5, 0 },
      width          = 2400,
      height         = 500,
      font_size      = 250
    }
    buttonBlock.createButton(params)
  end
end

-- score empty idol slots
function scoreUncoveredIdolSlots(playerColor)
  local idolSlotPoints    = 0
  local mat               = PlayermatApi.getPlayermats(playerColor)
  local leader            = PLAYERMAT_STATE_TO_LEADER[options.playerBoards[playerColor]]
  local idolSnapPositions = getLocalIdolSlotPositions(playerColor)

  for i, points in ipairs(IDOL_SLOT_DATA[leader]) do
    -- get all objects in this spot
    local searchResult = SearchLib.atPosition(mat.positionToWorld(idolSnapPositions[i]), "isIdol")

    -- give points if empty
    if #searchResult == 0 then
      idolSlotPoints = idolSlotPoints + points
    end
  end

  return idolSlotPoints
end

function toggleScoreboardButton(obj, clickColor, alt)
  if setupInProgress or not isSeated(clickColor) and clickColor ~= 'Black' then return end
  if UI.getAttribute('scoreboard', 'active') == 'true' or UI.getAttribute('scoreboard', 'active') == 'True' then
    UI.setAttribute('scoreboard', 'active', false)
    for playerColor, _ in pairs(PLAYER_VARS) do
      UI.setAttribute('scoreboard' .. playerColor, 'active', false)
    end
  else
    UI.setAttribute('scoreboard', 'active', true)
    for _, playerColor in ipairs(seatedPlayerColors) do
      UI.setAttribute('scoreboard' .. playerColor, 'active', true)
    end
  end
end

-- MARK: EVENTS

function onPlayerTurn(player, previousPlayer)
  -- tts bug: when rewinding time or saving a script, onPlayerTurn triggers with non-nil player that has '' color
  if not doneLoading or setupInProgress or round < 1 or player == nil or player.color == '' then return end
  turn = player.color
  Wait.time(function()
    local currentPlayerTent = nil
    local atLeastOneFaceupTent = false
    for _, playerColor in ipairs(seatedPlayerColors) do
      local tent = getTent(playerColor)
      if tent ~= nil then
        if playerColor == player.color then currentPlayerTent = tent end
        if not tent.is_face_down then atLeastOneFaceupTent = true end
      end
    end

    -- handle passing
    if atLeastOneFaceupTent and currentPlayerTent ~= nil and currentPlayerTent.is_face_down then
      Turns.turn_color = Turns.getNextTurnColor()
      return
    end

    for _, playerColor in ipairs(COLOR_LIST) do
      editClockQueue(playerColor, playerColor ~= player.color)
    end

    startLuaCoroutine(Global, "refillRowCoroutine")
  end, 0.01)
end

function onObjectEnterContainer(container, enteringObject)
  editResourceBagCounter(container)
end

function onObjectLeaveContainer(container, leavingObject)
  addExileMenu(leavingObject)
  addGetRewardsMenu(leavingObject)
  addReturnMenu(leavingObject)
  addTrashMenu(leavingObject)
  editResourceBagCounter(container)
end

-- check if this is an object with states (and prevent state switching)
function onObjectNumberTyped(hoveredObject, playerColor, number)
  local states = hoveredObject.getStates()
  if states ~= nil and #states > 0 then
    broadcastToColor("Use the context menu for state changing.", playerColor)
    return true
  end
end

function editResourceBagCounter(container)
  if round > 0 and container.hasTag('resource') and container.type == 'Bag' then -- stacks count as containers, so need to specify bags
    local playerColor  = container.getDescription()
    local resource     = container.getGMNotes()
    local buttonParent = nil
    if container.getName() == 'suitcase' then
      buttonParent = container
    else
      buttonParent = getObjectFromGUID(PLAYER_VARS[playerColor].resourceBagZones[resource])
    end
    buttonParent.editButton({ index = 0, label = container.getQuantity() })
  end
end

function filterObjectEnterContainer(container, object)
  if container.hasTag('resource') then
    if object.getGMNotes() ~= container.getGMNotes() then return false end
  end
  return true
end

-- MARK: CONTEXT MENU

function addExileMenu(object)
  if object.type == 'Tile' and object.getName() == 'Fear' or object.type == 'Card' and (#object.getTags() == 0 or object.hasTag('artifact') or object.hasTag('item')) then
    object.addContextMenuItem('Exile', function() exile(object) end)
  end
end

function addGetRewardsMenu(object)
  if object.type == 'Card' and (object.hasTag('site1') or object.hasTag('site2')) then
    object.addContextMenuItem('Get Rewards', function(playerColor) deliverRewards(playerColor, object) end)
  end
end

function addReturnMenu(object)
  if object.type == 'Card' and (object.hasTag('site1') or object.hasTag('site2') or object.hasTag('guardian')) then
    object.addContextMenuItem('Deck Bottom', function() returnToBottom(object) end)
  end
end

function addAssistantCycleMenu()
  for _, guid in ipairs(ASSISTANT_ZONES) do
    for _, object in ipairs(getObjectFromGUID(guid).getObjects()) do
      if object.type == 'Deck' and object.hasTag('assistant') then
        object.addContextMenuItem('Cycle to Bottom', function() cycleAssistant(object) end)
        break
      end
    end
  end
end

function addTrashMenu(object)
  if object.hasTag('research') and object.getDescription() == '' then
    object.addContextMenuItem('Trash', function(playerColor) trashObject(playerColor, object) end)
  end
end

function exile(object)
  if object == nil then return end
  if object.type == 'Tile' then
    object.destruct()
  elseif object.type == "Card" then
    local pos, rot
    local md = getMetaData(object)

    if not md or not md.type or md.type == "Starter" then
      pos = OTHER_EXILED_SPOT.pos
      rot = OTHER_EXILED_SPOT.rot
    else
      pos, rot = getCardBoardLocation(md.type, "exiled")
    end

    DeckLib.placeOrMergeIntoDeck(object, pos, rot)

    -- there needs to be a small delay before moving another card, if this exile ended with anything other than putObject to a deck
    return true
  end
end

function returnToBottom(object)
  function returnToBottomCoroutine()
    local zoneGuid = DECK_ZONE_GUIDS.guardians
    if object.hasTag('site1') then
      zoneGuid = DECK_ZONE_GUIDS.sites1
    elseif object.hasTag('site2') then
      zoneGuid = DECK_ZONE_GUIDS.sites2
    end

    local zone = getObjectFromGUID(zoneGuid)
    local toPos = zone.getPosition():setAt("y", tileY)
    local deck = nil
    for _, obj in ipairs(zone.getObjects()) do
      if obj.type == 'Card' or obj.type == 'Deck' then
        deck = obj
        obj.setPositionSmooth(toPos + Vector(0, 0.5, 0), false, true)
      end
    end

    wait(0.2)

    if deck ~= nil then deck.lock() end
    object.unlock()
    object.setRotation(facedown)
    object.setPositionSmooth(toPos, false, true)

    wait(0.3)

    if deck == nil then
      object.setPosition(toPos)
    else
      deck.unlock()
      deck.putObject(object)
    end

    return 1
  end

  startLuaCoroutine(Global, 'returnToBottomCoroutine')
end

function cycleAssistant(object)
  object.takeObject({ position = object.getPosition():setAt("y", tileY), rotation = object.getRotation() })
end

function trashObject(playerColor, object)
  local objs = getObjectsWithAllTags({ "Trash", playerColor })
  if #objs > 0 then
    objs[1].putObject(object)
    return
  end
  broadcastToColor("Couldn't find the trash for you!", playerColor, "Red")
end

-- MARK: SOLO RIVAL

function rivalBuy(action, buyHighestPoints)
  local startIndex = 1
  local endIndex = round
  if action == 'item' then
    startIndex = round + 1
    endIndex = 6
  end

  local highest = 0
  local highestCards = {}
  local lowest = 5
  local lowestCards = {}
  for i = startIndex, endIndex do
    local card   = SearchLib.atPosition(getMarketPos(i), "isCard")[1]
    local points = JSON.decode(card.getGMNotes()).points
    if points > highest then
      highest = points
      highestCards = { card }
    elseif points == highest then
      table.insert(highestCards, card)
    end

    if points < lowest then
      lowest = points
      lowestCards = { card }
    elseif points == lowest then
      table.insert(lowestCards, card)
    end
  end

  if buyHighestPoints then
    broadcastToAll('Rival buys an ' .. action .. ' with highest point value.')
    highestCards[math.random(1, #highestCards)].setPositionSmooth(solo.acquiredStuffPositions.buy, false, false)
  else
    broadcastToAll('Rival buys an ' .. action .. ' with lowest point value.')
    lowestCards[math.random(1, #lowestCards)].setPositionSmooth(solo.acquiredStuffPositions.buy, false, false)
  end
end

function rivalCheckSiteForResource(siteInfo, resource, campsite)
  -- TODO: Fix this
  --[[
  function rivalCheckSiteForOpenPawnPos(pawnSpaceGuid)
    local pawnZone = getObjectFromGUID(pawnSpaceGuid)
    local zonePos = pawnZone.getPosition()
    for _, object in ipairs(pawnZone.getObjects()) do
      if object.hasTag('pawn') then return nil end
    end
    return { zonePos[1], pawnY, zonePos[3] }
  end

  if campsite then
    if string.find(getObjectFromGUID(siteInfo.guid).getGMNotes(), resource) ~= nil then
      return rivalCheckSiteForOpenPawnPos(siteInfo.pawnSpaces[1])
    end
  else
    if siteInfo.discovered then
      for _, object in ipairs(getObjectFromGUID(siteInfo.guid).getObjects()) do
        if object.hasTag('site1') or object.hasTag('site2') then
          if string.find(object.getGMNotes(), resource) ~= nil then
            return rivalCheckSiteForOpenPawnPos(siteInfo.pawnSpaces[1])
          end
          break
        end
      end
    end
  end
  ]]

  return nil
end

function rivalMovePawn(toPos)
  local pawnNo = soloStatus.pawnsOut + 1
  local pawn = getObjectFromGUID(solo.pawns[pawnNo])
  if pawn == nil then
    broadcastToAll('Error: unable to locate rival pawn ' .. pawnNo .. '.')
    return false
  end
  pawn.setRotationSmooth(faceup, false, true)
  pawn.setPositionSmooth(toPos, false, false)
  soloStatus.pawnsOut = pawnNo
  return true
end

function rivalTurnCoroutine()
  getObjectFromGUID(PLAYER_VARS.Red.playAreaZoneGuid).editButton({ index = 0, label = buttonLabelsRival.busy })
  broadcastToAll("Rival's turn.", 'Red')
  wait(0.5)
  local deckPos = solo.deckPositions[2]
  local actionCard = drawCard(solo.zones.deck, faceup, { deckPos[1], tileY + 0.3, deckPos[3] })
  if actionCard == nil or actionCard.getDescription() == nil or actionCard.getDescription() == '' then
    broadcastToAll('Rival has no more action cards.')
    wait(1.2)
    broadcastToAll(getPlayerName(seatedPlayerColors[1], true) .. "'s turn.", seatedPlayerColors[1])
    setupButtonRivalTurn()
    return 1
  end

  local action = actionCard.getDescription()
  local gmNotes = actionCard.getGMNotes()
  if action == 'artifact' or action == 'item' then
    refillRowCoroutine()
    if gmNotes == 'green' then
      rivalBuy(action, false)
    else
      rivalBuy(action, true)
    end
    soloStatus.fulfilledObjectives[action] = true
    if gmNotes == 'purple' then
      wait(1.5)
      local secondAction = 'item'
      if action == 'item' then secondAction = 'artifact' end

      rivalBuy(secondAction, false)
      soloStatus.fulfilledObjectives[secondAction] = true
    end
    wait(1.2)
    refillRowCoroutine()
  elseif action == 'arch' then
    local placedPawn = false
    local resourceText = { t = 'a tablet', a = 'an arrowhead', j = 'a jewel', c = 'a coin', s = 'a compass' }

    -- TODO: Fix this
    --[[
    for i = 1, 4 do
      local possiblePawnPos = {}
      local campsite = false
      if i == 4 then campsite = true end
      for _, siteInfo in ipairs(siteLevels[i]) do
        local pos = rivalCheckSiteForResource(siteInfo, gmNotes, campsite)
        if pos ~= nil then table.insert(possiblePawnPos, pos) end
      end

      if #possiblePawnPos > 0 then
        broadcastToAll('Rival digs at a site that offers ' .. resourceText[gmNotes] .. '.')
        wait(0.5)
        rivalMovePawn(possiblePawnPos[math.random(1, #possiblePawnPos)])
        if soloStatus.pawnsOut > 2 then soloStatus.fulfilledObjectives.arch = true end
        placedPawn = true
        break
      end
    end
    if not placedPawn then broadcastToAll('No available site that offers ' .. resourceText[gmNotes] .. '.') end
    ]]
  elseif action == 'site' then
    if gmNotes == 'green' and round == 5 then
      broadcastToAll('Rival does not take this action in round 5.')
    else
      local startIndex = 2
      local endIndex   = 3
      local level      = 1
      if round > 3 then
        startIndex = 1
        endIndex   = 1
        level      = 2
      end

      -- TODO: Fix this
      --[[

      local possibleSiteInfos = {}
      for i = startIndex, endIndex do
        for _, siteInfo in ipairs(siteLevels[i]) do
          if not siteInfo.discovered then
            table.insert(possibleSiteInfos, siteInfo)
          else
            -- sites can become undiscovered so check for site card
            local discovered = false
            for _, object in ipairs(getObjectFromGUID(siteInfo.guid).getObjects()) do
              if object.hasTag('site1') or object.hasTag('site2') then
                discovered = true
                break
              end
            end
            if not discovered then table.insert(possibleSiteInfos, siteInfo) end
          end
        end
      end

      if #possibleSiteInfos > 0 then
        local siteInfo = possibleSiteInfos[math.random(1, #possibleSiteInfos)]
        broadcastToAll('Rival discovers a random level ' .. level .. ' site.')
        wait(0.5)

        local toPos = getObjectFromGUID(siteInfo.pawnSpaces[1]).getPosition()
        local success = rivalMovePawn({ toPos[1], pawnY, toPos[3] })
        if soloStatus.pawnsOut > 2 then soloStatus.fulfilledObjectives.arch = true end

        if success then
          wait(1.2)
          local siteZone = getObjectFromGUID(siteInfo.guid)
          for _, object in ipairs(siteZone.getObjects()) do
            if object.hasTag('idol') then
              local dupeZonePos = getObjectFromGUID(solo.zones.idol.dupe).getPosition()
              local dupePos = { dupeZonePos[1], tileY + 0.4, dupeZonePos[3] }
              if object.is_face_down then
                object.setRotationSmooth({ 0, 90, 180 }, false, true)
                object.setPositionSmooth(dupePos, false, false)
              else
                local idolReward = object.getGMNotes()
                local isDupe = false

                -- look for same type of idol to determine where this goes
                local idolZone = nil
                local idolPos = nil
                idolZone = getObjectFromGUID(solo.zones.idol[idolReward])
                idolPos = idolZone.getPosition()

                for _, obj in ipairs(idolZone.getObjects()) do
                  if obj.hasTag('idol') then
                    isDupe = true
                    break
                  end
                end
                if isDupe then
                  object.setRotationSmooth({ 0, 90, 0 }, false, true)
                  object.setPositionSmooth(dupePos, false, false)
                else
                  object.setRotationSmooth(faceup, false, true)
                  object.setPositionSmooth({ idolPos[1], tileY, idolPos[3] }, false, false)
                end
              end
              wait(0.5)
            end
          end

          local alt = true
          if (gmNotes == 'green' or gmNotes == 'purple') and (round == 1 or round == 3 or round == 5) then
            alt = false
          elseif gmNotes == 'red' and (round == 2 or round == 4) then
            alt = false
          end
          discoverButton(siteZone, 'Red', alt)
          soloStatus.fulfilledObjectives.site = true
          if not alt then wait(0.5) end
        end
      else
        broadcastToAll('No available site to discover.')
      end

      ]]
    end
  elseif action == 'guardian' then
    if gmNotes == 'green' and round == 5 then
      broadcastToAll('Rival does not take this action in round 5.')
    else
      if options.researchTrack == 4 and soloStatus.magnifying.row == 5 then
        -- overcome lizard temple guardian first
        local searchResult = SearchLib.atPosition(RESEARCH_TRACK_DATA[4].guardianPos, "isGuardian")
        if #searchResult > 0 and not searchResult[1].is_face_down then
          broadcastToAll('Rival overcomes the Lizard Temple guardian.')
          wait(0.5)
          searchResult[1].setRotation(faceup)
          searchResult[1].setPositionSmooth(solo.acquiredStuffPositions.guardian, false, false)
          soloStatus.fulfilledObjectives.guardian = true
        end
      end

      if not soloStatus.fulfilledObjectives.guardian then
        -- overcome a guardian on the main board

        -- TODO: Repair this
        --[[
        for i, siteLevel in ipairs(siteLevels) do
          local possibleGuardians = {}
          for _, siteInfo in ipairs(siteLevel) do
            if i == 4 or siteInfo.discovered then
              -- check for guardian
              local guardian = nil
              for _, object in ipairs(getObjectFromGUID(siteInfo.guid).getObjects()) do
                if object.hasTag('guardian') then
                  guardian = object
                  break
                end
              end
              if guardian ~= nil then

                for _, object in ipairs(getObjectFromGUID(siteInfo.pawnSpaces[1]).getObjects()) do
                  if object.hasTag('pawn') then
                    if object.getDescription() == 'Red' then table.insert(possibleGuardians, guardian) end
                    break
                  end
                end
              end
            end
          end

          if #possibleGuardians > 0 then
            local guardian = possibleGuardians[math.random(1, #possibleGuardians)]
            broadcastToAll('Rival overcomes a guardian.')
            wait(0.5)
            guardian.setRotation(faceup)
            guardian.setPositionSmooth(solo.acquiredStuffPositions.guardian, false, false)
            soloStatus.fulfilledObjectives.guardian = true
            break
          end
        end

        ]]
      end

      if not soloStatus.fulfilledObjectives.guardian then
        -- research with magnifying
        broadcastToAll('No guardians to overcome.')
        wait(1)
        soloStatus.fulfilledObjectives.research = rivalResearch('magnifying', true)
      end

      if gmNotes == 'purple' then
        -- research with journal
        wait(1.5)
        if soloStatus.journal.row > soloStatus.magnifying.row or soloStatus.journal.row == 0 and soloStatus.magnifying.row > 0 then
          rivalResearch('journal', true)
        end
      end
    end
  elseif action == 'research' then
    if gmNotes == 'green' and round == 5 then
      broadcastToAll('Rival does not take this action in round 5.')
    else
      soloStatus.fulfilledObjectives.research = rivalResearch('magnifying')
      if gmNotes == 'purple' and round == 5 then
        wait(1.5)
        rivalResearch('magnifying')
      end
    end
  end
  wait(1.2)

  -- draw objectives or check fulfillment
  if options.objectives > 0 then
    local objectivesDeckZone = getObjectFromGUID(solo.zones.objectivesDeck)
    if soloStatus.firstTurn then
      for i = 1, options.objectives do
        local toPos = getObjectFromGUID(solo.zones.objectives[i]).getPosition()
        local card = drawCard(objectivesDeckZone, faceup, toPos)
        wait(0.16)
        if card == nil then break end
      end
      wait(0.4)
    end

    local objectiveMessages = {
      artifact = 'buy an artifact.',
      item     = 'buy an item.',
      site     = 'discover a new site.',
      research = 'advance your magnifying glass.',
      arch     = 'send many archaeologists to the main board.'
    }
    for _, guid in ipairs(solo.zones.objectives) do
      local objectiveCardZone = getObjectFromGUID(guid)
      for _, object in ipairs(objectiveCardZone.getObjects()) do
        if object.type == 'Card' then
          local objective = object.getDescription()
          if not object.is_face_down and objective ~= nil and soloStatus.fulfilledObjectives[objective] then
            if soloStatus.firstTurn then
              broadcastToAll('Replacing a completed objective.')
              object.setRotation(facedown)
              object.setPositionSmooth(objectivesDeckZone.getPosition(), false, false)
              drawCard(objectivesDeckZone, faceup, objectiveCardZone.getPosition())
              wait(1.2)
            else
              broadcastToAll('Rival completes objective: ' .. objectiveMessages[objective])
              wait(0.5)
              object.flip()
              wait(0.5)
              getObjectFromGUID(BAG_GUIDS.soloTempleTiles).takeObject({
                position = solo.acquiredStuffPositions.templeTile[math.random(1, 6)],
                rotation = faceup
              })
              wait(1.2)
            end
          end
          break
        end
      end
    end
  end
  soloStatus.firstTurn = false

  local tent = getTent(seatedPlayerColors[1])
  if tent == nil or not tent.is_face_down or drawCard(solo.zones.deck, nil, nil, true) == nil then
    broadcastToAll(getPlayerName(seatedPlayerColors[1], true) .. "'s turn.", seatedPlayerColors[1])
    setupButtonRivalTurn()
  else
    rivalTurnCoroutine()
  end
  return 1
end

function rivalResearch(id, doNotTakeAssistant)
  local tokenName = id
  if id == 'magnifying' then tokenName = tokenName .. ' glass' end
  broadcastToAll('Rival researches with its ' .. tokenName .. '.')
  wait(0.5)

  local token = getResearchToken(id, "Red")
  if token == nil then
    broadcastToAll('Error: unable to locate ' .. tokenName .. '.')
    return false
  end
  local trackInfo = RESEARCH_TRACK_DATA[options.researchTrack]

  if options.researchTrack == 3 and soloStatus[id].row == 7 and id == 'magnifying' then
    local toPos = trackInfo.artifactPos
    token.setRotationSmooth(faceup, false, true)
    token.setPositionSmooth({ toPos[1], toPos[2] + 0.4, toPos[3] }, false, false)
    soloStatus[id].row = 5
    soloStatus[id].path = 1
    return true
  end

  if id == 'magnifying' and soloStatus[id].row == 1 or id == 'journal' and soloStatus[id].row == 2 then
    wait(1.2)
    function moveSilver(index)
      for _, templeTilePosition in ipairs(trackInfo.templeTileData[2].positions) do
        local searchResult = SearchLib.atPosition(templeTilePosition, "isTempleTile")
        if #searchResult > 0 then
          broadcastToAll('Rival takes a silver temple tile.')
          searchResult[1].setRotation(faceup)
          searchResult[1].setPositionSmooth(solo.acquiredStuffPositions.templeTileSilver, false, false)
          return true
        end
      end
      return false
    end

    local rand = math.random(4, 5)
    local silverFound = moveSilver(rand)
    if not silverFound then
      if rand == 4 then
        silverFound = moveSilver(5)
      else
        silverFound = moveSilver(4)
      end
    end
    if not silverFound then broadcastToAll('No silver temple tiles found.') end
    return false
  elseif id == 'magnifying' and soloStatus[id].row == 2 then
    for i, pos in ipairs(trackInfo.templePositions) do
      local occupied = false
      for _, obj in ipairs(SearchLib.atPosition(pos)) do
        if string.find(obj.getName(), 'Magnifying') ~= nil then occupied = true end
      end

      if not occupied then
        token.setRotationSmooth(faceup, false, true)
        token.setPositionSmooth(pos, false, false)
        soloStatus[id].row = 1
        soloStatus[id].path = 1
        break
      end
    end
    rivalTakeResearchBonus(trackInfo.rows[1].bonusPos)
    return true
  end

  local nextRowIndex = nil
  local forwardPaths = nil
  if soloStatus[id].row == 0 then
    nextRowIndex = #trackInfo.rows
    forwardPaths = {}
    for i, _ in ipairs(trackInfo.rows[nextRowIndex].paths) do
      table.insert(forwardPaths, i)
    end
  else
    nextRowIndex = soloStatus[id].row - 1
    forwardPaths = trackInfo.rows[soloStatus[id].row].paths[soloStatus[id].path].forward
  end

  local nextRow       = trackInfo.rows[nextRowIndex]
  local nextPathIndex = forwardPaths[math.random(1, #forwardPaths)]
  local nextPath      = nextRow.paths[nextPathIndex]
  local toPos         = nextPath.pos

  if toPos ~= nil then
    token.setRotationSmooth(faceup, false, true)
    token.setPositionSmooth({ toPos[1], toPos[2] + 0.4, toPos[3] }, false, false)
    soloStatus[id].row = nextRowIndex
    soloStatus[id].path = nextPathIndex
    if nextPath.bonus then rivalTakeResearchBonus(toPos) end
  else
    -- the next path has multiple bonus tiles; pick one and move to its spot
    local bonusTile = nil
    local bonusPositions = {} -- duplicate of nextPath.bonusPos for removing values
    for _, pos in ipairs(nextPath.bonusPos) do
      table.insert(bonusPositions, pos)
    end

    for i = 1, #bonusPositions do
      local bonusIndex = math.random(1, #bonusPositions)
      local bonusPos = bonusPositions[bonusIndex]
      for _, object in ipairs(getResearchObjects()) do
        if object.getDescription() == '' and not object.is_face_down then
          if positionIsClose(object.getPosition(), bonusPos) then
            bonusTile = object
            toPos = bonusPos
            break
          end
        end
      end
      if bonusTile == nil then
        table.remove(bonusPositions, bonusIndex)
      else
        break
      end
    end

    if toPos == nil then toPos = nextPath.bonusPos[1] end
    token.setRotationSmooth(faceup, false, true)
    token.setPositionSmooth({ toPos[1], toPos[2] + 0.4, toPos[3] }, false, false)
    soloStatus[id].row = nextRowIndex
    soloStatus[id].path = nextPathIndex
    if bonusTile ~= nil then
      wait(1.2)
      broadcastToAll('Rival removes a research bonus tile.')
      bonusTile.setRotation(facedown)
      bonusTile.setPositionSmooth(solo.acquiredStuffPositions.researchBonus, false, false)
    end
  end

  if id == 'magnifying' and nextRow.assistant then
    wait(1.2)
    if options.researchTrack == 2 and soloStatus[id].row == 5 then
      local card = drawCardFromPosition(trackInfo.assistantPos, solo.acquiredStuffPositions.assistant, faceup)
      if card ~= nil then
        broadcastToAll('Rival rescues an assistant from the research track.')
        wait(1.2)
      end
    end

    if doNotTakeAssistant then
      broadcastToAll('Rival does not remove an assistant from the supply board for this action.')
    else
      local most = 0
      local possibleZones = {}
      for _, guid in ipairs(ASSISTANT_ZONES) do
        local zone = getObjectFromGUID(guid)
        local obj = drawCard(zone, nil, nil, true)
        if obj ~= nil then
          local quantity = 0
          if obj.type == 'Card' then
            quantity = 1
          elseif obj.type == 'Deck' then
            quantity = obj.getQuantity()
          end

          if quantity > most then
            most = quantity
            possibleZones = { zone }
          elseif quantity == most then
            table.insert(possibleZones, zone)
          end
        end
      end
      if #possibleZones > 0 then
        broadcastToAll('Rival removes an assistant.')
        drawCard(possibleZones[math.random(1, #possibleZones)], faceup, solo.acquiredStuffPositions.assistant)
      end
    end
  end
  return true
end

function getResearchObjects()
  if options.researchTrack < 7 then
    local track = getObjectByTag("ResearchTrack")
    if track then
      return SearchLib.onObject(track, "isResearchTile")
    else
      return {}
    end
  elseif options.researchTrack == 7 then
    return SearchLib.inArea(Vector(15.22, 2, -5.3), nil, Vector(28, 1.5, 40), "isResearchTile")
  elseif options.researchTrack == 8 then
    return SearchLib.inArea(Vector(17.75, 2.25, -3), nil, Vector(22, 1.50, 45), "isResearchTile")
  end
end

function rivalTakeResearchBonus(bonusPos)
  for _, object in ipairs(getResearchObjects()) do
    if object.getDescription() == '' and not object.is_face_down then
      if positionIsClose(object.getPosition(), bonusPos) then
        wait(1.2)
        broadcastToAll('Rival removes a research bonus tile.')
        object.setRotation(facedown)
        object.setPositionSmooth(solo.acquiredStuffPositions.researchBonus, false, false)
        break
      end
    end
  end
end

function rivalTurnButton(buttonZone, clickColor, alt)
  if round < 1 or not doneLoading or setupInProgress or not isSeated(clickColor) and clickColor ~= 'Black' then return end
  local button = buttonZone.getButtons()[1]
  if button.label == buttonLabelsRival.ready then startLuaCoroutine(Global, 'rivalTurnCoroutine') end
end

-- MARK: UTIL

function getObjectByName(name)
  for _, o in ipairs(getObjects()) do
    if o.getName() == name then
      return o
    end
  end
end

function getObjectByTag(tag)
  for _, o in ipairs(getObjectsWithTag(tag)) do
    return o
  end
end

function editClockQueue(playerColor, pauseState)
  local waitName = "clock" .. playerColor

  if waitQueue[waitName] then
    Wait.stop(waitQueue[waitName])
  end

  waitQueue[waitName] = Wait.time(function() editClock(playerColor, pauseState) end, 0.1)
end

function editClock(playerColor, pauseState)
  local objects = getObjectsWithAllTags({ playerColor, "Time" })
  if #objects ~= 1 then return end

  if pauseState ~= nil then
    objects[1].Clock.paused = pauseState
  end
end

function positionIsClose(pos1, pos2)
  return math.abs(pos1[1] - pos2[1]) < 0.1 and math.abs(pos1[3] - pos2[3]) < 0.1
end

function drawCardFromPosition(deckPosition, position, rotation)
  for _, object in ipairs(SearchLib.atPosition(deckPosition, "isCardOrDeck")) do
    if object.type == 'Card' then
      if rotation then
        object.setRotation(rotation)
      end

      if position then
        object.setPositionSmooth(position, false, true)
      end

      return object
    elseif object.type == 'Deck' then
      return object.takeObject({ position = position, rotation = rotation })
    end
  end
end

function drawCard(zone, rotation, position, checkOnly)
  -- allow providing a zone GUID or an object reference
  if zone.type == nil then
    zone = getObjectFromGUID(zone)
  end

  if zone.type ~= "Scripting" then
    log("Invalid zone!")
    return
  end

  for _, object in ipairs(zone.getObjects()) do
    if checkOnly then
      if object.type == 'Card' or object.type == 'Deck' then return object end
    elseif object.type == 'Card' then
      if position ~= nil then
        object.setRotationSmooth(rotation, false, true)
        object.setPositionSmooth(position, false, true)
      end
      return object
    elseif object.type == 'Deck' then
      return object.takeObject({ position = position, rotation = rotation })
    end
  end
  return nil
end

function getPlayerName(playerColor, excludeHexColor)
  local name = Player[playerColor].steam_name or playerColor
  if not excludeHexColor then
    return addColorToString(playerColor, name)
  end
  return name
end

function isSeated(playerColor)
  for _, color in ipairs(seatedPlayerColors) do
    if color == playerColor then return true end
  end
  return false
end

function listToText(list, getPlayerNames)
  if list == nil or #list == 0 then return nil end
  local text = ''
  for i, item in ipairs(list) do
    if i > 1 then
      if #list == 2 then
        text = text .. ' and '
      else -- #list > 2
        if i == #list then
          text = text .. ', and '
        else
          text = text .. ', '
        end
      end
    end

    if getPlayerNames then
      text = text .. getPlayerName(item)
    else
      text = text .. item
    end
  end
  return text
end

function wait(t)
  local now = Time.time
  repeat coroutine.yield(0) until Time.time > now + t
end
